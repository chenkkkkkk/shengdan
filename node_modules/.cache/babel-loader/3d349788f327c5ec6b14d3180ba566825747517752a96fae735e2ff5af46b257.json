{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * tdesign v0.14.1\n * (c) 2022 TDesign Group\n * @license MIT\n */\n\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport { h, defineComponent, getCurrentInstance, reactive, toRefs, computed, ref, onMounted, nextTick, watch, resolveComponent, openBlock, createBlock, Transition, withCtx, createElementBlock, normalizeClass, normalizeStyle, createCommentVNode, createElementVNode, createVNode } from 'vue';\nimport { ErrorCircleFilledIcon, CheckCircleFilledIcon, CloseIcon } from 'tdesign-icons-vue-next';\nimport { isFunction } from 'lodash';\nimport messageProps from './props.js';\nimport config from '../config.js';\nimport '../shared/index.js';\nimport TNodeComponent from '../shared/render-tnode.js';\nimport { useEmitEvent } from '../shared/useEmitEvent/index.js';\nimport { useVModel } from '../shared/useVModel/index.js';\nimport { renderTNode, renderContent } from '../shared/render.js';\nimport '../shared/functions.js';\nimport '../shared/util.js';\nimport '../shared/component.js';\nimport '../shared/constants.js';\nimport '../shared/useToggle/index.js';\nimport '../shared/useCountDown/index.js';\nimport '@babel/runtime/helpers/asyncToGenerator';\nimport '@babel/runtime/regenerator';\nimport '@vueuse/core';\nimport '../shared/useCountDown/utils.js';\nimport '../shared/useDefault/index.js';\nimport 'lodash/camelCase';\nimport '../shared/useChildSlots/index.js';\nimport '@babel/runtime/helpers/toConsumableArray';\nimport '../shared/useTouch/index.js';\nimport '../shared/useScrollParent/index.js';\nimport '../shared/useExpose/index.js';\nimport '../shared/useTest/index.js';\nimport '@babel/runtime/helpers/typeof';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar prefix = config.prefix;\nvar name = \"\".concat(prefix, \"-message\");\nvar iconDefault = {\n  info: h(ErrorCircleFilledIcon),\n  success: h(CheckCircleFilledIcon),\n  warning: h(ErrorCircleFilledIcon),\n  error: h(ErrorCircleFilledIcon)\n};\nvar script = defineComponent({\n  name: name,\n  components: {\n    TNode: TNodeComponent\n  },\n  props: messageProps,\n  emits: [\"change\", \"open\", \"opened\", \"close\", \"closed\"],\n  setup: function setup(props, context) {\n    var emitEvent = useEmitEvent(props, context.emit);\n    var internalInstance = getCurrentInstance();\n    var state = reactive({\n      duration: 0,\n      offset: 0,\n      listWidth: 0,\n      itemWidth: 0,\n      scroll: {\n        marquee: false,\n        speed: 50,\n        loop: -1,\n        delay: 0\n      }\n    });\n    var _toRefs = toRefs(props),\n      visible = _toRefs.visible,\n      modelValue = _toRefs.modelValue;\n    var _useVModel = useVModel(visible, modelValue, props.defaultVisible, props.onChange),\n      _useVModel2 = _slicedToArray(_useVModel, 2),\n      currentVisible = _useVModel2[0],\n      setVisible = _useVModel2[1];\n    var rootClasses = computed(function () {\n      var _ref;\n      return _ref = {}, _defineProperty(_ref, name, true), _defineProperty(_ref, \"\".concat(name, \"--\").concat(props.theme), true), _defineProperty(_ref, \"\".concat(name, \"-align--\").concat(props.align), !!props.align), _ref;\n    });\n    var textWrapClasses = computed(function () {\n      var _ref2;\n      return _ref2 = {}, _defineProperty(_ref2, \"\".concat(name, \"__text-wrap\"), true), _defineProperty(_ref2, \"\".concat(name, \"__text-nowrap\"), props.marquee), _ref2;\n    });\n    var changeNumToStr = function changeNumToStr(arr) {\n      return arr.map(function (item) {\n        return typeof item === \"number\" ? \"\".concat(item, \"px\") : item;\n      });\n    };\n    var getMessageStylesOffset = function getMessageStylesOffset(offset) {\n      var arr = changeNumToStr(offset);\n      return {\n        top: arr[0],\n        right: arr[1],\n        left: arr[1]\n      };\n    };\n    var rootStyles = computed(function () {\n      var offset = props.offset;\n      var offsetStyle = offset ? getMessageStylesOffset(offset) : [];\n      return _objectSpread({\n        zIndex: props.zIndex\n      }, offsetStyle);\n    });\n    var computedPrefixIcon = computed(function () {\n      var icon = props.icon;\n      if (!icon) return null;\n      if (icon && !context.slots.icon && !isFunction(icon)) {\n        var theme = props.theme;\n        return (iconDefault === null || iconDefault === void 0 ? void 0 : iconDefault[theme]) || null;\n      }\n      return renderTNode(internalInstance, \"icon\");\n    });\n    var computedContent = computed(function () {\n      return renderContent(internalInstance, \"default\", \"content\");\n    });\n    var computedCloseBtn = computed(function () {\n      var closeBtn = props.closeBtn;\n      if (isFunction(closeBtn || context.slots.closeBtn)) {\n        return renderTNode(internalInstance, \"closeBtn\");\n      }\n      if (closeBtn) {\n        var closeIcon = h(CloseIcon);\n        return closeIcon;\n      }\n      return null;\n    });\n    var animateStyle = computed(function () {\n      return {\n        transform: state.offset ? \"translateX(\".concat(state.offset, \"px)\") : \"\",\n        transitionDuration: \"\".concat(state.duration, \"s\"),\n        transitionTimingFunction: \"linear\"\n      };\n    });\n    var textWrapDOM = ref();\n    var textDOM = ref();\n    var handleScrolling = function handleScrolling() {\n      var _props$marquee, _marquee$speed, _marquee$delay;\n      if (!(props !== null && props !== void 0 && props.marquee) || (props === null || props === void 0 ? void 0 : (_props$marquee = props.marquee) === null || _props$marquee === void 0 ? void 0 : _props$marquee.loop) === 0) {\n        return;\n      }\n      if (typeof props.marquee === \"boolean\") {\n        state.scroll = _objectSpread(_objectSpread({}, state.scroll), {}, {\n          marquee: props.marquee\n        });\n      }\n      var marquee = props.marquee;\n      state.scroll = {\n        marquee: true,\n        loop: typeof (marquee === null || marquee === void 0 ? void 0 : marquee.loop) === \"undefined\" ? state.scroll.loop : marquee.loop,\n        speed: (_marquee$speed = marquee.speed) !== null && _marquee$speed !== void 0 ? _marquee$speed : state.scroll.speed,\n        delay: (_marquee$delay = marquee.delay) !== null && _marquee$delay !== void 0 ? _marquee$delay : state.scroll.delay\n      };\n      setTimeout(function () {\n        var _textWrapDOM$value, _textDOM$value;\n        var textWrapDOMWidth = (_textWrapDOM$value = textWrapDOM.value) === null || _textWrapDOM$value === void 0 ? void 0 : _textWrapDOM$value.getBoundingClientRect().width;\n        var textDOMWidth = (_textDOM$value = textDOM.value) === null || _textDOM$value === void 0 ? void 0 : _textDOM$value.getBoundingClientRect().width;\n        state.offset = -textDOMWidth;\n        state.duration = textDOMWidth / state.scroll.speed;\n        state.listWidth = textWrapDOMWidth;\n        state.itemWidth = textDOMWidth;\n      }, state.scroll.delay);\n    };\n    var handleTransitionend = function handleTransitionend() {\n      state.scroll.loop = --state.scroll.loop;\n      if (state.scroll.loop === 0) {\n        state.scroll = _objectSpread(_objectSpread({}, state.scroll), {}, {\n          marquee: false\n        });\n        return;\n      }\n      state.offset = state.listWidth;\n      state.duration = 0;\n      setTimeout(function () {\n        state.offset = -state.itemWidth;\n        state.duration = (state.itemWidth + state.listWidth) / state.scroll.speed;\n      }, 0);\n    };\n    var onClose = function onClose() {\n      emitEvent(\"close\");\n      setVisible(false);\n    };\n    var handleDuration = function handleDuration() {\n      if (props.duration > 0) {\n        setTimeout(function () {\n          emitEvent(\"durationEnd\");\n          onClose();\n        }, props.duration);\n      }\n    };\n    onMounted(function () {\n      nextTick(function () {\n        if (currentVisible.value) {\n          handleScrolling();\n        }\n      });\n    });\n    watch(function () {\n      return currentVisible.value;\n    }, function (val) {\n      if (val === false) return;\n      emitEvent(\"open\");\n      setVisible(true);\n      handleDuration();\n      nextTick(function () {\n        state.offset = state.listWidth;\n        state.duration = 0;\n        handleScrolling();\n      });\n    });\n    return _objectSpread(_objectSpread({\n      name: ref(name)\n    }, toRefs(state)), {}, {\n      currentVisible: currentVisible,\n      rootClasses: rootClasses,\n      textWrapClasses: textWrapClasses,\n      rootStyles: rootStyles,\n      computedPrefixIcon: computedPrefixIcon,\n      computedContent: computedContent,\n      computedCloseBtn: computedCloseBtn,\n      textWrapDOM: textWrapDOM,\n      textDOM: textDOM,\n      animateStyle: animateStyle,\n      onClose: onClose,\n      handleTransitionend: handleTransitionend,\n      afterEnter: function afterEnter() {\n        return emitEvent(\"opened\");\n      },\n      afterLeave: function afterLeave() {\n        return emitEvent(\"closed\");\n      }\n    });\n  }\n});\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_t_node = resolveComponent(\"t-node\");\n  return openBlock(), createBlock(Transition, {\n    name: \"message\",\n    onAfterLeave: _ctx.afterLeave,\n    onAfterEnter: _ctx.afterEnter\n  }, {\n    default: withCtx(function () {\n      return [_ctx.currentVisible ? (openBlock(), createElementBlock(\"div\", {\n        key: 0,\n        ref: \"root\",\n        class: normalizeClass(_ctx.rootClasses),\n        style: normalizeStyle(_ctx.rootStyles)\n      }, [_ctx.computedPrefixIcon ? (openBlock(), createBlock(_component_t_node, {\n        key: 0,\n        content: _ctx.computedPrefixIcon\n      }, null, 8, [\"content\"])) : createCommentVNode(\"\", true), createElementVNode(\"div\", {\n        ref: \"textWrapDOM\",\n        class: normalizeClass(_ctx.textWrapClasses)\n      }, [createElementVNode(\"div\", {\n        ref: \"textDOM\",\n        class: normalizeClass(\"\".concat(_ctx.name, \"__text\")),\n        style: normalizeStyle(_ctx.scroll.marquee ? _ctx.animateStyle : \"\"),\n        onTransitionend: _cache[0] || (_cache[0] = function ($event) {\n          return _ctx.handleTransitionend();\n        })\n      }, [_ctx.computedContent ? (openBlock(), createBlock(_component_t_node, {\n        key: 0,\n        content: _ctx.computedContent\n      }, null, 8, [\"content\"])) : createCommentVNode(\"\", true)], 38)], 2), _ctx.computedCloseBtn ? (openBlock(), createElementBlock(\"div\", {\n        key: 1,\n        onClick: _cache[1] || (_cache[1] = function () {\n          return _ctx.onClose && _ctx.onClose.apply(_ctx, arguments);\n        })\n      }, [createVNode(_component_t_node, {\n        content: _ctx.computedCloseBtn\n      }, null, 8, [\"content\"])])) : createCommentVNode(\"\", true)], 6)) : createCommentVNode(\"\", true)];\n    }),\n    _: 1\n  }, 8, [\"onAfterLeave\", \"onAfterEnter\"]);\n}\nscript.render = render;\nexport { script as default };","map":{"version":3,"mappings":"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","names":["prefix","config","name","iconDefault","info","h","ErrorCircleFilledIcon","success","CheckCircleFilledIcon","warning","error","defineComponent","components","TNode","props","emits","setup","context","emitEvent","emit","internalInstance","getCurrentInstance","state","reactive","duration","offset","listWidth","itemWidth","scroll","marquee","speed","loop","delay","toRefs","visible","modelValue","useVModel","defaultVisible","onChange","_useVModel2","currentVisible","setVisible","computed","theme","align","changeNumToStr","arr","map","item","getMessageStylesOffset","top","right","left","offsetStyle","zIndex","icon","isFunction","computedContent","renderContent","closeBtn","CloseIcon","transform","transitionDuration","transitionTimingFunction","textWrapDOM","ref","textDOM","handleScrolling","_props$marquee","setTimeout","textWrapDOMWidth","value","_textWrapDOM$value","getBoundingClientRect","textDOMWidth","_textDOM$value","handleTransitionend","onClose","handleDuration","onMounted","nextTick","watch","val","rootClasses","textWrapClasses","rootStyles","computedPrefixIcon","computedCloseBtn","animateStyle","afterEnter","afterLeave","_Transition","onAfterLeave","_ctx","onAfterEnter","_createElementBlock","class","style","_createBlock","_component_t_node","content","_createElementVNode","_normalizeStyle","onTransitionend","onClick","_createVNode"],"sources":["../../src/message/message.vue","../../src/message/message.vue?vue&type=template&id=eade9a48&lang.js"],"sourcesContent":["<template>\n  <transition name=\"message\" @after-leave=\"afterLeave\" @after-enter=\"afterEnter\">\n    <div v-if=\"currentVisible\" ref=\"root\" :class=\"rootClasses\" :style=\"rootStyles\">\n      <t-node v-if=\"computedPrefixIcon\" :content=\"computedPrefixIcon\"></t-node>\n      <div ref=\"textWrapDOM\" :class=\"textWrapClasses\">\n        <div\n          ref=\"textDOM\"\n          :class=\"`${name}__text`\"\n          :style=\"scroll.marquee ? animateStyle : ''\"\n          @transitionend=\"handleTransitionend()\"\n        >\n          <t-node v-if=\"computedContent\" :content=\"computedContent\"></t-node>\n        </div>\n      </div>\n      <div v-if=\"computedCloseBtn\" @click=\"onClose\">\n        <t-node :content=\"computedCloseBtn\"></t-node>\n      </div>\n    </div>\n  </transition>\n</template>\n\n<script lang=\"ts\">\nimport {\n  h,\n  ref,\n  computed,\n  watch,\n  defineComponent,\n  getCurrentInstance,\n  SetupContext,\n  toRefs,\n  reactive,\n  nextTick,\n  onMounted,\n} from 'vue';\nimport { CheckCircleFilledIcon, ErrorCircleFilledIcon, CloseIcon } from 'tdesign-icons-vue-next';\nimport { isFunction } from 'lodash';\nimport { off } from 'process';\nimport messageProps from './props';\nimport { DrawMarquee } from './type';\nimport config from '../config';\nimport { renderContent, renderTNode, TNode, useEmitEvent, useVModel } from '../shared';\n\nconst { prefix } = config;\nconst name = `${prefix}-message`;\nconst iconDefault = {\n  info: h(ErrorCircleFilledIcon),\n  success: h(CheckCircleFilledIcon),\n  warning: h(ErrorCircleFilledIcon),\n  error: h(ErrorCircleFilledIcon),\n};\n\nexport default defineComponent({\n  name,\n  components: { TNode },\n  props: messageProps,\n  emits: ['change', 'open', 'opened', 'close', 'closed'],\n  setup(props: any, context: SetupContext) {\n    const emitEvent = useEmitEvent(props, context.emit);\n    const internalInstance = getCurrentInstance();\n\n    // 初始化动画相关数据\n    const state = reactive({\n      duration: 0,\n      offset: 0,\n      listWidth: 0,\n      itemWidth: 0,\n      scroll: {\n        marquee: false,\n        speed: 50,\n        loop: -1, // 值为 -1 表示循环播放，值为 0 表示不循环播放\n        delay: 0,\n      },\n    });\n\n    const { visible, modelValue } = toRefs(props);\n    const [currentVisible, setVisible] = useVModel(visible, modelValue, props.defaultVisible, props.onChange);\n    const rootClasses = computed(() => ({\n      [name]: true,\n      [`${name}--${props.theme}`]: true,\n      [`${name}-align--${props.align}`]: !!props.align,\n    }));\n\n    const textWrapClasses = computed(() => ({\n      [`${name}__text-wrap`]: true,\n      [`${name}__text-nowrap`]: props.marquee,\n    }));\n\n    const changeNumToStr = (arr: []) => {\n      return arr.map(function (item) {\n        return typeof item === 'number' ? `${item}px` : item;\n      });\n    };\n\n    const getMessageStylesOffset = (offset: []) => {\n      const arr = changeNumToStr(offset);\n      return {\n        top: arr[0],\n        right: arr[1],\n        left: arr[1],\n      };\n    };\n\n    const rootStyles = computed(() => {\n      const { offset } = props;\n      const offsetStyle = offset ? getMessageStylesOffset(offset) : [];\n      return {\n        zIndex: props.zIndex,\n        ...offsetStyle,\n      };\n    });\n\n    const computedPrefixIcon = computed(() => {\n      const { icon } = props;\n      if (!icon) return null;\n      if (icon && !context.slots.icon && !isFunction(icon)) {\n        const theme = props.theme as string;\n        return iconDefault?.[theme] || null;\n      }\n      return renderTNode(internalInstance, 'icon');\n    });\n\n    // content\n    const computedContent = computed(() => renderContent(internalInstance, 'default', 'content'));\n\n    // closeBtn\n    const computedCloseBtn = computed(() => {\n      const { closeBtn } = props;\n      if (isFunction(closeBtn || context.slots.closeBtn)) {\n        return renderTNode(internalInstance, 'closeBtn');\n      }\n      if (closeBtn) {\n        const closeIcon = h(CloseIcon);\n        return closeIcon;\n      }\n      return null;\n    });\n\n    // 动画\n    const animateStyle = computed(() => ({\n      transform: state.offset ? `translateX(${state.offset}px)` : '',\n      transitionDuration: `${state.duration}s`,\n      transitionTimingFunction: 'linear',\n    }));\n\n    const textWrapDOM = ref();\n    const textDOM = ref();\n\n    const handleScrolling = () => {\n      if (!props?.marquee || (props?.marquee as DrawMarquee)?.loop === 0) {\n        return;\n      }\n      // 初始化动画参数\n      if (typeof props.marquee === 'boolean') {\n        state.scroll = { ...state.scroll, marquee: props.marquee };\n      }\n      const marquee = props.marquee as DrawMarquee;\n      state.scroll = {\n        marquee: true,\n        loop: typeof marquee?.loop === 'undefined' ? state.scroll.loop : marquee.loop,\n        speed: marquee.speed ?? state.scroll.speed,\n        delay: marquee.delay ?? state.scroll.delay,\n      };\n      // 设置动画\n      setTimeout(() => {\n        const textWrapDOMWidth = textWrapDOM.value?.getBoundingClientRect().width;\n        const textDOMWidth = textDOM.value?.getBoundingClientRect().width;\n        state.offset = -textDOMWidth;\n        state.duration = textDOMWidth / state.scroll.speed;\n        state.listWidth = textWrapDOMWidth;\n        state.itemWidth = textDOMWidth;\n      }, state.scroll.delay);\n    };\n\n    // 动画结束后，初始化动画\n    const handleTransitionend = () => {\n      state.scroll.loop = --state.scroll.loop;\n      if (state.scroll.loop === 0) {\n        state.scroll = {\n          ...state.scroll,\n          marquee: false,\n        };\n        return;\n      }\n      state.offset = state.listWidth;\n      state.duration = 0;\n\n      setTimeout(() => {\n        state.offset = -state.itemWidth;\n        state.duration = (state.itemWidth + state.listWidth) / state.scroll.speed;\n      }, 0);\n    };\n\n    const onClose = () => {\n      emitEvent('close');\n      setVisible(false);\n    };\n\n    const handleDuration = () => {\n      if (props.duration > 0) {\n        setTimeout(() => {\n          emitEvent('durationEnd');\n          onClose();\n        }, props.duration);\n      }\n    };\n\n    onMounted(() => {\n      nextTick(() => {\n        if (currentVisible.value) {\n          handleScrolling();\n        }\n      });\n    });\n\n    watch(\n      () => currentVisible.value,\n      (val) => {\n        if (val === false) return;\n        emitEvent('open');\n        setVisible(true);\n        handleDuration();\n        nextTick(() => {\n          state.offset = state.listWidth;\n          state.duration = 0;\n          handleScrolling();\n        });\n      },\n    );\n\n    return {\n      name: ref(name),\n      ...toRefs(state),\n      currentVisible,\n      rootClasses,\n      textWrapClasses,\n      rootStyles,\n      computedPrefixIcon,\n      computedContent,\n      computedCloseBtn,\n      textWrapDOM,\n      textDOM,\n      animateStyle,\n      onClose,\n      handleTransitionend,\n      afterEnter: () => emitEvent('opened'),\n      afterLeave: () => emitEvent('closed'),\n    };\n  },\n});\n</script>\n","<template>\n  <transition name=\"message\" @after-leave=\"afterLeave\" @after-enter=\"afterEnter\">\n    <div v-if=\"currentVisible\" ref=\"root\" :class=\"rootClasses\" :style=\"rootStyles\">\n      <t-node v-if=\"computedPrefixIcon\" :content=\"computedPrefixIcon\"></t-node>\n      <div ref=\"textWrapDOM\" :class=\"textWrapClasses\">\n        <div\n          ref=\"textDOM\"\n          :class=\"`${name}__text`\"\n          :style=\"scroll.marquee ? animateStyle : ''\"\n          @transitionend=\"handleTransitionend()\"\n        >\n          <t-node v-if=\"computedContent\" :content=\"computedContent\"></t-node>\n        </div>\n      </div>\n      <div v-if=\"computedCloseBtn\" @click=\"onClose\">\n        <t-node :content=\"computedCloseBtn\"></t-node>\n      </div>\n    </div>\n  </transition>\n</template>\n\n<script lang=\"ts\">\nimport {\n  h,\n  ref,\n  computed,\n  watch,\n  defineComponent,\n  getCurrentInstance,\n  SetupContext,\n  toRefs,\n  reactive,\n  nextTick,\n  onMounted,\n} from 'vue';\nimport { CheckCircleFilledIcon, ErrorCircleFilledIcon, CloseIcon } from 'tdesign-icons-vue-next';\nimport { isFunction } from 'lodash';\nimport { off } from 'process';\nimport messageProps from './props';\nimport { DrawMarquee } from './type';\nimport config from '../config';\nimport { renderContent, renderTNode, TNode, useEmitEvent, useVModel } from '../shared';\n\nconst { prefix } = config;\nconst name = `${prefix}-message`;\nconst iconDefault = {\n  info: h(ErrorCircleFilledIcon),\n  success: h(CheckCircleFilledIcon),\n  warning: h(ErrorCircleFilledIcon),\n  error: h(ErrorCircleFilledIcon),\n};\n\nexport default defineComponent({\n  name,\n  components: { TNode },\n  props: messageProps,\n  emits: ['change', 'open', 'opened', 'close', 'closed'],\n  setup(props: any, context: SetupContext) {\n    const emitEvent = useEmitEvent(props, context.emit);\n    const internalInstance = getCurrentInstance();\n\n    // 初始化动画相关数据\n    const state = reactive({\n      duration: 0,\n      offset: 0,\n      listWidth: 0,\n      itemWidth: 0,\n      scroll: {\n        marquee: false,\n        speed: 50,\n        loop: -1, // 值为 -1 表示循环播放，值为 0 表示不循环播放\n        delay: 0,\n      },\n    });\n\n    const { visible, modelValue } = toRefs(props);\n    const [currentVisible, setVisible] = useVModel(visible, modelValue, props.defaultVisible, props.onChange);\n    const rootClasses = computed(() => ({\n      [name]: true,\n      [`${name}--${props.theme}`]: true,\n      [`${name}-align--${props.align}`]: !!props.align,\n    }));\n\n    const textWrapClasses = computed(() => ({\n      [`${name}__text-wrap`]: true,\n      [`${name}__text-nowrap`]: props.marquee,\n    }));\n\n    const changeNumToStr = (arr: []) => {\n      return arr.map(function (item) {\n        return typeof item === 'number' ? `${item}px` : item;\n      });\n    };\n\n    const getMessageStylesOffset = (offset: []) => {\n      const arr = changeNumToStr(offset);\n      return {\n        top: arr[0],\n        right: arr[1],\n        left: arr[1],\n      };\n    };\n\n    const rootStyles = computed(() => {\n      const { offset } = props;\n      const offsetStyle = offset ? getMessageStylesOffset(offset) : [];\n      return {\n        zIndex: props.zIndex,\n        ...offsetStyle,\n      };\n    });\n\n    const computedPrefixIcon = computed(() => {\n      const { icon } = props;\n      if (!icon) return null;\n      if (icon && !context.slots.icon && !isFunction(icon)) {\n        const theme = props.theme as string;\n        return iconDefault?.[theme] || null;\n      }\n      return renderTNode(internalInstance, 'icon');\n    });\n\n    // content\n    const computedContent = computed(() => renderContent(internalInstance, 'default', 'content'));\n\n    // closeBtn\n    const computedCloseBtn = computed(() => {\n      const { closeBtn } = props;\n      if (isFunction(closeBtn || context.slots.closeBtn)) {\n        return renderTNode(internalInstance, 'closeBtn');\n      }\n      if (closeBtn) {\n        const closeIcon = h(CloseIcon);\n        return closeIcon;\n      }\n      return null;\n    });\n\n    // 动画\n    const animateStyle = computed(() => ({\n      transform: state.offset ? `translateX(${state.offset}px)` : '',\n      transitionDuration: `${state.duration}s`,\n      transitionTimingFunction: 'linear',\n    }));\n\n    const textWrapDOM = ref();\n    const textDOM = ref();\n\n    const handleScrolling = () => {\n      if (!props?.marquee || (props?.marquee as DrawMarquee)?.loop === 0) {\n        return;\n      }\n      // 初始化动画参数\n      if (typeof props.marquee === 'boolean') {\n        state.scroll = { ...state.scroll, marquee: props.marquee };\n      }\n      const marquee = props.marquee as DrawMarquee;\n      state.scroll = {\n        marquee: true,\n        loop: typeof marquee?.loop === 'undefined' ? state.scroll.loop : marquee.loop,\n        speed: marquee.speed ?? state.scroll.speed,\n        delay: marquee.delay ?? state.scroll.delay,\n      };\n      // 设置动画\n      setTimeout(() => {\n        const textWrapDOMWidth = textWrapDOM.value?.getBoundingClientRect().width;\n        const textDOMWidth = textDOM.value?.getBoundingClientRect().width;\n        state.offset = -textDOMWidth;\n        state.duration = textDOMWidth / state.scroll.speed;\n        state.listWidth = textWrapDOMWidth;\n        state.itemWidth = textDOMWidth;\n      }, state.scroll.delay);\n    };\n\n    // 动画结束后，初始化动画\n    const handleTransitionend = () => {\n      state.scroll.loop = --state.scroll.loop;\n      if (state.scroll.loop === 0) {\n        state.scroll = {\n          ...state.scroll,\n          marquee: false,\n        };\n        return;\n      }\n      state.offset = state.listWidth;\n      state.duration = 0;\n\n      setTimeout(() => {\n        state.offset = -state.itemWidth;\n        state.duration = (state.itemWidth + state.listWidth) / state.scroll.speed;\n      }, 0);\n    };\n\n    const onClose = () => {\n      emitEvent('close');\n      setVisible(false);\n    };\n\n    const handleDuration = () => {\n      if (props.duration > 0) {\n        setTimeout(() => {\n          emitEvent('durationEnd');\n          onClose();\n        }, props.duration);\n      }\n    };\n\n    onMounted(() => {\n      nextTick(() => {\n        if (currentVisible.value) {\n          handleScrolling();\n        }\n      });\n    });\n\n    watch(\n      () => currentVisible.value,\n      (val) => {\n        if (val === false) return;\n        emitEvent('open');\n        setVisible(true);\n        handleDuration();\n        nextTick(() => {\n          state.offset = state.listWidth;\n          state.duration = 0;\n          handleScrolling();\n        });\n      },\n    );\n\n    return {\n      name: ref(name),\n      ...toRefs(state),\n      currentVisible,\n      rootClasses,\n      textWrapClasses,\n      rootStyles,\n      computedPrefixIcon,\n      computedContent,\n      computedCloseBtn,\n      textWrapDOM,\n      textDOM,\n      animateStyle,\n      onClose,\n      handleTransitionend,\n      afterEnter: () => emitEvent('opened'),\n      afterLeave: () => emitEvent('closed'),\n    };\n  },\n});\n</script>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}