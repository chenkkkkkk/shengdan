{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * tdesign v0.14.1\n * (c) 2022 TDesign Group\n * @license MIT\n */\n\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { defineComponent, h, getCurrentInstance, inject, computed, toRefs, resolveComponent, openBlock, createElementBlock, normalizeClass, createElementVNode, createBlock, createCommentVNode, normalizeStyle, createVNode } from 'vue';\nimport { MinusCircleFilledIcon, CheckCircleFilledIcon, CircleIcon } from 'tdesign-icons-vue-next';\nimport config from '../config.js';\nimport CheckboxProps from './props.js';\nimport '../shared/index.js';\nimport ClASSNAMES from '../shared/constants.js';\nimport TNodeComponent from '../shared/render-tnode.js';\nimport { useDefault } from '../shared/useDefault/index.js';\nimport { renderContent, renderTNode } from '../shared/render.js';\nimport '../shared/functions.js';\nimport '../shared/util.js';\nimport '../shared/component.js';\nimport '../shared/useToggle/index.js';\nimport '../shared/useCountDown/index.js';\nimport '@babel/runtime/helpers/asyncToGenerator';\nimport '@babel/runtime/regenerator';\nimport '@vueuse/core';\nimport '../shared/useCountDown/utils.js';\nimport '../shared/useEmitEvent/index.js';\nimport 'lodash/camelCase';\nimport '../shared/useChildSlots/index.js';\nimport '@babel/runtime/helpers/toConsumableArray';\nimport '../shared/useVModel/index.js';\nimport '../shared/useTouch/index.js';\nimport '../shared/useScrollParent/index.js';\nimport '../shared/useExpose/index.js';\nimport '../shared/useTest/index.js';\nimport '@babel/runtime/helpers/typeof';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar prefix = config.prefix;\nvar name = \"\".concat(prefix, \"-checkbox\");\nvar script = defineComponent({\n  name: name,\n  components: {\n    TNode: TNodeComponent,\n    MinusCircleFilledIcon: MinusCircleFilledIcon\n  },\n  props: _objectSpread(_objectSpread({}, CheckboxProps), {}, {\n    borderless: {\n      type: Boolean,\n      value: false\n    }\n  }),\n  emits: [\"update:checked\", \"update:modelValue\", \"change\"],\n  setup: function setup(props, context) {\n    var flagName = name;\n    var checkIcons = props.icon || [h(CheckCircleFilledIcon), h(CircleIcon)];\n    var _useDefault = useDefault(props, context.emit, \"checked\", \"change\"),\n      _useDefault2 = _slicedToArray(_useDefault, 2),\n      innerChecked = _useDefault2[0],\n      setInnerChecked = _useDefault2[1];\n    var internalInstance = getCurrentInstance();\n    var checkboxGroup = inject(\"checkboxGroup\", void 0);\n    var labelContent = computed(function () {\n      return renderContent(internalInstance, \"label\", \"default\");\n    });\n    var checkboxContent = computed(function () {\n      return renderTNode(internalInstance, \"content\");\n    });\n    var indeterminate = computed(function () {\n      if (props.checkAll && checkboxGroup != null) return checkboxGroup.checkAllStatus.value === \"indeterminate\";\n      return props.indeterminate;\n    });\n    var isChecked = computed(function () {\n      if (props.checkAll) return (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.checkAllStatus.value) === \"checked\";\n      if (checkboxGroup != null && props.value != null) {\n        var _checkboxGroup$checke;\n        return !!((_checkboxGroup$checke = checkboxGroup.checkedSet.value) !== null && _checkboxGroup$checke !== void 0 && _checkboxGroup$checke.has(props.value));\n      }\n      return innerChecked.value;\n    });\n    var isDisabled = computed(function () {\n      if (checkboxGroup !== null && checkboxGroup !== void 0 && checkboxGroup.max.value) return checkboxGroup.max.value <= checkboxGroup.innerValue.value.length && !isChecked.value;\n      if (props.disabled != null) return props.disabled;\n      return !!(checkboxGroup !== null && checkboxGroup !== void 0 && checkboxGroup.disabled.value);\n    });\n    var componentClass = computed(function () {\n      var _ref;\n      return [\"\".concat(flagName), (_ref = {}, _defineProperty(_ref, ClASSNAMES.STATUS.checked, isChecked.value), _defineProperty(_ref, ClASSNAMES.STATUS.disabled, isDisabled.value), _defineProperty(_ref, ClASSNAMES.STATUS.indeterminate, indeterminate.value), _ref)];\n    });\n    var getLimitRowStyle = function getLimitRowStyle(row) {\n      return {\n        display: \"-webkit-box\",\n        overflow: \"hidden\",\n        WebkitBoxOrient: \"vertical\",\n        WebkitLineClamp: row\n      };\n    };\n    var labelStyle = computed(function () {\n      return _objectSpread({\n        color: isDisabled.value ? \"#dcdcdc\" : \"inherit\"\n      }, getLimitRowStyle(props.maxLabelRow));\n    });\n    var contentStyle = computed(function () {\n      return _objectSpread({}, getLimitRowStyle(props.maxContentRow));\n    });\n    var handleChange = function handleChange(e, source) {\n      if (isDisabled.value) return;\n      if (source === \"content\" && props.contentDisabled) return;\n      var value = !isChecked.value;\n      setInnerChecked(value, {\n        e: e\n      });\n      e.stopPropagation();\n      if (checkboxGroup && checkboxGroup !== null && checkboxGroup !== void 0 && checkboxGroup.onCheckedChange) {\n        checkboxGroup.onCheckedChange({\n          checked: value,\n          checkAll: props.checkAll,\n          e: e,\n          option: props\n        });\n      }\n    };\n    return _objectSpread(_objectSpread({}, toRefs(props)), {}, {\n      isChecked: isChecked,\n      checkIcons: checkIcons,\n      labelContent: labelContent,\n      labelStyle: labelStyle,\n      checkboxContent: checkboxContent,\n      contentStyle: contentStyle,\n      isDisabled: isDisabled,\n      flagName: flagName,\n      componentClass: componentClass,\n      indeterminate: indeterminate,\n      handleChange: handleChange\n    });\n  }\n});\nvar _hoisted_1 = [\"name\", \"value\", \"disabled\", \"readonly\", \"checked\", \"indeterminate\"];\nvar _hoisted_2 = [\"name\", \"value\", \"disabled\", \"readonly\", \"checked\", \"indeterminate\"];\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _normalizeClass2;\n  var _component_t_node = resolveComponent(\"t-node\");\n  var _component_minus_circle_filled_icon = resolveComponent(\"minus-circle-filled-icon\");\n  return openBlock(), createElementBlock(\"div\", {\n    class: normalizeClass(_ctx.componentClass)\n  }, [createElementVNode(\"div\", {\n    class: normalizeClass(\"\".concat(_ctx.flagName, \"__content-wrap\"))\n  }, [_ctx.align === \"left\" ? (openBlock(), createElementBlock(\"span\", {\n    key: 0,\n    class: normalizeClass(\"\".concat(_ctx.flagName, \"__icon-left\"))\n  }, [createElementVNode(\"input\", {\n    type: \"checkbox\",\n    name: _ctx.name,\n    class: normalizeClass(\"\".concat(_ctx.flagName, \"__original-left\")),\n    value: _ctx.value,\n    disabled: _ctx.isDisabled,\n    readonly: _ctx.readonly,\n    checked: _ctx.isChecked,\n    indeterminate: _ctx.indeterminate,\n    onClick: _cache[0] || (_cache[0] = function () {\n      return _ctx.handleChange && _ctx.handleChange.apply(_ctx, arguments);\n    })\n  }, null, 10, _hoisted_1), !_ctx.indeterminate ? (openBlock(), createBlock(_component_t_node, {\n    key: 0,\n    content: _ctx.checkIcons[_ctx.isChecked ? 0 : 1]\n  }, null, 8, [\"content\"])) : (openBlock(), createBlock(_component_minus_circle_filled_icon, {\n    key: 1\n  }))], 2)) : createCommentVNode(\"\", true), _ctx.labelContent || _ctx.checkboxContent ? (openBlock(), createElementBlock(\"span\", {\n    key: 1,\n    class: normalizeClass((_normalizeClass2 = {}, _defineProperty(_normalizeClass2, \"\".concat(_ctx.flagName, \"__label\"), true), _defineProperty(_normalizeClass2, \"\".concat(_ctx.flagName, \"__label-left\"), _ctx.align === \"right\"), _normalizeClass2)),\n    onClick: _cache[1] || (_cache[1] = function (e) {\n      return _ctx.handleChange(e, \"content\");\n    })\n  }, [_ctx.labelContent ? (openBlock(), createElementBlock(\"span\", {\n    key: 0,\n    style: normalizeStyle(_ctx.labelStyle)\n  }, [createVNode(_component_t_node, {\n    content: _ctx.labelContent\n  }, null, 8, [\"content\"])], 4)) : createCommentVNode(\"\", true), _ctx.checkboxContent ? (openBlock(), createElementBlock(\"span\", {\n    key: 1,\n    class: normalizeClass(\"\".concat(_ctx.flagName, \"__description\")),\n    style: normalizeStyle(_ctx.contentStyle)\n  }, [createVNode(_component_t_node, {\n    content: _ctx.checkboxContent\n  }, null, 8, [\"content\"])], 6)) : createCommentVNode(\"\", true)], 2)) : createCommentVNode(\"\", true), _ctx.align === \"right\" ? (openBlock(), createElementBlock(\"span\", {\n    key: 2,\n    class: normalizeClass(\"\".concat(_ctx.flagName, \"__icon-right\"))\n  }, [createElementVNode(\"input\", {\n    type: \"checkbox\",\n    name: _ctx.name,\n    class: normalizeClass(\"\".concat(_ctx.flagName, \"__original-right\")),\n    value: _ctx.value,\n    disabled: _ctx.isDisabled,\n    readonly: _ctx.readonly,\n    checked: _ctx.isChecked,\n    indeterminate: _ctx.indeterminate,\n    onClick: _cache[2] || (_cache[2] = function () {\n      return _ctx.handleChange && _ctx.handleChange.apply(_ctx, arguments);\n    })\n  }, null, 10, _hoisted_2), !_ctx.indeterminate ? (openBlock(), createBlock(_component_t_node, {\n    key: 0,\n    content: _ctx.checkIcons[_ctx.isChecked ? 0 : 1]\n  }, null, 8, [\"content\"])) : (openBlock(), createBlock(_component_minus_circle_filled_icon, {\n    key: 1\n  }))], 2)) : createCommentVNode(\"\", true)], 2), !_ctx.borderless ? (openBlock(), createElementBlock(\"div\", {\n    key: 0,\n    class: normalizeClass(\"\".concat(_ctx.flagName, \"__border \").concat(_ctx.flagName, \"__border--\").concat(_ctx.align))\n  }, null, 2)) : createCommentVNode(\"\", true)], 2);\n}\nscript.render = render;\nexport { script as default };","map":{"version":3,"mappings":"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","names":["prefix","config","name","defineComponent","components","TNode","MinusCircleFilledIcon","props","CheckboxProps","borderless","type","value","emits","setup","context","flagName","icon","h","CheckCircleFilledIcon","useDefault","_useDefault2","innerChecked","setInnerChecked","internalInstance","getCurrentInstance","inject","labelContent","computed","renderContent","checkboxContent","renderTNode","checkAll","checkboxGroup","checkAllStatus","checkedSet","has","max","innerValue","isChecked","disabled","ClASSNAMES","STATUS","isDisabled","indeterminate","getLimitRowStyle","row","display","overflow","WebkitBoxOrient","WebkitLineClamp","color","maxLabelRow","maxContentRow","handleChange","e","source","stopPropagation","onCheckedChange","checked","option","toRefs","checkIcons","labelStyle","contentStyle","componentClass","class","_createElementVNode","_ctx","align","_createElementBlock","readonly","onClick","_createBlock","_component_t_node","content","key","_cache","style","_createVNode","_normalizeClass"],"sources":["../../src/checkbox/checkbox.vue","../../src/checkbox/checkbox.vue?vue&type=template&id=54b41810&lang.js"],"sourcesContent":["<template>\n  <div :class=\"componentClass\">\n    <div :class=\"`${flagName}__content-wrap`\">\n      <span v-if=\"align === 'left'\" :class=\"`${flagName}__icon-left`\">\n        <input\n          type=\"checkbox\"\n          :name=\"name\"\n          :class=\"`${flagName}__original-left`\"\n          :value=\"value\"\n          :disabled=\"isDisabled\"\n          :readonly=\"readonly\"\n          :checked=\"isChecked\"\n          :indeterminate=\"indeterminate\"\n          @click=\"handleChange\"\n        />\n        <t-node v-if=\"!indeterminate\" :content=\"checkIcons[isChecked ? 0 : 1]\" />\n        <minus-circle-filled-icon v-else />\n      </span>\n      <span\n        v-if=\"labelContent || checkboxContent\"\n        :class=\"{ [`${flagName}__label`]: true, [`${flagName}__label-left`]: align === 'right' }\"\n        @click=\"(e) => handleChange(e, 'content')\"\n      >\n        <span v-if=\"labelContent\" :style=\"labelStyle\">\n          <t-node :content=\"labelContent\" />\n        </span>\n        <span v-if=\"checkboxContent\" :class=\"`${flagName}__description`\" :style=\"contentStyle\">\n          <t-node :content=\"checkboxContent\" />\n        </span>\n      </span>\n\n      <span v-if=\"align === 'right'\" :class=\"`${flagName}__icon-right`\">\n        <input\n          type=\"checkbox\"\n          :name=\"name\"\n          :class=\"`${flagName}__original-right`\"\n          :value=\"value\"\n          :disabled=\"isDisabled\"\n          :readonly=\"readonly\"\n          :checked=\"isChecked\"\n          :indeterminate=\"indeterminate\"\n          @click=\"handleChange\"\n        />\n        <t-node v-if=\"!indeterminate\" :content=\"checkIcons[isChecked ? 0 : 1]\" />\n        <minus-circle-filled-icon v-else />\n      </span>\n    </div>\n    <!--下边框 -->\n    <div v-if=\"!borderless\" :class=\"`${flagName}__border ${flagName}__border--${align}`\"></div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { inject, computed, SetupContext, defineComponent, getCurrentInstance, h, toRefs, CSSProperties } from 'vue';\nimport { MinusCircleFilledIcon, CheckCircleFilledIcon, CircleIcon } from 'tdesign-icons-vue-next';\nimport config from '../config';\nimport CheckboxProps from './props';\nimport { renderContent, renderTNode, TNode, useDefault, useVModel } from '../shared';\nimport { TdCheckboxProps } from './type';\nimport ClASSNAMES from '../shared/constants';\n\nconst { prefix } = config;\nconst name = `${prefix}-checkbox`;\n\nexport default defineComponent({\n  name,\n  components: { TNode, MinusCircleFilledIcon },\n  props: {\n    ...CheckboxProps,\n    borderless: {\n      type: Boolean,\n      value: false,\n    },\n  },\n  emits: ['update:checked', 'update:modelValue', 'change'],\n  setup(props, context: SetupContext) {\n    const flagName = name;\n    const checkIcons = props.icon || [h(CheckCircleFilledIcon), h(CircleIcon)];\n    const [innerChecked, setInnerChecked] = useDefault<boolean, TdCheckboxProps>(\n      props,\n      context.emit,\n      'checked',\n      'change',\n    );\n\n    const internalInstance = getCurrentInstance();\n    const checkboxGroup: any = inject('checkboxGroup', undefined);\n    const labelContent = computed(() => renderContent(internalInstance, 'label', 'default'));\n    const checkboxContent = computed(() => renderTNode(internalInstance, 'content'));\n    const indeterminate = computed<boolean>(() => {\n      if (props.checkAll && checkboxGroup != null) return checkboxGroup.checkAllStatus.value === 'indeterminate';\n      return props.indeterminate;\n    });\n    const isChecked = computed(() => {\n      if (props.checkAll) return checkboxGroup?.checkAllStatus.value === 'checked';\n      if (checkboxGroup != null && props.value != null) {\n        return !!checkboxGroup.checkedSet.value?.has(props.value);\n      }\n\n      return innerChecked.value;\n    });\n\n    const isDisabled = computed(() => {\n      if (checkboxGroup?.max.value)\n        return checkboxGroup.max.value <= checkboxGroup.innerValue.value.length && !isChecked.value;\n      if (props.disabled != null) return props.disabled;\n      return !!checkboxGroup?.disabled.value;\n    });\n\n    const componentClass = computed(() => [\n      `${flagName}`,\n      {\n        [ClASSNAMES.STATUS.checked]: isChecked.value,\n        [ClASSNAMES.STATUS.disabled]: isDisabled.value,\n        [ClASSNAMES.STATUS.indeterminate]: indeterminate.value,\n      },\n    ]);\n\n    const getLimitRowStyle = (row: number): CSSProperties => ({\n      display: '-webkit-box',\n      overflow: 'hidden',\n      WebkitBoxOrient: 'vertical',\n      WebkitLineClamp: row,\n    });\n\n    const labelStyle = computed(() => ({\n      color: isDisabled.value ? '#dcdcdc' : 'inherit',\n      ...getLimitRowStyle(props.maxLabelRow),\n    }));\n\n    const contentStyle = computed(() => ({\n      ...getLimitRowStyle(props.maxContentRow),\n    }));\n\n    const handleChange = (e: Event, source?: string) => {\n      if (isDisabled.value) return;\n      if (source === 'content' && props.contentDisabled) return;\n\n      const value = !isChecked.value;\n      setInnerChecked(value, { e });\n      e.stopPropagation();\n      if (checkboxGroup && checkboxGroup?.onCheckedChange) {\n        checkboxGroup.onCheckedChange({ checked: value, checkAll: props.checkAll, e, option: props });\n      }\n    };\n\n    return {\n      ...toRefs(props),\n      isChecked,\n      checkIcons,\n      labelContent,\n      labelStyle,\n      checkboxContent,\n      contentStyle,\n      isDisabled,\n      flagName,\n      componentClass,\n      indeterminate,\n      handleChange,\n    };\n  },\n});\n</script>\n","<template>\n  <div :class=\"componentClass\">\n    <div :class=\"`${flagName}__content-wrap`\">\n      <span v-if=\"align === 'left'\" :class=\"`${flagName}__icon-left`\">\n        <input\n          type=\"checkbox\"\n          :name=\"name\"\n          :class=\"`${flagName}__original-left`\"\n          :value=\"value\"\n          :disabled=\"isDisabled\"\n          :readonly=\"readonly\"\n          :checked=\"isChecked\"\n          :indeterminate=\"indeterminate\"\n          @click=\"handleChange\"\n        />\n        <t-node v-if=\"!indeterminate\" :content=\"checkIcons[isChecked ? 0 : 1]\" />\n        <minus-circle-filled-icon v-else />\n      </span>\n      <span\n        v-if=\"labelContent || checkboxContent\"\n        :class=\"{ [`${flagName}__label`]: true, [`${flagName}__label-left`]: align === 'right' }\"\n        @click=\"(e) => handleChange(e, 'content')\"\n      >\n        <span v-if=\"labelContent\" :style=\"labelStyle\">\n          <t-node :content=\"labelContent\" />\n        </span>\n        <span v-if=\"checkboxContent\" :class=\"`${flagName}__description`\" :style=\"contentStyle\">\n          <t-node :content=\"checkboxContent\" />\n        </span>\n      </span>\n\n      <span v-if=\"align === 'right'\" :class=\"`${flagName}__icon-right`\">\n        <input\n          type=\"checkbox\"\n          :name=\"name\"\n          :class=\"`${flagName}__original-right`\"\n          :value=\"value\"\n          :disabled=\"isDisabled\"\n          :readonly=\"readonly\"\n          :checked=\"isChecked\"\n          :indeterminate=\"indeterminate\"\n          @click=\"handleChange\"\n        />\n        <t-node v-if=\"!indeterminate\" :content=\"checkIcons[isChecked ? 0 : 1]\" />\n        <minus-circle-filled-icon v-else />\n      </span>\n    </div>\n    <!--下边框 -->\n    <div v-if=\"!borderless\" :class=\"`${flagName}__border ${flagName}__border--${align}`\"></div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { inject, computed, SetupContext, defineComponent, getCurrentInstance, h, toRefs, CSSProperties } from 'vue';\nimport { MinusCircleFilledIcon, CheckCircleFilledIcon, CircleIcon } from 'tdesign-icons-vue-next';\nimport config from '../config';\nimport CheckboxProps from './props';\nimport { renderContent, renderTNode, TNode, useDefault, useVModel } from '../shared';\nimport { TdCheckboxProps } from './type';\nimport ClASSNAMES from '../shared/constants';\n\nconst { prefix } = config;\nconst name = `${prefix}-checkbox`;\n\nexport default defineComponent({\n  name,\n  components: { TNode, MinusCircleFilledIcon },\n  props: {\n    ...CheckboxProps,\n    borderless: {\n      type: Boolean,\n      value: false,\n    },\n  },\n  emits: ['update:checked', 'update:modelValue', 'change'],\n  setup(props, context: SetupContext) {\n    const flagName = name;\n    const checkIcons = props.icon || [h(CheckCircleFilledIcon), h(CircleIcon)];\n    const [innerChecked, setInnerChecked] = useDefault<boolean, TdCheckboxProps>(\n      props,\n      context.emit,\n      'checked',\n      'change',\n    );\n\n    const internalInstance = getCurrentInstance();\n    const checkboxGroup: any = inject('checkboxGroup', undefined);\n    const labelContent = computed(() => renderContent(internalInstance, 'label', 'default'));\n    const checkboxContent = computed(() => renderTNode(internalInstance, 'content'));\n    const indeterminate = computed<boolean>(() => {\n      if (props.checkAll && checkboxGroup != null) return checkboxGroup.checkAllStatus.value === 'indeterminate';\n      return props.indeterminate;\n    });\n    const isChecked = computed(() => {\n      if (props.checkAll) return checkboxGroup?.checkAllStatus.value === 'checked';\n      if (checkboxGroup != null && props.value != null) {\n        return !!checkboxGroup.checkedSet.value?.has(props.value);\n      }\n\n      return innerChecked.value;\n    });\n\n    const isDisabled = computed(() => {\n      if (checkboxGroup?.max.value)\n        return checkboxGroup.max.value <= checkboxGroup.innerValue.value.length && !isChecked.value;\n      if (props.disabled != null) return props.disabled;\n      return !!checkboxGroup?.disabled.value;\n    });\n\n    const componentClass = computed(() => [\n      `${flagName}`,\n      {\n        [ClASSNAMES.STATUS.checked]: isChecked.value,\n        [ClASSNAMES.STATUS.disabled]: isDisabled.value,\n        [ClASSNAMES.STATUS.indeterminate]: indeterminate.value,\n      },\n    ]);\n\n    const getLimitRowStyle = (row: number): CSSProperties => ({\n      display: '-webkit-box',\n      overflow: 'hidden',\n      WebkitBoxOrient: 'vertical',\n      WebkitLineClamp: row,\n    });\n\n    const labelStyle = computed(() => ({\n      color: isDisabled.value ? '#dcdcdc' : 'inherit',\n      ...getLimitRowStyle(props.maxLabelRow),\n    }));\n\n    const contentStyle = computed(() => ({\n      ...getLimitRowStyle(props.maxContentRow),\n    }));\n\n    const handleChange = (e: Event, source?: string) => {\n      if (isDisabled.value) return;\n      if (source === 'content' && props.contentDisabled) return;\n\n      const value = !isChecked.value;\n      setInnerChecked(value, { e });\n      e.stopPropagation();\n      if (checkboxGroup && checkboxGroup?.onCheckedChange) {\n        checkboxGroup.onCheckedChange({ checked: value, checkAll: props.checkAll, e, option: props });\n      }\n    };\n\n    return {\n      ...toRefs(props),\n      isChecked,\n      checkIcons,\n      labelContent,\n      labelStyle,\n      checkboxContent,\n      contentStyle,\n      isDisabled,\n      flagName,\n      componentClass,\n      indeterminate,\n      handleChange,\n    };\n  },\n});\n</script>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}