{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * tdesign v0.14.1\n * (c) 2022 TDesign Group\n * @license MIT\n */\n\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { defineComponent, ref, reactive, computed, watchEffect, onMounted, onBeforeUnmount, toRefs, resolveComponent, openBlock, createElementBlock, normalizeStyle, normalizeClass, Fragment, renderList, withModifiers, createTextVNode, toDisplayString, createElementVNode, createCommentVNode, createVNode, withCtx, createBlock } from 'vue';\nimport config from '../config.js';\nimport IndexesProps from './props.js';\nimport '../shared/index.js';\nimport script$1 from './indexes-anchor.js';\nimport script$2 from './indexes-cell.js';\nimport { useEmitEvent } from '../shared/useEmitEvent/index.js';\nimport '../shared/functions.js';\nimport '../shared/util.js';\nimport '../shared/component.js';\nimport '../shared/constants.js';\nimport '../shared/render.js';\nimport '@babel/runtime/helpers/typeof';\nimport 'lodash/camelCase';\nimport '../shared/render-tnode.js';\nimport '../shared/useToggle/index.js';\nimport '../shared/useCountDown/index.js';\nimport '@babel/runtime/helpers/asyncToGenerator';\nimport '@babel/runtime/regenerator';\nimport '@vueuse/core';\nimport '../shared/useCountDown/utils.js';\nimport '../shared/useDefault/index.js';\nimport '../shared/useChildSlots/index.js';\nimport '@babel/runtime/helpers/toConsumableArray';\nimport '../shared/useVModel/index.js';\nimport '../shared/useTouch/index.js';\nimport '../shared/useScrollParent/index.js';\nimport '../shared/useExpose/index.js';\nimport '../shared/useTest/index.js';\nimport '../cell/index.js';\nimport '../cell/cell.js';\nimport 'tdesign-icons-vue-next';\nimport '../cell/props.js';\nimport './style/css.js';\nimport '../cell/type.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar prefix = config.prefix;\nvar touch = {\n  startX: 0,\n  startY: 0,\n  deltaX: 0,\n  deltaY: 0,\n  offsetX: 0,\n  offsetY: 0\n};\nvar componentName = \"\".concat(prefix, \"-indexes\");\nvar script = defineComponent({\n  name: componentName,\n  components: {\n    indexesAnchor: script$1,\n    TIndexesCell: script$2\n  },\n  props: IndexesProps,\n  emits: [\"select\"],\n  setup: function setup(props, context) {\n    var emitEvent = useEmitEvent(props, context.emit);\n    var timeOut;\n    var indexesRoot = ref(null);\n    var state = reactive({\n      componentName: componentName,\n      list: props.list,\n      showSidebarTip: false,\n      activeSidebar: \"\",\n      activeIndex: -1\n    });\n    var anchorGroup = ref([]);\n    var setAnchorGroupRefs = function setAnchorGroupRefs(index) {\n      return function (el) {\n        anchorGroup.value[index] = el;\n      };\n    };\n    var anchor = ref([]);\n    var anchorStyle = reactive([]);\n    var setAnchorRefs = function setAnchorRefs(index) {\n      return function (el) {\n        anchor.value[index] = el;\n      };\n    };\n    var indexesRootStyle = computed(function () {\n      if (typeof props.height !== \"number\") {\n        return {};\n      }\n      var height = Number(props.height);\n      return {\n        height: height === 0 ? 0 : \"\".concat(height, \"px\")\n      };\n    });\n    var scrollToView = function scrollToView() {\n      var _targets$, _targets$$scrollIntoV;\n      var children = anchorGroup.value;\n      var targets = children.filter(function (ele) {\n        var dataset = ele.dataset;\n        return dataset && dataset.index === state.activeSidebar;\n      });\n      (_targets$ = targets[0]) === null || _targets$ === void 0 ? void 0 : (_targets$$scrollIntoV = _targets$.scrollIntoView) === null || _targets$$scrollIntoV === void 0 ? void 0 : _targets$$scrollIntoV.call(_targets$);\n    };\n    var calcSticky = function calcSticky(indexesRootTop) {\n      var children = anchorGroup.value;\n      for (var i = 0; i < children.length; i++) {\n        var _anchor$value, _anchor$value$$el$get;\n        var _children$i$getBoundi = children[i].getBoundingClientRect(),\n          childTop = _children$i$getBoundi.top,\n          width = _children$i$getBoundi.width;\n        anchorStyle[i] = \"z-index: \".concat(i + 1, \";\");\n        if (childTop < indexesRootTop && i === state.activeIndex) {\n          anchorStyle[i] += \"position:fixed;top:\".concat(indexesRootTop, \"px;width: \").concat(width, \"px;\");\n        } else {\n          anchorStyle[i] += \"\";\n        }\n        var anchorHeight = (_anchor$value = anchor.value[i - 1]) === null || _anchor$value === void 0 ? void 0 : (_anchor$value$$el$get = _anchor$value.$el.getBoundingClientRect()) === null || _anchor$value$$el$get === void 0 ? void 0 : _anchor$value$$el$get.height;\n        var diff = childTop - indexesRootTop - anchorHeight;\n        if (i - 1 === state.activeIndex && diff < 0) {\n          anchorStyle[i - 1] += \"transform: translateY(\".concat(diff, \"px)\");\n        }\n      }\n    };\n    var calcChildPosition = function calcChildPosition(scrollTop) {\n      var _children$currentInde;\n      var children = anchorGroup.value;\n      var currentIndex = -1;\n      for (var i = 0; i < children.length - 1; i++) {\n        if (scrollTop < children[i + 1].offsetTop) {\n          currentIndex = i;\n          break;\n        }\n      }\n      if (scrollTop >= children[children.length - 1].offsetTop) {\n        currentIndex = children.length - 1;\n      }\n      state.activeIndex = currentIndex;\n      state.activeSidebar = (_children$currentInde = children[currentIndex].dataset.index) !== null && _children$currentInde !== void 0 ? _children$currentInde : \"\";\n    };\n    var setActiveSidebarAndTip = function setActiveSidebarAndTip(index) {\n      state.activeSidebar = index;\n      state.showSidebarTip = true;\n    };\n    watchEffect(function () {\n      if (state.showSidebarTip) {\n        clearSidebarTip();\n      }\n    });\n    var handleSidebarItemClick = function handleSidebarItemClick(index) {\n      setActiveSidebarAndTip(index);\n      scrollToView();\n    };\n    var handleSidebarTouchstart = function handleSidebarTouchstart(event) {\n      event.stopPropagation();\n      var touches = event.touches;\n      touch.startX = touches[0].clientX;\n      touch.startY = touches[0].clientX;\n    };\n    var handleSidebarTouchmove = function handleSidebarTouchmove(event) {\n      event.preventDefault();\n      var touches = event.touches;\n      var _touches$ = touches[0],\n        clientX = _touches$.clientX,\n        clientY = _touches$.clientY;\n      var target = document.elementFromPoint(clientX, clientY);\n      if (target && target.className === \"\".concat(componentName, \"__sidebar-item\") && target instanceof HTMLElement) {\n        var index = target.dataset.index;\n        if (index !== void 0 && state.activeSidebar !== index) {\n          setActiveSidebarAndTip(index);\n          scrollToView();\n        }\n      }\n    };\n    var handleRootScroll = function handleRootScroll(event) {\n      if (indexesRoot.value) {\n        calcChildPosition(indexesRoot.value.scrollTop);\n        if (props.sticky) {\n          var _indexesRoot$value$ge, _indexesRoot$value, _indexesRoot$value$ge2;\n          var indexesRootTop = (_indexesRoot$value$ge = (_indexesRoot$value = indexesRoot.value) === null || _indexesRoot$value === void 0 ? void 0 : (_indexesRoot$value$ge2 = _indexesRoot$value.getBoundingClientRect()) === null || _indexesRoot$value$ge2 === void 0 ? void 0 : _indexesRoot$value$ge2.top) !== null && _indexesRoot$value$ge !== void 0 ? _indexesRoot$value$ge : 0;\n          calcSticky(indexesRootTop);\n        }\n      }\n    };\n    var clearSidebarTip = function clearSidebarTip() {\n      if (state.showSidebarTip && state.activeSidebar) {\n        timeOut && clearTimeout(timeOut);\n        timeOut = window.setTimeout(function () {\n          state.showSidebarTip = false;\n        }, 1e3);\n      }\n    };\n    var handleCellClick = function handleCellClick(indexes) {\n      emitEvent(\"select\", indexes);\n    };\n    onMounted(function () {\n      var children = anchorGroup.value;\n      if (children.length > 0) {\n        var index = children[0].dataset.index;\n        if (index !== void 0) {\n          state.activeSidebar = index;\n        }\n      }\n    });\n    onBeforeUnmount(function () {\n      timeOut && clearTimeout(timeOut);\n    });\n    return _objectSpread(_objectSpread({}, toRefs(state)), {}, {\n      indexesRoot: indexesRoot,\n      indexesRootStyle: indexesRootStyle,\n      anchorGroup: anchorGroup,\n      anchorStyle: anchorStyle,\n      setAnchorGroupRefs: setAnchorGroupRefs,\n      setAnchorRefs: setAnchorRefs,\n      handleSidebarItemClick: handleSidebarItemClick,\n      handleSidebarTouchmove: handleSidebarTouchmove,\n      handleSidebarTouchstart: handleSidebarTouchstart,\n      handleRootScroll: handleRootScroll,\n      handleCellClick: handleCellClick\n    });\n  }\n});\nvar _hoisted_1 = [\"data-index\", \"onClick\"];\nvar _hoisted_2 = [\"data-index\"];\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_indexes_anchor = resolveComponent(\"indexes-anchor\");\n  var _component_t_indexes_cell = resolveComponent(\"t-indexes-cell\");\n  return openBlock(), createElementBlock(\"div\", {\n    ref: \"indexesRoot\",\n    style: normalizeStyle(_ctx.indexesRootStyle),\n    class: normalizeClass(_ctx.componentName),\n    onScroll: _cache[2] || (_cache[2] = function () {\n      return _ctx.handleRootScroll && _ctx.handleRootScroll.apply(_ctx, arguments);\n    })\n  }, [_ctx.list.length > 0 ? (openBlock(), createElementBlock(\"div\", {\n    key: 0,\n    class: normalizeClass(\"\".concat(_ctx.componentName, \"__sidebar\")),\n    onTouchstart: _cache[0] || (_cache[0] = function () {\n      return _ctx.handleSidebarTouchstart && _ctx.handleSidebarTouchstart.apply(_ctx, arguments);\n    }),\n    onTouchmove: _cache[1] || (_cache[1] = function () {\n      return _ctx.handleSidebarTouchmove && _ctx.handleSidebarTouchmove.apply(_ctx, arguments);\n    })\n  }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, function (item) {\n    return openBlock(), createElementBlock(\"div\", {\n      key: item.index,\n      class: normalizeClass([\"\".concat(_ctx.componentName, \"__sidebar-item\"), _ctx.activeSidebar === item.index ? \"\".concat(_ctx.componentName, \"__sidebar-item--active\") : \"\"]),\n      \"data-index\": item.index,\n      onClick: withModifiers(function ($event) {\n        return _ctx.handleSidebarItemClick(item.index);\n      }, [\"prevent\"])\n    }, [createTextVNode(toDisplayString(item.index) + \" \", 1), _ctx.showSidebarTip && _ctx.activeSidebar === item.index ? (openBlock(), createElementBlock(\"div\", {\n      key: 0,\n      class: normalizeClass(\"\".concat(_ctx.componentName, \"__sidebar-tip\"))\n    }, [createElementVNode(\"span\", {\n      class: normalizeClass(\"\".concat(_ctx.componentName, \"__sidebar-tip-text\"))\n    }, toDisplayString(_ctx.activeSidebar), 3)], 2)) : createCommentVNode(\"\", true)], 10, _hoisted_1);\n  }), 128))], 34)) : createCommentVNode(\"\", true), (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, function (item, index) {\n    return openBlock(), createElementBlock(\"div\", {\n      ref_for: true,\n      ref: _ctx.setAnchorGroupRefs(index),\n      key: item.index,\n      \"data-index\": item.index\n    }, [createVNode(_component_indexes_anchor, {\n      ref_for: true,\n      ref: _ctx.setAnchorRefs(index),\n      \"anchor-style\": _ctx.anchorStyle[index]\n    }, {\n      default: withCtx(function () {\n        var _item$title;\n        return [createTextVNode(toDisplayString((_item$title = item.title) !== null && _item$title !== void 0 ? _item$title : item.index), 1)];\n      }),\n      _: 2\n    }, 1032, [\"anchor-style\"]), createElementVNode(\"div\", {\n      class: normalizeClass([\"\".concat(_ctx.componentName, \"__group\")])\n    }, [(openBlock(true), createElementBlock(Fragment, null, renderList(item.children, function (child, childrenIndex) {\n      return openBlock(), createBlock(_component_t_indexes_cell, {\n        key: child.title,\n        value: String(child.title),\n        title: child.title,\n        link: true,\n        bordered: false,\n        onClick: function onClick($event) {\n          return _ctx.handleCellClick({\n            groupIndex: item.index,\n            childrenIndex: childrenIndex\n          });\n        }\n      }, null, 8, [\"value\", \"title\", \"onClick\"]);\n    }), 128))], 2)], 8, _hoisted_2);\n  }), 128))], 38);\n}\nscript.render = render;\nexport { script as default };","map":{"version":3,"mappings":"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","names":["prefix","config","touch","startX","startY","deltaX","deltaY","offsetX","offsetY","componentName","defineComponent","name","components","indexesAnchor","TIndexesCell","props","emits","setup","context","emitEvent","emit","ref","state","reactive","list","showSidebarTip","activeSidebar","activeIndex","setAnchorGroupRefs","index","el","anchorGroup","value","setAnchorRefs","anchor","computed","Number","height","scrollToView","children","targets","filter","ele","dataset","_targets$","scrollIntoView","_targets$$scrollIntoV","calcSticky","indexesRootTop","i","length","getBoundingClientRect","childTop","top","width","anchorStyle","anchorHeight","_anchor$value","$el","_anchor$value$$el$get","diff","calcChildPosition","scrollTop","currentIndex","offsetTop","setActiveSidebarAndTip","watchEffect","clearSidebarTip","handleSidebarItemClick","handleSidebarTouchstart","event","stopPropagation","touches","handleSidebarTouchmove","preventDefault","clientX","clientY","target","elementFromPoint","HTMLElement","handleRootScroll","indexesRoot","sticky","_indexesRoot$value","_indexesRoot$value$ge2","timeOut","clearTimeout","setTimeout","handleCellClick","indexes","onMounted","onBeforeUnmount","toRefs","indexesRootStyle","style","class","onScroll","_ctx","_createElementBlock","onTouchstart","onTouchmove","item","key","_normalizeClass","onClick","_withModifiers","_createElementVNode","_openBlock","_createVNode","_component_indexes_anchor","_createTextVNode","title","childrenIndex","_component_t_indexes_cell","child","String","link","bordered","groupIndex"],"sources":["../../src/indexes/indexes.vue","../../src/indexes/indexes.vue?vue&type=template&id=48462048&lang.js"],"sourcesContent":["<template>\n  <div ref=\"indexesRoot\" :style=\"indexesRootStyle\" :class=\"componentName\" @scroll=\"handleRootScroll\">\n    <div\n      v-if=\"list.length > 0\"\n      :class=\"`${componentName}__sidebar`\"\n      @touchstart=\"handleSidebarTouchstart\"\n      @touchmove=\"handleSidebarTouchmove\"\n    >\n      <div\n        v-for=\"item in list\"\n        :key=\"item.index\"\n        :class=\"[\n          `${componentName}__sidebar-item`,\n          activeSidebar === item.index ? `${componentName}__sidebar-item--active` : '',\n        ]\"\n        :data-index=\"item.index\"\n        @click.prevent=\"handleSidebarItemClick(item.index)\"\n      >\n        {{ item.index }}\n        <div v-if=\"showSidebarTip && activeSidebar === item.index\" :class=\"`${componentName}__sidebar-tip`\">\n          <span :class=\"`${componentName}__sidebar-tip-text`\">\n            {{ activeSidebar }}\n          </span>\n        </div>\n      </div>\n    </div>\n\n    <div v-for=\"(item, index) in list\" :ref=\"setAnchorGroupRefs(index)\" :key=\"item.index\" :data-index=\"item.index\">\n      <indexes-anchor :ref=\"setAnchorRefs(index)\" :anchor-style=\"anchorStyle[index]\">\n        {{ item.title ?? item.index }}\n      </indexes-anchor>\n      <div :class=\"[`${componentName}__group`]\">\n        <t-indexes-cell\n          v-for=\"(child, childrenIndex) in item.children\"\n          :key=\"child.title\"\n          :value=\"String(child.title)\"\n          :title=\"child.title\"\n          :link=\"true\"\n          :bordered=\"false\"\n          @click=\"handleCellClick({ groupIndex: item.index, childrenIndex: childrenIndex })\"\n        />\n      </div>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  ref,\n  reactive,\n  defineComponent,\n  PropType,\n  onMounted,\n  watchEffect,\n  computed,\n  onBeforeUnmount,\n  toRefs,\n  SetupContext,\n} from 'vue';\nimport config from '../config';\nimport { ListItem } from './type';\nimport IndexesProps from './props';\nimport { useEmitEvent } from '../shared';\nimport indexesAnchor from './indexes-anchor.vue';\nimport TIndexesCell from './indexes-cell.vue';\n\nconst { prefix } = config;\n\ninterface Touch {\n  startX: number;\n  startY: number;\n  deltaX: number;\n  deltaY: number;\n  offsetX: number;\n  offsetY: number;\n}\ninterface State {\n  componentName: string;\n  list: ListItem[];\n  showSidebarTip: boolean;\n  activeSidebar: string;\n  activeIndex: number;\n}\n\nconst touch: Touch = {\n  startX: 0,\n  startY: 0,\n  deltaX: 0,\n  deltaY: 0,\n  offsetX: 0,\n  offsetY: 0,\n};\n\nconst componentName = `${prefix}-indexes`;\n\nexport default defineComponent({\n  name: componentName,\n  components: { indexesAnchor, TIndexesCell },\n  props: IndexesProps,\n  emits: ['select'],\n  setup(props, context: SetupContext) {\n    const emitEvent = useEmitEvent(props, context.emit);\n    let timeOut: number;\n    const indexesRoot = ref<null | HTMLElement>(null);\n    const state: State = reactive({\n      componentName,\n      list: props.list,\n      showSidebarTip: false,\n      activeSidebar: '',\n      activeIndex: -1,\n    });\n\n    const anchorGroup = ref<HTMLElement[]>([]);\n    const setAnchorGroupRefs = (index: number) => {\n      return (el: any) => {\n        anchorGroup.value[index] = el as HTMLElement;\n      };\n    };\n\n    const anchor = ref<any[]>([]);\n    const anchorStyle = reactive<string[]>([]);\n    const setAnchorRefs = (index: number) => {\n      return (el: any) => {\n        anchor.value[index] = el as HTMLElement;\n      };\n    };\n\n    const indexesRootStyle = computed(() => {\n      if (typeof props.height !== 'number') {\n        return {};\n      }\n      const height = Number(props.height);\n      return { height: height === 0 ? 0 : `${height}px` };\n    });\n\n    const scrollToView = (): void => {\n      const children = anchorGroup.value;\n      const targets = children.filter((ele) => {\n        const { dataset } = ele;\n        return dataset && dataset.index === state.activeSidebar;\n      });\n      targets[0]?.scrollIntoView?.();\n    };\n\n    const calcSticky = (indexesRootTop: number) => {\n      const children = anchorGroup.value;\n      for (let i = 0; i < children.length; i++) {\n        const { top: childTop, width } = children[i].getBoundingClientRect();\n        anchorStyle[i] = `z-index: ${i + 1};`;\n        if (childTop < indexesRootTop && i === state.activeIndex) {\n          anchorStyle[i] += `position:fixed;top:${indexesRootTop}px;width: ${width}px;`;\n        } else {\n          anchorStyle[i] += '';\n        }\n        const anchorHeight = anchor.value[i - 1]?.$el.getBoundingClientRect()?.height;\n        const diff = childTop - indexesRootTop - anchorHeight;\n        if (i - 1 === state.activeIndex && diff < 0) {\n          anchorStyle[i - 1] += `transform: translateY(${diff}px)`;\n        }\n      }\n    };\n\n    const calcChildPosition = (scrollTop: number) => {\n      const children = anchorGroup.value;\n      let currentIndex = -1;\n      for (let i = 0; i < children.length - 1; i++) {\n        if (scrollTop < children[i + 1].offsetTop) {\n          currentIndex = i;\n          break;\n        }\n      }\n      if (scrollTop >= children[children.length - 1].offsetTop) {\n        currentIndex = children.length - 1;\n      }\n      state.activeIndex = currentIndex;\n      state.activeSidebar = children[currentIndex].dataset.index ?? '';\n    };\n\n    const setActiveSidebarAndTip = (index: string) => {\n      state.activeSidebar = index;\n      state.showSidebarTip = true;\n    };\n\n    watchEffect(() => {\n      if (state.showSidebarTip) {\n        clearSidebarTip();\n      }\n    });\n\n    const handleSidebarItemClick = (index: string) => {\n      setActiveSidebarAndTip(index);\n      scrollToView();\n    };\n\n    const handleSidebarTouchstart = (event: TouchEvent): void => {\n      event.stopPropagation();\n      const { touches } = event;\n      touch.startX = touches[0].clientX;\n      touch.startY = touches[0].clientX;\n    };\n\n    const handleSidebarTouchmove = (event: TouchEvent): void => {\n      event.preventDefault();\n      const { touches } = event;\n      const { clientX, clientY } = touches[0];\n\n      const target = document.elementFromPoint(clientX, clientY);\n      if (target && target.className === `${componentName}__sidebar-item` && target instanceof HTMLElement) {\n        const { index } = target.dataset;\n        if (index !== undefined && state.activeSidebar !== index) {\n          setActiveSidebarAndTip(index);\n          scrollToView();\n        }\n      }\n    };\n\n    const handleRootScroll = (event: UIEvent) => {\n      if (indexesRoot.value) {\n        calcChildPosition(indexesRoot.value.scrollTop);\n        if (props.sticky) {\n          const indexesRootTop = indexesRoot.value?.getBoundingClientRect()?.top ?? 0;\n          calcSticky(indexesRootTop);\n        }\n      }\n    };\n\n    const clearSidebarTip = (): void => {\n      if (state.showSidebarTip && state.activeSidebar) {\n        timeOut && clearTimeout(timeOut);\n        timeOut = window.setTimeout(() => {\n          state.showSidebarTip = false;\n        }, 1000);\n      }\n    };\n\n    const handleCellClick = (indexes: { groupIndex: string; childrenIndex: number }) => {\n      emitEvent('select', indexes);\n    };\n\n    onMounted(() => {\n      const children = anchorGroup.value;\n      if (children.length > 0) {\n        const { index } = children[0].dataset;\n        if (index !== undefined) {\n          state.activeSidebar = index;\n        }\n      }\n    });\n    onBeforeUnmount(() => {\n      timeOut && clearTimeout(timeOut);\n    });\n\n    return {\n      ...toRefs(state),\n      indexesRoot,\n      indexesRootStyle,\n      anchorGroup,\n      anchorStyle,\n      setAnchorGroupRefs,\n      setAnchorRefs,\n      handleSidebarItemClick,\n      handleSidebarTouchmove,\n      handleSidebarTouchstart,\n      handleRootScroll,\n      handleCellClick,\n    };\n  },\n});\n</script>\n","<template>\n  <div ref=\"indexesRoot\" :style=\"indexesRootStyle\" :class=\"componentName\" @scroll=\"handleRootScroll\">\n    <div\n      v-if=\"list.length > 0\"\n      :class=\"`${componentName}__sidebar`\"\n      @touchstart=\"handleSidebarTouchstart\"\n      @touchmove=\"handleSidebarTouchmove\"\n    >\n      <div\n        v-for=\"item in list\"\n        :key=\"item.index\"\n        :class=\"[\n          `${componentName}__sidebar-item`,\n          activeSidebar === item.index ? `${componentName}__sidebar-item--active` : '',\n        ]\"\n        :data-index=\"item.index\"\n        @click.prevent=\"handleSidebarItemClick(item.index)\"\n      >\n        {{ item.index }}\n        <div v-if=\"showSidebarTip && activeSidebar === item.index\" :class=\"`${componentName}__sidebar-tip`\">\n          <span :class=\"`${componentName}__sidebar-tip-text`\">\n            {{ activeSidebar }}\n          </span>\n        </div>\n      </div>\n    </div>\n\n    <div v-for=\"(item, index) in list\" :ref=\"setAnchorGroupRefs(index)\" :key=\"item.index\" :data-index=\"item.index\">\n      <indexes-anchor :ref=\"setAnchorRefs(index)\" :anchor-style=\"anchorStyle[index]\">\n        {{ item.title ?? item.index }}\n      </indexes-anchor>\n      <div :class=\"[`${componentName}__group`]\">\n        <t-indexes-cell\n          v-for=\"(child, childrenIndex) in item.children\"\n          :key=\"child.title\"\n          :value=\"String(child.title)\"\n          :title=\"child.title\"\n          :link=\"true\"\n          :bordered=\"false\"\n          @click=\"handleCellClick({ groupIndex: item.index, childrenIndex: childrenIndex })\"\n        />\n      </div>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  ref,\n  reactive,\n  defineComponent,\n  PropType,\n  onMounted,\n  watchEffect,\n  computed,\n  onBeforeUnmount,\n  toRefs,\n  SetupContext,\n} from 'vue';\nimport config from '../config';\nimport { ListItem } from './type';\nimport IndexesProps from './props';\nimport { useEmitEvent } from '../shared';\nimport indexesAnchor from './indexes-anchor.vue';\nimport TIndexesCell from './indexes-cell.vue';\n\nconst { prefix } = config;\n\ninterface Touch {\n  startX: number;\n  startY: number;\n  deltaX: number;\n  deltaY: number;\n  offsetX: number;\n  offsetY: number;\n}\ninterface State {\n  componentName: string;\n  list: ListItem[];\n  showSidebarTip: boolean;\n  activeSidebar: string;\n  activeIndex: number;\n}\n\nconst touch: Touch = {\n  startX: 0,\n  startY: 0,\n  deltaX: 0,\n  deltaY: 0,\n  offsetX: 0,\n  offsetY: 0,\n};\n\nconst componentName = `${prefix}-indexes`;\n\nexport default defineComponent({\n  name: componentName,\n  components: { indexesAnchor, TIndexesCell },\n  props: IndexesProps,\n  emits: ['select'],\n  setup(props, context: SetupContext) {\n    const emitEvent = useEmitEvent(props, context.emit);\n    let timeOut: number;\n    const indexesRoot = ref<null | HTMLElement>(null);\n    const state: State = reactive({\n      componentName,\n      list: props.list,\n      showSidebarTip: false,\n      activeSidebar: '',\n      activeIndex: -1,\n    });\n\n    const anchorGroup = ref<HTMLElement[]>([]);\n    const setAnchorGroupRefs = (index: number) => {\n      return (el: any) => {\n        anchorGroup.value[index] = el as HTMLElement;\n      };\n    };\n\n    const anchor = ref<any[]>([]);\n    const anchorStyle = reactive<string[]>([]);\n    const setAnchorRefs = (index: number) => {\n      return (el: any) => {\n        anchor.value[index] = el as HTMLElement;\n      };\n    };\n\n    const indexesRootStyle = computed(() => {\n      if (typeof props.height !== 'number') {\n        return {};\n      }\n      const height = Number(props.height);\n      return { height: height === 0 ? 0 : `${height}px` };\n    });\n\n    const scrollToView = (): void => {\n      const children = anchorGroup.value;\n      const targets = children.filter((ele) => {\n        const { dataset } = ele;\n        return dataset && dataset.index === state.activeSidebar;\n      });\n      targets[0]?.scrollIntoView?.();\n    };\n\n    const calcSticky = (indexesRootTop: number) => {\n      const children = anchorGroup.value;\n      for (let i = 0; i < children.length; i++) {\n        const { top: childTop, width } = children[i].getBoundingClientRect();\n        anchorStyle[i] = `z-index: ${i + 1};`;\n        if (childTop < indexesRootTop && i === state.activeIndex) {\n          anchorStyle[i] += `position:fixed;top:${indexesRootTop}px;width: ${width}px;`;\n        } else {\n          anchorStyle[i] += '';\n        }\n        const anchorHeight = anchor.value[i - 1]?.$el.getBoundingClientRect()?.height;\n        const diff = childTop - indexesRootTop - anchorHeight;\n        if (i - 1 === state.activeIndex && diff < 0) {\n          anchorStyle[i - 1] += `transform: translateY(${diff}px)`;\n        }\n      }\n    };\n\n    const calcChildPosition = (scrollTop: number) => {\n      const children = anchorGroup.value;\n      let currentIndex = -1;\n      for (let i = 0; i < children.length - 1; i++) {\n        if (scrollTop < children[i + 1].offsetTop) {\n          currentIndex = i;\n          break;\n        }\n      }\n      if (scrollTop >= children[children.length - 1].offsetTop) {\n        currentIndex = children.length - 1;\n      }\n      state.activeIndex = currentIndex;\n      state.activeSidebar = children[currentIndex].dataset.index ?? '';\n    };\n\n    const setActiveSidebarAndTip = (index: string) => {\n      state.activeSidebar = index;\n      state.showSidebarTip = true;\n    };\n\n    watchEffect(() => {\n      if (state.showSidebarTip) {\n        clearSidebarTip();\n      }\n    });\n\n    const handleSidebarItemClick = (index: string) => {\n      setActiveSidebarAndTip(index);\n      scrollToView();\n    };\n\n    const handleSidebarTouchstart = (event: TouchEvent): void => {\n      event.stopPropagation();\n      const { touches } = event;\n      touch.startX = touches[0].clientX;\n      touch.startY = touches[0].clientX;\n    };\n\n    const handleSidebarTouchmove = (event: TouchEvent): void => {\n      event.preventDefault();\n      const { touches } = event;\n      const { clientX, clientY } = touches[0];\n\n      const target = document.elementFromPoint(clientX, clientY);\n      if (target && target.className === `${componentName}__sidebar-item` && target instanceof HTMLElement) {\n        const { index } = target.dataset;\n        if (index !== undefined && state.activeSidebar !== index) {\n          setActiveSidebarAndTip(index);\n          scrollToView();\n        }\n      }\n    };\n\n    const handleRootScroll = (event: UIEvent) => {\n      if (indexesRoot.value) {\n        calcChildPosition(indexesRoot.value.scrollTop);\n        if (props.sticky) {\n          const indexesRootTop = indexesRoot.value?.getBoundingClientRect()?.top ?? 0;\n          calcSticky(indexesRootTop);\n        }\n      }\n    };\n\n    const clearSidebarTip = (): void => {\n      if (state.showSidebarTip && state.activeSidebar) {\n        timeOut && clearTimeout(timeOut);\n        timeOut = window.setTimeout(() => {\n          state.showSidebarTip = false;\n        }, 1000);\n      }\n    };\n\n    const handleCellClick = (indexes: { groupIndex: string; childrenIndex: number }) => {\n      emitEvent('select', indexes);\n    };\n\n    onMounted(() => {\n      const children = anchorGroup.value;\n      if (children.length > 0) {\n        const { index } = children[0].dataset;\n        if (index !== undefined) {\n          state.activeSidebar = index;\n        }\n      }\n    });\n    onBeforeUnmount(() => {\n      timeOut && clearTimeout(timeOut);\n    });\n\n    return {\n      ...toRefs(state),\n      indexesRoot,\n      indexesRootStyle,\n      anchorGroup,\n      anchorStyle,\n      setAnchorGroupRefs,\n      setAnchorRefs,\n      handleSidebarItemClick,\n      handleSidebarTouchmove,\n      handleSidebarTouchstart,\n      handleRootScroll,\n      handleCellClick,\n    };\n  },\n});\n</script>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}