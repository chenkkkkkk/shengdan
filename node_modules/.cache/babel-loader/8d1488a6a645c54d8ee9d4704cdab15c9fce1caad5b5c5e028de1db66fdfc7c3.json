{"ast":null,"code":"/**\n * tdesign v0.14.1\n * (c) 2022 TDesign Group\n * @license MIT\n */\n\nimport _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _typeof from '@babel/runtime/helpers/typeof';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport { defineComponent, ref, toRefs, getCurrentInstance, computed, reactive, resolveComponent, openBlock, createElementBlock, normalizeClass, toDisplayString, createCommentVNode, createElementVNode, normalizeStyle, Fragment, renderList, createVNode } from 'vue';\nimport config from '../config.js';\nimport props from './props.js';\nimport { useVModel } from '../shared/useVModel/index.js';\nimport '../shared/index.js';\nimport TNodeComponent from '../shared/render-tnode.js';\nimport { renderTNode } from '../shared/render.js';\nimport '../shared/functions.js';\nimport '../shared/util.js';\nimport '../shared/component.js';\nimport '../shared/constants.js';\nimport '../shared/useToggle/index.js';\nimport '../shared/useCountDown/index.js';\nimport '@babel/runtime/helpers/asyncToGenerator';\nimport '@babel/runtime/regenerator';\nimport '@vueuse/core';\nimport '../shared/useCountDown/utils.js';\nimport '../shared/useDefault/index.js';\nimport 'lodash/camelCase';\nimport '../shared/useEmitEvent/index.js';\nimport '../shared/useChildSlots/index.js';\nimport '../shared/useTouch/index.js';\nimport '../shared/useScrollParent/index.js';\nimport '../shared/useExpose/index.js';\nimport '../shared/useTest/index.js';\nvar prefix = config.prefix;\nvar name = \"\".concat(prefix, \"-slider\");\nvar isArray = Array.isArray;\nvar script = defineComponent({\n  name: name,\n  components: {\n    TNode: TNodeComponent\n  },\n  props: props,\n  emits: [\"drag-start\", \"drag-end\", \"update:modelValue\", \"change\"],\n  setup: function setup(props2, context) {\n    var rootRef = ref(null);\n    var barRef = ref(null);\n    var defaultValue = props2.defaultValue || props2.min;\n    var _toRefs = toRefs(props2),\n      value = _toRefs.value,\n      modelValue = _toRefs.modelValue,\n      max = _toRefs.max,\n      min = _toRefs.min;\n    var _useVModel = useVModel(value, modelValue, defaultValue, props2.onChange),\n      _useVModel2 = _slicedToArray(_useVModel, 2),\n      innerValue = _useVModel2[0],\n      setInnerValue = _useVModel2[1];\n    var internalInstance = getCurrentInstance();\n    var labelContent = computed(function () {\n      return !props2.range && props2.label && (_typeof(renderTNode(internalInstance, \"label\")) === \"object\" ? renderTNode(internalInstance, \"label\") : \"\".concat(innerValue.value));\n    });\n    var isRange = computed(function () {\n      return props2.range && isArray(innerValue.value) && innerValue.value.length === 2;\n    });\n    var dots = computed(function () {\n      if (isRange.value) return innerValue.value;\n      if (typeof innerValue.value === \"number\") return [innerValue.value];\n      return [];\n    });\n    var classes = computed(function () {\n      var _ref;\n      return [\"\".concat(name, \"-wrap\"), (_ref = {}, _defineProperty(_ref, \"\".concat(prefix, \"-is-disabled\"), props2.disabled), _defineProperty(_ref, \"\".concat(prefix, \"-is-mark\"), props2.marks), _defineProperty(_ref, \"\".concat(prefix, \"-is-value\"), props2.showExtremeValue), _ref)];\n    });\n    var handleClass = computed(function () {\n      return [\"\".concat(name, \"__handle\")];\n    });\n    var marksData = computed(function () {\n      var sorter = function sorter(a, b) {\n        return a[0] - b[0];\n      };\n      if (!props2.range && props2.marks) {\n        if (isArray(props2.marks)) {\n          return props2.marks.map(function (val) {\n            return [val, val];\n          }).sort(sorter);\n        }\n        return Object.entries(props2.marks).map(function (_ref2) {\n          var _ref3 = _slicedToArray(_ref2, 2),\n            key = _ref3[0],\n            value2 = _ref3[1];\n          return [parseInt(key, 10), value2];\n        }).sort(sorter);\n      }\n      return [];\n    });\n    var dragStatus = ref(\"\");\n    var touchData = reactive({\n      startValue: 0,\n      newValue: 0,\n      startX: 0,\n      deltaX: 0,\n      offsetX: 0\n    });\n    function onTouchStart(event, value2) {\n      if (props2.disabled) {\n        return;\n      }\n      event.stopPropagation();\n      event.preventDefault();\n      touchData.deltaX = 0;\n      touchData.offsetX = 0;\n      touchData.startX = event.touches[0].clientX;\n      touchData.startValue = format(value2);\n      dragStatus.value = \"start\";\n    }\n    function onTouchMove(event, index) {\n      if (props2.disabled) return;\n      if (!barRef.value) return;\n      event.stopPropagation();\n      event.preventDefault();\n      if (dragStatus.value === \"start\") {\n        context.emit(\"drag-start\");\n      }\n      var touch = event.touches[0];\n      touchData.deltaX = touch.clientX - touchData.startX;\n      touchData.offsetX = Math.abs(touchData.deltaX);\n      dragStatus.value = \"dragging\";\n      var rect = barRef.value.getBoundingClientRect();\n      var delta = touchData.deltaX;\n      var total = rect.width;\n      var diff = delta / total * (props2.max - props2.min);\n      touchData.newValue = touchData.startValue + diff;\n      updateValue(touchData.newValue, index);\n    }\n    function onTouchEnd(event, index) {\n      if (props2.disabled) {\n        return;\n      }\n      event.stopPropagation();\n      event.preventDefault();\n      if (dragStatus.value === \"dragging\") {\n        updateValue(touchData.newValue, index, true);\n        context.emit(\"drag-end\");\n      }\n      dragStatus.value = \"\";\n    }\n    function onClick(event) {\n      var _innerValue$value;\n      event.stopPropagation();\n      if (props2.disabled) return;\n      if (!barRef.value) return;\n      var rect = barRef.value.getBoundingClientRect();\n      var delta = event.clientX - rect.left;\n      var total = rect.width;\n      var current = +props2.min + delta / total * (props2.max - props2.min);\n      var index = 0;\n      if (props2.range && innerValue.value) {\n        if (Math.abs(current - innerValue.value[0]) > Math.abs(current - innerValue.value[1])) {\n          index = 1;\n        }\n      }\n      touchData.startValue = (_innerValue$value = innerValue.value) === null || _innerValue$value === void 0 ? void 0 : _innerValue$value[index];\n      updateValue(current, index, true);\n    }\n    function format(value2) {\n      var current = value2;\n      if (!props2.range && props2.marks) {\n        var _marksData$value;\n        if (marksData !== null && marksData !== void 0 && (_marksData$value = marksData.value) !== null && _marksData$value !== void 0 && _marksData$value.length) {\n          var _marksData$value$ = _slicedToArray(marksData.value[0], 1),\n            min2 = _marksData$value$[0];\n          marksData.value.forEach(function (_ref4) {\n            var _ref5 = _slicedToArray(_ref4, 1),\n              marksDataItemValue = _ref5[0];\n            if (Math.abs(marksDataItemValue - value2) < Math.abs(min2 - value2)) {\n              min2 = marksDataItemValue;\n            }\n          });\n          current = min2;\n        }\n      }\n      return Math.round(Math.max(props2.min, Math.min(current, props2.max)) / props2.step) * props2.step;\n    }\n    function updateValue(newValue, index) {\n      var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var formatValue = format(newValue);\n      if (props2.range && Array.isArray(innerValue.value)) {\n        var tmpValue = _toConsumableArray(innerValue.value);\n        tmpValue[index] = formatValue;\n        if (end && formatValue !== touchData.startValue) {\n          tmpValue.sort(function (a, b) {\n            return a - b;\n          });\n          setInnerValue(tmpValue);\n        } else if (formatValue !== touchData.startValue) {\n          setInnerValue(tmpValue);\n        }\n      } else if (formatValue !== touchData.startValue) {\n        setInnerValue(formatValue);\n      }\n    }\n    var getPercentage = function getPercentage(value2) {\n      return (value2 ? value2 - props2.min : 0) / (props2.max - props2.min) * 100;\n    };\n    var trackStyle = computed(function () {\n      if (props2.range && isArray(innerValue.value)) {\n        return {\n          left: \"\".concat(getPercentage(Math.min(innerValue.value[0], innerValue.value[1])), \"%\"),\n          width: \"\".concat(getPercentage(Math.abs(innerValue.value[1] - innerValue.value[0])), \"%\")\n        };\n      }\n      if (!isArray(innerValue.value)) {\n        return {\n          width: \"\".concat(getPercentage(innerValue.value), \"%\")\n        };\n      }\n      return {};\n    });\n    return {\n      max: max,\n      min: min,\n      name: ref(name),\n      marksData: marksData,\n      rootRef: rootRef,\n      barRef: barRef,\n      dots: dots,\n      value: innerValue,\n      labelContent: labelContent,\n      classes: classes,\n      handleClass: handleClass,\n      trackStyle: trackStyle,\n      getPercentage: getPercentage,\n      onTouchStart: onTouchStart,\n      onTouchMove: onTouchMove,\n      onTouchEnd: onTouchEnd,\n      onClick: onClick\n    };\n  }\n});\nvar _hoisted_1 = [\"onTouchstart\", \"onTouchmove\", \"onTouchend\"];\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_t_node = resolveComponent(\"t-node\");\n  return openBlock(), createElementBlock(\"div\", {\n    ref: \"rootRef\",\n    class: normalizeClass(_ctx.classes)\n  }, [_ctx.showExtremeValue ? (openBlock(), createElementBlock(\"div\", {\n    key: 0,\n    class: normalizeClass(\"\".concat(_ctx.name, \"-wrap__value--left\"))\n  }, toDisplayString(_ctx.min), 3)) : createCommentVNode(\"\", true), createElementVNode(\"div\", {\n    class: normalizeClass(\"\".concat(_ctx.name)),\n    onClick: _cache[0] || (_cache[0] = function () {\n      return _ctx.onClick && _ctx.onClick.apply(_ctx, arguments);\n    })\n  }, [createElementVNode(\"div\", {\n    ref: \"barRef\",\n    class: normalizeClass(\"\".concat(_ctx.name, \"__bar\"))\n  }, null, 2), createElementVNode(\"div\", {\n    class: normalizeClass(\"\".concat(_ctx.name, \"__track\")),\n    style: normalizeStyle(_ctx.trackStyle)\n  }, null, 6), (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.dots, function (item, index) {\n    return openBlock(), createElementBlock(\"div\", {\n      key: index + 1,\n      class: normalizeClass(_ctx.handleClass),\n      style: normalizeStyle(\"left:\".concat(_ctx.getPercentage(item), \"%\")),\n      onTouchstart: function onTouchstart($event) {\n        return _ctx.onTouchStart($event, item);\n      },\n      onTouchmove: function onTouchmove($event) {\n        return _ctx.onTouchMove($event, index);\n      },\n      onTouchend: function onTouchend($event) {\n        return _ctx.onTouchEnd($event, index);\n      }\n    }, null, 46, _hoisted_1);\n  }), 128)), _ctx.marksData ? (openBlock(), createElementBlock(\"div\", {\n    key: 0,\n    class: normalizeClass(\"\".concat(_ctx.name, \"__mark\"))\n  }, [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.marksData, function (v, k) {\n    return openBlock(), createElementBlock(\"div\", {\n      key: k,\n      class: normalizeClass(\"\".concat(_ctx.name, \"__mark-text t-is-\").concat(_ctx.value && _ctx.value > v[0] ? \"active\" : \"\")),\n      style: normalizeStyle(\"left: \".concat(_ctx.getPercentage(v[0]), \"%\"))\n    }, toDisplayString(typeof v[1] === \"function\" ? v[1](v[0]) : v[1]), 7);\n  }), 128))], 2)) : createCommentVNode(\"\", true)], 2), _ctx.labelContent ? (openBlock(), createElementBlock(\"div\", {\n    key: 1,\n    class: normalizeClass(\"\".concat(_ctx.name, \"-wrap__value\"))\n  }, [createVNode(_component_t_node, {\n    content: _ctx.labelContent\n  }, null, 8, [\"content\"])], 2)) : createCommentVNode(\"\", true), _ctx.showExtremeValue ? (openBlock(), createElementBlock(\"div\", {\n    key: 2,\n    class: normalizeClass(\"\".concat(_ctx.name, \"-wrap__value\"))\n  }, toDisplayString(_ctx.max), 3)) : createCommentVNode(\"\", true)], 2);\n}\nscript.render = render;\nexport { script as default };","map":{"version":3,"mappings":"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","names":["prefix","config","name","isArray","Array","defineComponent","components","TNode","props","emits","setup","context","ref","toRefs","value","modelValue","max","min","useVModel","defaultValue","onChange","_useVModel2","innerValue","setInnerValue","internalInstance","getCurrentInstance","labelContent","range","label","_typeof","renderTNode","computed","length","isRange","handleClass","sorter","a","b","marks","val","entries","map","key","parseInt","sort","touchData","reactive","startValue","newValue","startX","deltaX","offsetX","event","disabled","stopPropagation","preventDefault","format","dragStatus","index","barRef","emit","touches","touch","abs","getBoundingClientRect","delta","total","rect","diff","updateValue","onClick","Math","current","_innerValue$value","_marksData$value","marksData","_ref4","marksDataItemValue","round","end","tmpValue","formatValue","getPercentage","left","width","rootRef","dots","classes","trackStyle","onTouchStart","onTouchMove","onTouchEnd","class","_ctx","_createElementBlock","_createElementVNode","style","_openBlock","_normalizeStyle","item","onTouchstart","$event","onTouchmove","onTouchend","k","v","_createVNode","_component_t_node","content"],"sources":["../../src/slider/slider.vue","../../src/slider/slider.vue?vue&type=template&id=0027e9b8&lang.js"],"sourcesContent":["<template>\n  <div ref=\"rootRef\" :class=\"classes\">\n    <div v-if=\"showExtremeValue\" :class=\"`${name}-wrap__value--left`\">{{ min }}</div>\n    <div :class=\"`${name}`\" @click=\"onClick\">\n      <!-- 总长度 -->\n      <div ref=\"barRef\" :class=\"`${name}__bar`\"></div>\n      <!-- 滑块长度 -->\n      <div :class=\"`${name}__track`\" :style=\"trackStyle\"></div>\n      <!-- 滑块操作 -->\n      <div\n        v-for=\"(item, index) in dots\"\n        :key=\"index + 1\"\n        :class=\"handleClass\"\n        :style=\"`left:${getPercentage(item)}%`\"\n        @touchstart=\"onTouchStart($event, item)\"\n        @touchmove=\"onTouchMove($event, index)\"\n        @touchend=\"onTouchEnd($event, index)\"\n      ></div>\n      <!-- 刻度内容 -->\n      <div v-if=\"marksData\" :class=\"`${name}__mark`\">\n        <div\n          v-for=\"(v, k) in marksData\"\n          :key=\"k\"\n          :class=\"`${name}__mark-text t-is-${value && value > v[0] ? 'active' : ''}`\"\n          :style=\"`left: ${getPercentage(v[0])}%`\"\n        >\n          {{ typeof v[1] === 'function' ? v[1](v[0]) : v[1] }}\n        </div>\n      </div>\n    </div>\n    <div v-if=\"labelContent\" :class=\"`${name}-wrap__value`\">\n      <t-node :content=\"labelContent\"></t-node>\n    </div>\n    <div v-if=\"showExtremeValue\" :class=\"`${name}-wrap__value`\">{{ max }}</div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { ref, toRefs, computed, SetupContext, reactive, defineComponent, getCurrentInstance } from 'vue';\nimport config from '../config';\nimport props from './props';\nimport { useVModel } from '../shared/useVModel';\nimport { renderTNode, TNode } from '../shared';\n\nconst { prefix } = config;\nconst name = `${prefix}-slider`;\nconst { isArray } = Array;\n\nexport interface TouchData {\n  startValue: number;\n  newValue: number;\n  startX: number;\n  deltaX: number;\n  offsetX: number;\n}\n\nexport default defineComponent({\n  name,\n  components: { TNode },\n  props,\n  emits: ['drag-start', 'drag-end', 'update:modelValue', 'change'],\n  setup(props, context: SetupContext) {\n    const rootRef = ref<HTMLElement | null>(null);\n    const barRef = ref<HTMLElement | null>(null);\n    const defaultValue = props.defaultValue || props.min;\n    const { value, modelValue, max, min } = toRefs(props);\n    const [innerValue, setInnerValue] = useVModel(value, modelValue, defaultValue, props.onChange);\n    const internalInstance = getCurrentInstance();\n    const labelContent = computed(\n      () =>\n        !props.range &&\n        props.label &&\n        (typeof renderTNode(internalInstance, 'label') === 'object'\n          ? renderTNode(internalInstance, 'label')\n          : `${innerValue.value}`),\n    );\n\n    const isRange = computed(() => {\n      return props.range && isArray(innerValue.value) && innerValue.value.length === 2;\n    });\n    const dots = computed(() => {\n      if (isRange.value) return innerValue.value;\n\n      if (typeof innerValue.value === 'number') return [innerValue.value];\n      return [];\n    });\n\n    const classes = computed(() => [\n      `${name}-wrap`,\n      {\n        [`${prefix}-is-disabled`]: props.disabled,\n        [`${prefix}-is-mark`]: props.marks,\n        [`${prefix}-is-value`]: props.showExtremeValue,\n      },\n    ]);\n    const handleClass = computed(() => [`${name}__handle`]);\n    const marksData = computed(() => {\n      const sorter = (a: number[], b: number[]) => a[0] - b[0];\n      if (!props.range && props.marks) {\n        if (isArray(props.marks)) {\n          return props.marks.map((val: number) => [val, val]).sort(sorter);\n        }\n        return Object.entries(props.marks)\n          .map(([key, value]) => [parseInt(key, 10), value])\n          .sort(sorter);\n      }\n      return [];\n    });\n\n    const dragStatus = ref<string>('');\n    const touchData = reactive<TouchData>({\n      startValue: 0,\n      newValue: 0,\n      startX: 0,\n      deltaX: 0,\n      offsetX: 0,\n    });\n\n    function onTouchStart(event: TouchEvent, value: number) {\n      if (props.disabled) {\n        return;\n      }\n      event.stopPropagation();\n      event.preventDefault();\n      touchData.deltaX = 0;\n      touchData.offsetX = 0;\n      touchData.startX = event.touches[0].clientX;\n      touchData.startValue = format(value);\n      dragStatus.value = 'start';\n    }\n\n    function onTouchMove(event: TouchEvent, index: number) {\n      if (props.disabled) return;\n      if (!barRef.value) return;\n\n      event.stopPropagation();\n      event.preventDefault();\n      if (dragStatus.value === 'start') {\n        context.emit('drag-start');\n      }\n      const touch = event.touches[0];\n      touchData.deltaX = touch.clientX - touchData.startX;\n      touchData.offsetX = Math.abs(touchData.deltaX);\n      dragStatus.value = 'dragging';\n\n      const rect = barRef.value.getBoundingClientRect();\n      const delta = touchData.deltaX;\n      const total = rect.width;\n      const diff = (delta / total) * (props.max - props.min);\n\n      touchData.newValue = touchData.startValue + diff;\n      updateValue(touchData.newValue, index);\n    }\n\n    function onTouchEnd(event: TouchEvent, index: number) {\n      if (props.disabled) {\n        return;\n      }\n      event.stopPropagation();\n      event.preventDefault();\n\n      if (dragStatus.value === 'dragging') {\n        updateValue(touchData.newValue, index, true);\n        context.emit('drag-end');\n      }\n\n      dragStatus.value = '';\n    }\n\n    function onClick(event: MouseEvent) {\n      event.stopPropagation();\n\n      if (props.disabled) return;\n      if (!barRef.value) return;\n\n      const rect = barRef.value.getBoundingClientRect();\n      const delta = event.clientX - rect.left;\n      const total = rect.width;\n      const current = +props.min + (delta / total) * (props.max - props.min);\n\n      let index = 0;\n      if (props.range && innerValue.value) {\n        if (Math.abs(current - innerValue.value[0]) > Math.abs(current - innerValue.value[1])) {\n          index = 1;\n        }\n      }\n\n      touchData.startValue = innerValue.value?.[index];\n      updateValue(current, index, true);\n    }\n\n    function format(value: number): number {\n      let current = value;\n      if (!props.range && props.marks) {\n        if (marksData?.value?.length) {\n          let [min] = marksData.value[0];\n          marksData.value.forEach(([marksDataItemValue]) => {\n            if (Math.abs(marksDataItemValue - value) < Math.abs(min - value)) {\n              min = marksDataItemValue;\n            }\n          });\n          current = min;\n        }\n      }\n      return Math.round(Math.max(props.min, Math.min(current, props.max)) / props.step) * props.step;\n    }\n\n    function updateValue(newValue: number, index: number, end = false) {\n      const formatValue = format(newValue);\n      if (props.range && Array.isArray(innerValue.value)) {\n        const tmpValue = [...innerValue.value];\n        tmpValue[index] = formatValue;\n\n        if (end && formatValue !== touchData.startValue) {\n          tmpValue.sort((a, b) => a - b);\n          setInnerValue(tmpValue);\n        } else if (formatValue !== touchData.startValue) {\n          setInnerValue(tmpValue);\n        }\n      } else if (formatValue !== touchData.startValue) {\n        setInnerValue(formatValue);\n      }\n    }\n\n    const getPercentage = (value: number | undefined): number =>\n      ((value ? value - props.min : 0) / (props.max - props.min)) * 100;\n    const trackStyle = computed(() => {\n      if (props.range && isArray(innerValue.value)) {\n        return {\n          left: `${getPercentage(Math.min(innerValue.value[0], innerValue.value[1]))}%`,\n          width: `${getPercentage(Math.abs(innerValue.value[1] - innerValue.value[0]))}%`,\n        };\n      }\n      if (!isArray(innerValue.value)) {\n        return {\n          width: `${getPercentage(innerValue.value)}%`,\n        };\n      }\n      return {};\n    });\n\n    return {\n      max,\n      min,\n      name: ref(name),\n      marksData,\n      rootRef,\n      barRef,\n      dots,\n      value: innerValue,\n      labelContent,\n      classes,\n      handleClass,\n      trackStyle,\n      getPercentage,\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd,\n      onClick,\n    };\n  },\n});\n</script>\n","<template>\n  <div ref=\"rootRef\" :class=\"classes\">\n    <div v-if=\"showExtremeValue\" :class=\"`${name}-wrap__value--left`\">{{ min }}</div>\n    <div :class=\"`${name}`\" @click=\"onClick\">\n      <!-- 总长度 -->\n      <div ref=\"barRef\" :class=\"`${name}__bar`\"></div>\n      <!-- 滑块长度 -->\n      <div :class=\"`${name}__track`\" :style=\"trackStyle\"></div>\n      <!-- 滑块操作 -->\n      <div\n        v-for=\"(item, index) in dots\"\n        :key=\"index + 1\"\n        :class=\"handleClass\"\n        :style=\"`left:${getPercentage(item)}%`\"\n        @touchstart=\"onTouchStart($event, item)\"\n        @touchmove=\"onTouchMove($event, index)\"\n        @touchend=\"onTouchEnd($event, index)\"\n      ></div>\n      <!-- 刻度内容 -->\n      <div v-if=\"marksData\" :class=\"`${name}__mark`\">\n        <div\n          v-for=\"(v, k) in marksData\"\n          :key=\"k\"\n          :class=\"`${name}__mark-text t-is-${value && value > v[0] ? 'active' : ''}`\"\n          :style=\"`left: ${getPercentage(v[0])}%`\"\n        >\n          {{ typeof v[1] === 'function' ? v[1](v[0]) : v[1] }}\n        </div>\n      </div>\n    </div>\n    <div v-if=\"labelContent\" :class=\"`${name}-wrap__value`\">\n      <t-node :content=\"labelContent\"></t-node>\n    </div>\n    <div v-if=\"showExtremeValue\" :class=\"`${name}-wrap__value`\">{{ max }}</div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { ref, toRefs, computed, SetupContext, reactive, defineComponent, getCurrentInstance } from 'vue';\nimport config from '../config';\nimport props from './props';\nimport { useVModel } from '../shared/useVModel';\nimport { renderTNode, TNode } from '../shared';\n\nconst { prefix } = config;\nconst name = `${prefix}-slider`;\nconst { isArray } = Array;\n\nexport interface TouchData {\n  startValue: number;\n  newValue: number;\n  startX: number;\n  deltaX: number;\n  offsetX: number;\n}\n\nexport default defineComponent({\n  name,\n  components: { TNode },\n  props,\n  emits: ['drag-start', 'drag-end', 'update:modelValue', 'change'],\n  setup(props, context: SetupContext) {\n    const rootRef = ref<HTMLElement | null>(null);\n    const barRef = ref<HTMLElement | null>(null);\n    const defaultValue = props.defaultValue || props.min;\n    const { value, modelValue, max, min } = toRefs(props);\n    const [innerValue, setInnerValue] = useVModel(value, modelValue, defaultValue, props.onChange);\n    const internalInstance = getCurrentInstance();\n    const labelContent = computed(\n      () =>\n        !props.range &&\n        props.label &&\n        (typeof renderTNode(internalInstance, 'label') === 'object'\n          ? renderTNode(internalInstance, 'label')\n          : `${innerValue.value}`),\n    );\n\n    const isRange = computed(() => {\n      return props.range && isArray(innerValue.value) && innerValue.value.length === 2;\n    });\n    const dots = computed(() => {\n      if (isRange.value) return innerValue.value;\n\n      if (typeof innerValue.value === 'number') return [innerValue.value];\n      return [];\n    });\n\n    const classes = computed(() => [\n      `${name}-wrap`,\n      {\n        [`${prefix}-is-disabled`]: props.disabled,\n        [`${prefix}-is-mark`]: props.marks,\n        [`${prefix}-is-value`]: props.showExtremeValue,\n      },\n    ]);\n    const handleClass = computed(() => [`${name}__handle`]);\n    const marksData = computed(() => {\n      const sorter = (a: number[], b: number[]) => a[0] - b[0];\n      if (!props.range && props.marks) {\n        if (isArray(props.marks)) {\n          return props.marks.map((val: number) => [val, val]).sort(sorter);\n        }\n        return Object.entries(props.marks)\n          .map(([key, value]) => [parseInt(key, 10), value])\n          .sort(sorter);\n      }\n      return [];\n    });\n\n    const dragStatus = ref<string>('');\n    const touchData = reactive<TouchData>({\n      startValue: 0,\n      newValue: 0,\n      startX: 0,\n      deltaX: 0,\n      offsetX: 0,\n    });\n\n    function onTouchStart(event: TouchEvent, value: number) {\n      if (props.disabled) {\n        return;\n      }\n      event.stopPropagation();\n      event.preventDefault();\n      touchData.deltaX = 0;\n      touchData.offsetX = 0;\n      touchData.startX = event.touches[0].clientX;\n      touchData.startValue = format(value);\n      dragStatus.value = 'start';\n    }\n\n    function onTouchMove(event: TouchEvent, index: number) {\n      if (props.disabled) return;\n      if (!barRef.value) return;\n\n      event.stopPropagation();\n      event.preventDefault();\n      if (dragStatus.value === 'start') {\n        context.emit('drag-start');\n      }\n      const touch = event.touches[0];\n      touchData.deltaX = touch.clientX - touchData.startX;\n      touchData.offsetX = Math.abs(touchData.deltaX);\n      dragStatus.value = 'dragging';\n\n      const rect = barRef.value.getBoundingClientRect();\n      const delta = touchData.deltaX;\n      const total = rect.width;\n      const diff = (delta / total) * (props.max - props.min);\n\n      touchData.newValue = touchData.startValue + diff;\n      updateValue(touchData.newValue, index);\n    }\n\n    function onTouchEnd(event: TouchEvent, index: number) {\n      if (props.disabled) {\n        return;\n      }\n      event.stopPropagation();\n      event.preventDefault();\n\n      if (dragStatus.value === 'dragging') {\n        updateValue(touchData.newValue, index, true);\n        context.emit('drag-end');\n      }\n\n      dragStatus.value = '';\n    }\n\n    function onClick(event: MouseEvent) {\n      event.stopPropagation();\n\n      if (props.disabled) return;\n      if (!barRef.value) return;\n\n      const rect = barRef.value.getBoundingClientRect();\n      const delta = event.clientX - rect.left;\n      const total = rect.width;\n      const current = +props.min + (delta / total) * (props.max - props.min);\n\n      let index = 0;\n      if (props.range && innerValue.value) {\n        if (Math.abs(current - innerValue.value[0]) > Math.abs(current - innerValue.value[1])) {\n          index = 1;\n        }\n      }\n\n      touchData.startValue = innerValue.value?.[index];\n      updateValue(current, index, true);\n    }\n\n    function format(value: number): number {\n      let current = value;\n      if (!props.range && props.marks) {\n        if (marksData?.value?.length) {\n          let [min] = marksData.value[0];\n          marksData.value.forEach(([marksDataItemValue]) => {\n            if (Math.abs(marksDataItemValue - value) < Math.abs(min - value)) {\n              min = marksDataItemValue;\n            }\n          });\n          current = min;\n        }\n      }\n      return Math.round(Math.max(props.min, Math.min(current, props.max)) / props.step) * props.step;\n    }\n\n    function updateValue(newValue: number, index: number, end = false) {\n      const formatValue = format(newValue);\n      if (props.range && Array.isArray(innerValue.value)) {\n        const tmpValue = [...innerValue.value];\n        tmpValue[index] = formatValue;\n\n        if (end && formatValue !== touchData.startValue) {\n          tmpValue.sort((a, b) => a - b);\n          setInnerValue(tmpValue);\n        } else if (formatValue !== touchData.startValue) {\n          setInnerValue(tmpValue);\n        }\n      } else if (formatValue !== touchData.startValue) {\n        setInnerValue(formatValue);\n      }\n    }\n\n    const getPercentage = (value: number | undefined): number =>\n      ((value ? value - props.min : 0) / (props.max - props.min)) * 100;\n    const trackStyle = computed(() => {\n      if (props.range && isArray(innerValue.value)) {\n        return {\n          left: `${getPercentage(Math.min(innerValue.value[0], innerValue.value[1]))}%`,\n          width: `${getPercentage(Math.abs(innerValue.value[1] - innerValue.value[0]))}%`,\n        };\n      }\n      if (!isArray(innerValue.value)) {\n        return {\n          width: `${getPercentage(innerValue.value)}%`,\n        };\n      }\n      return {};\n    });\n\n    return {\n      max,\n      min,\n      name: ref(name),\n      marksData,\n      rootRef,\n      barRef,\n      dots,\n      value: innerValue,\n      labelContent,\n      classes,\n      handleClass,\n      trackStyle,\n      getPercentage,\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd,\n      onClick,\n    };\n  },\n});\n</script>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}