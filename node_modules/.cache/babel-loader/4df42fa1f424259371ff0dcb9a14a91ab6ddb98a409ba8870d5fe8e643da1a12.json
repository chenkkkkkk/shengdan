{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * tdesign v0.14.1\n * (c) 2022 TDesign Group\n * @license MIT\n */\n\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport { defineComponent, getCurrentInstance, ref, computed, reactive, onMounted, nextTick, watch, provide, resolveComponent, openBlock, createElementBlock, normalizeStyle, normalizeClass, createElementVNode, renderSlot, Fragment, createVNode, createCommentVNode, renderList, toDisplayString, createBlock } from 'vue';\nimport { ChevronLeftIcon, ChevronRightIcon } from 'tdesign-icons-vue-next';\nimport { useSwipe } from '@vueuse/core';\nimport SwiperProps from './props.js';\nimport config from '../config.js';\nimport '../shared/index.js';\nimport TNodeComponent from '../shared/render-tnode.js';\nimport { useDefault } from '../shared/useDefault/index.js';\nimport { renderTNode } from '../shared/render.js';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport '../shared/functions.js';\nimport '../shared/util.js';\nimport '../shared/component.js';\nimport '../shared/constants.js';\nimport '../shared/useToggle/index.js';\nimport '../shared/useCountDown/index.js';\nimport '@babel/runtime/helpers/asyncToGenerator';\nimport '@babel/runtime/regenerator';\nimport '../shared/useCountDown/utils.js';\nimport '../shared/useEmitEvent/index.js';\nimport 'lodash/camelCase';\nimport '../shared/useChildSlots/index.js';\nimport '@babel/runtime/helpers/toConsumableArray';\nimport '../shared/useVModel/index.js';\nimport '../shared/useTouch/index.js';\nimport '../shared/useScrollParent/index.js';\nimport '../shared/useExpose/index.js';\nimport '../shared/useTest/index.js';\nimport '@babel/runtime/helpers/typeof';\nvar prefix = config.prefix;\nvar name = \"\".concat(prefix, \"-swiper\");\nvar setOffset = function setOffset(element, offset) {\n  var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"X\";\n  element.style.transform = \"translate\".concat(direction, \"(\").concat(offset, \"px)\");\n};\nvar script = defineComponent({\n  name: name,\n  components: {\n    ChevronLeftIcon: ChevronLeftIcon,\n    ChevronRightIcon: ChevronRightIcon,\n    TNode: TNodeComponent\n  },\n  props: SwiperProps,\n  emits: [\"change\", \"update:current\", \"update:modelValue\"],\n  setup: function setup(props, context) {\n    var _useDefault = useDefault(props, context.emit, \"current\", \"change\"),\n      _useDefault2 = _slicedToArray(_useDefault, 2),\n      swiperValue = _useDefault2[0],\n      setSwiperValue = _useDefault2[1];\n    var self = getCurrentInstance();\n    var swiperContainer = ref(null);\n    var computedNavigation = computed(function () {\n      return renderTNode(self, \"navigation\");\n    });\n    var height = props.height || 180;\n    var state = reactive({\n      showNavigation: true,\n      activeIndex: 0,\n      itemLength: 0,\n      itemWidth: 0,\n      isControl: false,\n      btnDisabled: false,\n      children: []\n    });\n    var paginationList = computed(function () {\n      return new Array(state.itemLength).fill(1);\n    });\n    var showPageNum = computed(function () {\n      var activeIndex = state.activeIndex,\n        itemLength = state.itemLength;\n      if (activeIndex > itemLength - 1) return itemLength;\n      if (activeIndex < 0) return 1;\n      return activeIndex + 1;\n    });\n    var childCount = computed(function () {\n      return state.children.length;\n    });\n    var getContainer = function getContainer() {\n      var _self$proxy;\n      return self === null || self === void 0 ? void 0 : (_self$proxy = self.proxy) === null || _self$proxy === void 0 ? void 0 : _self$proxy.$el.querySelector(\".\".concat(name, \"__container\"));\n    };\n    var initSwiper = function initSwiper() {\n      var _swiperContainer$chil, _swiperContainer$quer;\n      var _swiperContainer = getContainer();\n      _swiperContainer.querySelectorAll(\".copy-item\").forEach(function (ele) {\n        _swiperContainer.removeChild(ele);\n      });\n      var items = _swiperContainer.querySelectorAll(\".\".concat(name, \"-item\"));\n      state.itemLength = ((_swiperContainer$chil = _swiperContainer.children) === null || _swiperContainer$chil === void 0 ? void 0 : _swiperContainer$chil.length) || 0;\n      var itemWidth = ((_swiperContainer$quer = _swiperContainer.querySelector(\".\".concat(name, \"-item\"))) === null || _swiperContainer$quer === void 0 ? void 0 : _swiperContainer$quer.getBoundingClientRect().width) || 0;\n      state.itemWidth = itemWidth;\n      if (items.length <= 0) return false;\n      if (computedNavigation.value && \"minShowNum\" in computedNavigation.value && items.length < computedNavigation.value.minShowNum) {\n        state.showNavigation = false;\n      }\n      if (props !== null && props !== void 0 && props.loop) {\n        var first = items[0].cloneNode(true);\n        first.classList.add(\"copy-item\");\n        var last = items[items.length - 1].cloneNode(true);\n        last.classList.add(\"copy-item\");\n        _swiperContainer.appendChild(first);\n        _swiperContainer.insertBefore(last, items[0]);\n      }\n      move(0);\n      startAutoplay();\n      if (typeof props.current === \"number\") {\n        state.isControl = true;\n        next(props.current);\n      }\n    };\n    onMounted(function () {\n      nextTick(function () {\n        console.info(\"swiper mounted\");\n        initSwiper();\n      });\n    });\n    watch(function () {\n      return state.children.length;\n    }, function () {\n      nextTick(function () {\n        console.info(\"swiper mounted\");\n        initSwiper();\n      });\n    });\n    var autoplayTimer = null;\n    var actionIsTrust = true;\n    var move = function move(targetIndex) {\n      var isTrust = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      var _swiperContainer = getContainer();\n      var moveDirection = (props === null || props === void 0 ? void 0 : props.direction) === \"horizontal\" ? \"X\" : \"Y\";\n      var moveLength = (props === null || props === void 0 ? void 0 : props.direction) === \"vertical\" ? height : state.itemWidth;\n      actionIsTrust = isTrust;\n      _swiperContainer.dataset.isTrust = \"\".concat(isTrust);\n      var toIndex = props !== null && props !== void 0 && props.loop ? targetIndex + 1 : targetIndex;\n      _swiperContainer.style.transform = \"translate\".concat(moveDirection, \"(-\").concat(moveLength * toIndex, \"px)\");\n    };\n    var addAnimation = function addAnimation() {\n      var _swiperContainer = getContainer();\n      _swiperContainer.style.transition = \"transform \".concat(props === null || props === void 0 ? void 0 : props.duration, \"ms\");\n    };\n    var removeAnimation = function removeAnimation() {\n      var _swiperContainer = getContainer();\n      _swiperContainer.style.transition = \"none\";\n    };\n    var handleAnimationEnd = function handleAnimationEnd() {\n      state.btnDisabled = false;\n      removeAnimation();\n      if (state.activeIndex >= state.itemLength) {\n        state.activeIndex = 0;\n        move(0);\n      }\n      if (state.activeIndex <= -1) {\n        state.activeIndex = state.itemLength - 1;\n        move(state.itemLength - 1);\n      }\n      setTimeout(function () {\n        actionIsTrust && emitCurrentChange(state.activeIndex);\n      }, 0);\n    };\n    var stopAutoplay = function stopAutoplay() {\n      if (!autoplayTimer) return;\n      clearInterval(autoplayTimer);\n      autoplayTimer = null;\n    };\n    var startAutoplay = function startAutoplay() {\n      if (typeof props.current === \"number\") return false;\n      if (!(props !== null && props !== void 0 && props.autoplay) || autoplayTimer !== null) return false;\n      autoplayTimer = setInterval(function () {\n        state.activeIndex += 1;\n        if (!(props !== null && props !== void 0 && props.loop) && state.activeIndex >= state.children.length - 1) {\n          state.activeIndex = 0;\n        }\n        if (!(props !== null && props !== void 0 && props.loop) && state.activeIndex <= 0) {\n          state.activeIndex = state.children.length - 1;\n        }\n        addAnimation();\n        move(state.activeIndex);\n      }, props === null || props === void 0 ? void 0 : props.interval);\n    };\n    var emitCurrentChange = function emitCurrentChange(index) {\n      var resultIndex = index;\n      if (index >= state.itemLength) resultIndex = 0;\n      if (index < 0) resultIndex = state.itemLength - 1;\n      setSwiperValue(resultIndex);\n    };\n    var prev = function prev() {\n      var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var cannotMovePrev = !(props !== null && props !== void 0 && props.loop) && state.activeIndex === 0;\n      if (state.btnDisabled || cannotMovePrev) {\n        move(state.activeIndex);\n        return false;\n      }\n      stopAutoplay();\n      state.activeIndex -= step;\n      addAnimation();\n      move(state.activeIndex);\n      startAutoplay();\n      state.btnDisabled = true;\n    };\n    var next = function next() {\n      var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var cannotMoveLast = !(props !== null && props !== void 0 && props.loop) && state.activeIndex === state.itemLength - 1;\n      if (state.btnDisabled || cannotMoveLast) {\n        move(state.activeIndex);\n        return false;\n      }\n      stopAutoplay();\n      state.activeIndex += step;\n      addAnimation();\n      move(state.activeIndex);\n      startAutoplay();\n      state.btnDisabled = true;\n    };\n    var _useSwipe = useSwipe(swiperContainer, {\n        passive: false,\n        onSwipeStart: function onSwipeStart(e) {\n          if (state.btnDisabled) return false;\n          stopAutoplay();\n        },\n        onSwipe: function onSwipe(e) {\n          if (state.btnDisabled) return false;\n          onTouchMove(e);\n        },\n        onSwipeEnd: function onSwipeEnd() {\n          onTouchEnd();\n        }\n      }),\n      lengthX = _useSwipe.lengthX,\n      lengthY = _useSwipe.lengthY;\n    var onTouchMove = function onTouchMove(event) {\n      event.preventDefault();\n      var activeIndex = state.activeIndex,\n        itemWidth = state.itemWidth;\n      var distanceX = lengthX.value;\n      var distanceY = lengthY.value;\n      var _container = getContainer();\n      removeAnimation();\n      var toIndex = props !== null && props !== void 0 && props.loop ? activeIndex + 1 : activeIndex;\n      if ((props === null || props === void 0 ? void 0 : props.direction) === \"horizontal\") {\n        setOffset(_container, -(toIndex * itemWidth + distanceX));\n      } else {\n        var _props$height = props.height,\n          height2 = _props$height === void 0 ? 180 : _props$height;\n        setOffset(_container, -(toIndex * height2 + distanceY), \"Y\");\n      }\n    };\n    var onTouchEnd = function onTouchEnd() {\n      var distanceX = lengthX.value;\n      var distanceY = lengthY.value;\n      addAnimation();\n      if ((props === null || props === void 0 ? void 0 : props.direction) === \"horizontal\" && distanceX < -100 || (props === null || props === void 0 ? void 0 : props.direction) === \"vertical\" && distanceY < -100) {\n        prev(1);\n      } else if ((props === null || props === void 0 ? void 0 : props.direction) === \"horizontal\" && distanceX > 100 || (props === null || props === void 0 ? void 0 : props.direction) === \"vertical\" && distanceY > 100) {\n        next(1);\n      } else {\n        move(state.activeIndex);\n      }\n      startAutoplay();\n    };\n    var relation = function relation(child) {\n      if (child.proxy) {\n        state.children.push(child.proxy);\n      }\n    };\n    provide(\"parent\", {\n      props: props,\n      relation: relation\n    });\n    watch(function () {\n      return props.current;\n    }, function (newPage, oldPage) {\n      if (state.isControl) {\n        state.activeIndex = newPage || 0;\n        addAnimation();\n        move(state.activeIndex, false);\n      }\n    });\n    return {\n      swiperContainer: swiperContainer,\n      name: name,\n      computedNavigation: computedNavigation,\n      onTouchMove: onTouchMove,\n      onTouchEnd: onTouchEnd,\n      handleAnimationEnd: handleAnimationEnd,\n      state: state,\n      paginationList: paginationList,\n      showPageNum: showPageNum,\n      prev: prev,\n      next: next\n    };\n  }\n});\nvar _hoisted_1 = {\n  key: 0\n};\nvar _hoisted_2 = {\n  key: 1\n};\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_chevron_left_icon = resolveComponent(\"chevron-left-icon\");\n  var _component_chevron_right_icon = resolveComponent(\"chevron-right-icon\");\n  var _component_t_node = resolveComponent(\"t-node\");\n  return openBlock(), createElementBlock(\"div\", {\n    style: normalizeStyle({\n      height: \"\".concat(_ctx.height, \"px\"),\n      overflow: \"hidden\"\n    }),\n    class: normalizeClass(\"\".concat(_ctx.name))\n  }, [createElementVNode(\"div\", {\n    ref: \"swiperContainer\",\n    class: normalizeClass(\"\".concat(_ctx.name, \"__container\")),\n    style: normalizeStyle({\n      height: \"\".concat(_ctx.height, \"px\"),\n      flexDirection: _ctx.direction === \"horizontal\" ? \"row\" : \"column\"\n    }),\n    onTransitionend: _cache[0] || (_cache[0] = function () {\n      return _ctx.handleAnimationEnd && _ctx.handleAnimationEnd.apply(_ctx, arguments);\n    })\n  }, [renderSlot(_ctx.$slots, \"default\")], 38), _ctx.navigation && _ctx.state.showNavigation ? (openBlock(), createElementBlock(Fragment, {\n    key: 0\n  }, [_ctx.direction === \"horizontal\" && \"showSlideBtn\" in _ctx.navigation && _ctx.navigation.showSlideBtn ? (openBlock(), createElementBlock(\"span\", _hoisted_1, [createElementVNode(\"span\", {\n    class: normalizeClass(\"\".concat(_ctx.name, \"__btn btn-prev\")),\n    onClick: _cache[1] || (_cache[1] = function ($event) {\n      return _ctx.prev(1);\n    })\n  }, [createVNode(_component_chevron_left_icon, {\n    size: \"20px\"\n  })], 2), createElementVNode(\"span\", {\n    class: normalizeClass(\"\".concat(_ctx.name, \"__btn btn-next\")),\n    onClick: _cache[2] || (_cache[2] = function ($event) {\n      return _ctx.next(1);\n    })\n  }, [createVNode(_component_chevron_right_icon, {\n    size: \"20px\"\n  })], 2)])) : createCommentVNode(\"\", true), \"type\" in _ctx.navigation ? (openBlock(), createElementBlock(\"span\", {\n    key: 1,\n    class: normalizeClass(\"\".concat(_ctx.name, \"__pagination \").concat(_ctx.name, \"__pagination-\").concat(_ctx.navigation.type || \"\", \" \").concat(_ctx.name, \"__pagination-\").concat(_ctx.paginationPosition))\n  }, [[\"dots\", \"dots-bar\"].includes(_ctx.navigation.type || \"\") ? (openBlock(true), createElementBlock(Fragment, {\n    key: 0\n  }, renderList(_ctx.state.children.length, function (item, index) {\n    var _normalizeClass2;\n    return openBlock(), createElementBlock(\"span\", {\n      key: \"page\" + index,\n      class: normalizeClass((_normalizeClass2 = {}, _defineProperty(_normalizeClass2, \"\".concat(_ctx.name, \"-dot\"), true), _defineProperty(_normalizeClass2, \"\".concat(_ctx.name, \"-dot--active\"), index === _ctx.state.activeIndex), _normalizeClass2))\n    }, null, 2);\n  }), 128)) : createCommentVNode(\"\", true), _ctx.navigation.type && _ctx.navigation.type === \"fraction\" ? (openBlock(), createElementBlock(\"span\", _hoisted_2, toDisplayString(_ctx.showPageNum + \"/\" + _ctx.state.children.length), 1)) : createCommentVNode(\"\", true)], 2)) : createCommentVNode(\"\", true)], 64)) : _ctx.computedNavigation !== void 0 ? (openBlock(), createBlock(_component_t_node, {\n    key: 1,\n    content: _ctx.computedNavigation,\n    style: {}\n  }, null, 8, [\"content\"])) : createCommentVNode(\"\", true)], 6);\n}\nscript.render = render;\nexport { script as default };","map":{"version":3,"mappings":"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","names":["prefix","config","name","setOffset","element","direction","transform","defineComponent","components","ChevronLeftIcon","ChevronRightIcon","TNode","props","emits","setup","context","useDefault","emit","_useDefault2","swiperValue","setSwiperValue","self","getCurrentInstance","ref","computedNavigation","computed","renderTNode","height","state","reactive","showNavigation","activeIndex","itemLength","itemWidth","isControl","btnDisabled","children","Array","fill","childCount","length","getContainer","proxy","$el","initSwiper","_swiperContainer","querySelectorAll","ele","removeChild","items","querySelector","_swiperContainer$quer","getBoundingClientRect","width","value","minShowNum","loop","first","add","last","cloneNode","appendChild","move","startAutoplay","next","current","onMounted","nextTick","console","info","watch","autoplayTimer","actionIsTrust","targetIndex","isTrust","moveDirection","moveLength","toIndex","style","addAnimation","transition","removeAnimation","handleAnimationEnd","setTimeout","stopAutoplay","clearInterval","setInterval","interval","emitCurrentChange","index","resultIndex","prev","step","cannotMovePrev","cannotMoveLast","useSwipe","swiperContainer","passive","onSwipeStart","e","onSwipe","onTouchMove","onSwipeEnd","onTouchEnd","lengthX","lengthY","event","preventDefault","distanceX","distanceY","_container","relation","child","push","provide","newPage","oldPage","paginationList","showPageNum","_ctx","overflow","class","_createElementVNode","_normalizeStyle","onTransitionend","_renderSlot","_Fragment","key","showSlideBtn","onClick","$event","_createVNode","size","_createElementBlock","type","item","_normalizeClass","_component_t_node","content"],"sources":["../../src/swiper/swiper.vue","../../src/swiper/swiper.vue?vue&type=template&id=2ac5cb78&lang.js"],"sourcesContent":["<template>\n  <div :style=\"{ height: `${height}px`, overflow: 'hidden' }\" :class=\"`${name}`\">\n    <div\n      ref=\"swiperContainer\"\n      :class=\"`${name}__container`\"\n      :style=\"{\n        height: `${height}px`,\n        flexDirection: direction === 'horizontal' ? 'row' : 'column',\n      }\"\n      @transitionend=\"handleAnimationEnd\"\n    >\n      <slot></slot>\n    </div>\n    <template v-if=\"navigation && state.showNavigation\">\n      <span v-if=\"direction === 'horizontal' && 'showSlideBtn' in navigation && navigation.showSlideBtn\">\n        <span :class=\"`${name}__btn btn-prev`\" @click=\"prev(1)\">\n          <chevron-left-icon size=\"20px\" />\n        </span>\n        <span :class=\"`${name}__btn btn-next`\" @click=\"next(1)\">\n          <chevron-right-icon size=\"20px\" />\n        </span>\n      </span>\n      <span\n        v-if=\"'type' in navigation\"\n        :class=\"`${name}__pagination ${name}__pagination-${\n          navigation.type || ''\n        } ${name}__pagination-${paginationPosition}`\"\n      >\n        <template v-if=\"['dots', 'dots-bar'].includes(navigation.type || '')\">\n          <span\n            v-for=\"(item, index) in state.children.length\"\n            :key=\"'page' + index\"\n            :class=\"{ [`${name}-dot`]: true, [`${name}-dot--active`]: index === state.activeIndex }\"\n          ></span>\n        </template>\n        <span v-if=\"navigation.type && navigation.type === 'fraction'\">\n          {{ showPageNum + '/' + state.children.length }}\n        </span>\n      </span>\n    </template>\n    <template v-else-if=\"computedNavigation !== undefined\">\n      <t-node :content=\"computedNavigation\" :style=\"{}\"></t-node>\n    </template>\n  </div>\n</template>\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  reactive,\n  getCurrentInstance,\n  onMounted,\n  computed,\n  watch,\n  ref,\n  SetupContext,\n  nextTick,\n  provide,\n  ComponentInternalInstance,\n  ComponentPublicInstance,\n} from 'vue';\nimport { ChevronLeftIcon, ChevronRightIcon } from 'tdesign-icons-vue-next';\nimport { useSwipe } from '@vueuse/core';\nimport SwiperProps from './props';\nimport config from '../config';\nimport { renderTNode, useDefault, TNode } from '../shared';\nimport { TdSwiperProps } from './type';\n\nconst { prefix } = config;\nconst name = `${prefix}-swiper`;\nconst setOffset = (element: HTMLDivElement, offset: number, direction = 'X'): void => {\n  // eslint-disable-next-line no-param-reassign\n  element.style.transform = `translate${direction}(${offset}px)`;\n};\nexport default defineComponent({\n  name,\n  components: { ChevronLeftIcon, ChevronRightIcon, TNode },\n  props: SwiperProps,\n  emits: ['change', 'update:current', 'update:modelValue'],\n  setup(props, context: SetupContext) {\n    // const emitEvent = useEmitEvent(props, context.emit);\n    const [swiperValue, setSwiperValue] = useDefault<Number, TdSwiperProps>(props, context.emit, 'current', 'change');\n    const self = getCurrentInstance();\n    const swiperContainer = ref<HTMLElement | null>(null);\n    const computedNavigation = computed(() => renderTNode(self, 'navigation'));\n    // const { height = 180, current = null } = props;\n    const height = props.height || 180;\n    const state: {\n      showNavigation: boolean;\n      activeIndex: number;\n      itemLength: number;\n      itemWidth: number;\n      isControl: boolean;\n      btnDisabled: boolean;\n      children: ComponentPublicInstance[];\n    } = reactive({\n      showNavigation: true,\n      activeIndex: 0,\n      itemLength: 0,\n      itemWidth: 0,\n      isControl: false,\n      btnDisabled: false,\n      children: [] as ComponentPublicInstance[],\n    });\n    const paginationList = computed(() => new Array(state.itemLength).fill(1));\n    const showPageNum = computed(() => {\n      const { activeIndex, itemLength } = state;\n      if (activeIndex > itemLength - 1) return itemLength;\n      if (activeIndex < 0) return 1;\n      return activeIndex + 1;\n    });\n    const childCount = computed(() => state.children.length);\n    const getContainer = (): HTMLDivElement => self?.proxy?.$el.querySelector(`.${name}__container`);\n    // const getContainer = (): HTMLDivElement => swiperContainer.value as any;\n    const initSwiper = () => {\n      const _swiperContainer = getContainer();\n      _swiperContainer.querySelectorAll('.copy-item').forEach((ele) => {\n        _swiperContainer.removeChild(ele);\n      });\n      const items = _swiperContainer.querySelectorAll(`.${name}-item`);\n      state.itemLength = _swiperContainer.children?.length || 0;\n      const itemWidth = _swiperContainer.querySelector(`.${name}-item`)?.getBoundingClientRect().width || 0;\n      state.itemWidth = itemWidth;\n      if (items.length <= 0) return false;\n      if (\n        computedNavigation.value &&\n        'minShowNum' in computedNavigation.value &&\n        items.length < computedNavigation.value.minShowNum\n      ) {\n        state.showNavigation = false;\n      }\n      if (props?.loop) {\n        const first = items[0].cloneNode(true) as HTMLDivElement;\n        first.classList.add('copy-item');\n        const last = items[items.length - 1].cloneNode(true) as HTMLDivElement;\n        last.classList.add('copy-item');\n        _swiperContainer.appendChild(first);\n        _swiperContainer.insertBefore(last, items[0]);\n      }\n      move(0);\n      startAutoplay();\n      if (typeof props.current === 'number') {\n        state.isControl = true;\n        next(props.current);\n      }\n    };\n    onMounted(() => {\n      nextTick(() => {\n        console.info('swiper mounted');\n        initSwiper();\n      });\n    });\n    watch(\n      () => state.children.length,\n      () => {\n        nextTick(() => {\n          console.info('swiper mounted');\n          initSwiper();\n        });\n      },\n    );\n    // eslint-disable-next-line no-undef\n    let autoplayTimer: number | NodeJS.Timeout | null = null;\n    let actionIsTrust = true;\n    /**\n     * move item\n     */\n    const move = (targetIndex: number, isTrust = true) => {\n      const _swiperContainer = getContainer();\n      const moveDirection = props?.direction === 'horizontal' ? 'X' : 'Y';\n      const moveLength: number = props?.direction === 'vertical' ? height : state.itemWidth;\n      actionIsTrust = isTrust;\n      _swiperContainer.dataset.isTrust = `${isTrust}`;\n      // do not translate one item if not loop\n      const toIndex = props?.loop ? targetIndex + 1 : targetIndex;\n      _swiperContainer.style.transform = `translate${moveDirection}(-${moveLength * toIndex}px)`;\n    };\n    const addAnimation = () => {\n      const _swiperContainer = getContainer();\n      _swiperContainer.style.transition = `transform ${props?.duration}ms`;\n    };\n    const removeAnimation = () => {\n      const _swiperContainer = getContainer();\n      _swiperContainer.style.transition = 'none';\n    };\n    const handleAnimationEnd = () => {\n      state.btnDisabled = false;\n      removeAnimation();\n      if (state.activeIndex >= state.itemLength) {\n        state.activeIndex = 0;\n        move(0);\n      }\n      if (state.activeIndex <= -1) {\n        state.activeIndex = state.itemLength - 1;\n        move(state.itemLength - 1);\n      }\n      setTimeout(() => {\n        actionIsTrust && emitCurrentChange(state.activeIndex);\n      }, 0);\n    };\n    const stopAutoplay = () => {\n      if (!autoplayTimer) return;\n      clearInterval(autoplayTimer as number);\n      autoplayTimer = null;\n    };\n    const startAutoplay = () => {\n      if (typeof props.current === 'number') return false;\n      if (!props?.autoplay || autoplayTimer !== null) return false; // stop repeat autoplay\n      autoplayTimer = setInterval(() => {\n        state.activeIndex += 1;\n        if (!props?.loop && state.activeIndex >= state.children.length - 1) {\n          state.activeIndex = 0;\n        }\n        if (!props?.loop && state.activeIndex <= 0) {\n          state.activeIndex = state.children.length - 1;\n        }\n        addAnimation();\n        move(state.activeIndex);\n      }, props?.interval);\n    };\n    const emitCurrentChange = (index: number) => {\n      // if (!state.isControl) return false;\n      let resultIndex = index;\n      if (index >= state.itemLength) resultIndex = 0;\n      if (index < 0) resultIndex = state.itemLength - 1;\n      // emitEvent('change', resultIndex);\n      setSwiperValue(resultIndex);\n    };\n    const prev = (step = 1) => {\n      const cannotMovePrev = !props?.loop && state.activeIndex === 0;\n      if (state.btnDisabled || cannotMovePrev) {\n        move(state.activeIndex);\n        return false;\n      }\n      stopAutoplay();\n      state.activeIndex -= step;\n      addAnimation();\n      move(state.activeIndex);\n      startAutoplay();\n      state.btnDisabled = true;\n    };\n    const next = (step = 1) => {\n      const cannotMoveLast = !props?.loop && state.activeIndex === state.itemLength - 1;\n      if (state.btnDisabled || cannotMoveLast) {\n        move(state.activeIndex);\n        return false;\n      }\n      stopAutoplay();\n      state.activeIndex += step;\n      addAnimation();\n      move(state.activeIndex);\n      startAutoplay();\n      state.btnDisabled = true;\n    };\n    const { lengthX, lengthY } = useSwipe(swiperContainer, {\n      passive: false,\n      onSwipeStart(e: TouchEvent) {\n        if (state.btnDisabled) return false;\n        stopAutoplay();\n      },\n      onSwipe(e: TouchEvent) {\n        if (state.btnDisabled) return false;\n        onTouchMove(e);\n      },\n      onSwipeEnd() {\n        onTouchEnd();\n      },\n    });\n    const onTouchMove = (event: TouchEvent) => {\n      event.preventDefault();\n      const { activeIndex, itemWidth } = state;\n      const distanceX = lengthX.value;\n      const distanceY = lengthY.value;\n      const _container = getContainer();\n      removeAnimation();\n      const toIndex = props?.loop ? activeIndex + 1 : activeIndex;\n      if (props?.direction === 'horizontal') {\n        setOffset(_container, -(toIndex * itemWidth + distanceX));\n      } else {\n        const { height = 180 } = props;\n        setOffset(_container, -(toIndex * height + distanceY), 'Y');\n      }\n    };\n    const onTouchEnd = () => {\n      const distanceX = lengthX.value;\n      const distanceY = lengthY.value;\n      addAnimation();\n      if (\n        (props?.direction === 'horizontal' && distanceX < -100) ||\n        (props?.direction === 'vertical' && distanceY < -100)\n      ) {\n        prev(1);\n      } else if (\n        (props?.direction === 'horizontal' && distanceX > 100) ||\n        (props?.direction === 'vertical' && distanceY > 100)\n      ) {\n        next(1);\n      } else {\n        move(state.activeIndex);\n      }\n      startAutoplay();\n    };\n    const relation = (child: ComponentInternalInstance) => {\n      if (child.proxy) {\n        state.children.push(child.proxy);\n      }\n    };\n    provide('parent', {\n      props,\n      relation,\n    });\n    watch(\n      () => props.current,\n      (newPage, oldPage) => {\n        if (state.isControl) {\n          state.activeIndex = newPage || 0;\n          addAnimation();\n          move(state.activeIndex, false);\n        }\n      },\n    );\n    return {\n      swiperContainer,\n      name,\n      computedNavigation,\n      onTouchMove,\n      onTouchEnd,\n      handleAnimationEnd,\n      state,\n      paginationList,\n      showPageNum,\n      prev,\n      next,\n    };\n  },\n});\n</script>\n","<template>\n  <div :style=\"{ height: `${height}px`, overflow: 'hidden' }\" :class=\"`${name}`\">\n    <div\n      ref=\"swiperContainer\"\n      :class=\"`${name}__container`\"\n      :style=\"{\n        height: `${height}px`,\n        flexDirection: direction === 'horizontal' ? 'row' : 'column',\n      }\"\n      @transitionend=\"handleAnimationEnd\"\n    >\n      <slot></slot>\n    </div>\n    <template v-if=\"navigation && state.showNavigation\">\n      <span v-if=\"direction === 'horizontal' && 'showSlideBtn' in navigation && navigation.showSlideBtn\">\n        <span :class=\"`${name}__btn btn-prev`\" @click=\"prev(1)\">\n          <chevron-left-icon size=\"20px\" />\n        </span>\n        <span :class=\"`${name}__btn btn-next`\" @click=\"next(1)\">\n          <chevron-right-icon size=\"20px\" />\n        </span>\n      </span>\n      <span\n        v-if=\"'type' in navigation\"\n        :class=\"`${name}__pagination ${name}__pagination-${\n          navigation.type || ''\n        } ${name}__pagination-${paginationPosition}`\"\n      >\n        <template v-if=\"['dots', 'dots-bar'].includes(navigation.type || '')\">\n          <span\n            v-for=\"(item, index) in state.children.length\"\n            :key=\"'page' + index\"\n            :class=\"{ [`${name}-dot`]: true, [`${name}-dot--active`]: index === state.activeIndex }\"\n          ></span>\n        </template>\n        <span v-if=\"navigation.type && navigation.type === 'fraction'\">\n          {{ showPageNum + '/' + state.children.length }}\n        </span>\n      </span>\n    </template>\n    <template v-else-if=\"computedNavigation !== undefined\">\n      <t-node :content=\"computedNavigation\" :style=\"{}\"></t-node>\n    </template>\n  </div>\n</template>\n<script lang=\"ts\">\nimport {\n  defineComponent,\n  reactive,\n  getCurrentInstance,\n  onMounted,\n  computed,\n  watch,\n  ref,\n  SetupContext,\n  nextTick,\n  provide,\n  ComponentInternalInstance,\n  ComponentPublicInstance,\n} from 'vue';\nimport { ChevronLeftIcon, ChevronRightIcon } from 'tdesign-icons-vue-next';\nimport { useSwipe } from '@vueuse/core';\nimport SwiperProps from './props';\nimport config from '../config';\nimport { renderTNode, useDefault, TNode } from '../shared';\nimport { TdSwiperProps } from './type';\n\nconst { prefix } = config;\nconst name = `${prefix}-swiper`;\nconst setOffset = (element: HTMLDivElement, offset: number, direction = 'X'): void => {\n  // eslint-disable-next-line no-param-reassign\n  element.style.transform = `translate${direction}(${offset}px)`;\n};\nexport default defineComponent({\n  name,\n  components: { ChevronLeftIcon, ChevronRightIcon, TNode },\n  props: SwiperProps,\n  emits: ['change', 'update:current', 'update:modelValue'],\n  setup(props, context: SetupContext) {\n    // const emitEvent = useEmitEvent(props, context.emit);\n    const [swiperValue, setSwiperValue] = useDefault<Number, TdSwiperProps>(props, context.emit, 'current', 'change');\n    const self = getCurrentInstance();\n    const swiperContainer = ref<HTMLElement | null>(null);\n    const computedNavigation = computed(() => renderTNode(self, 'navigation'));\n    // const { height = 180, current = null } = props;\n    const height = props.height || 180;\n    const state: {\n      showNavigation: boolean;\n      activeIndex: number;\n      itemLength: number;\n      itemWidth: number;\n      isControl: boolean;\n      btnDisabled: boolean;\n      children: ComponentPublicInstance[];\n    } = reactive({\n      showNavigation: true,\n      activeIndex: 0,\n      itemLength: 0,\n      itemWidth: 0,\n      isControl: false,\n      btnDisabled: false,\n      children: [] as ComponentPublicInstance[],\n    });\n    const paginationList = computed(() => new Array(state.itemLength).fill(1));\n    const showPageNum = computed(() => {\n      const { activeIndex, itemLength } = state;\n      if (activeIndex > itemLength - 1) return itemLength;\n      if (activeIndex < 0) return 1;\n      return activeIndex + 1;\n    });\n    const childCount = computed(() => state.children.length);\n    const getContainer = (): HTMLDivElement => self?.proxy?.$el.querySelector(`.${name}__container`);\n    // const getContainer = (): HTMLDivElement => swiperContainer.value as any;\n    const initSwiper = () => {\n      const _swiperContainer = getContainer();\n      _swiperContainer.querySelectorAll('.copy-item').forEach((ele) => {\n        _swiperContainer.removeChild(ele);\n      });\n      const items = _swiperContainer.querySelectorAll(`.${name}-item`);\n      state.itemLength = _swiperContainer.children?.length || 0;\n      const itemWidth = _swiperContainer.querySelector(`.${name}-item`)?.getBoundingClientRect().width || 0;\n      state.itemWidth = itemWidth;\n      if (items.length <= 0) return false;\n      if (\n        computedNavigation.value &&\n        'minShowNum' in computedNavigation.value &&\n        items.length < computedNavigation.value.minShowNum\n      ) {\n        state.showNavigation = false;\n      }\n      if (props?.loop) {\n        const first = items[0].cloneNode(true) as HTMLDivElement;\n        first.classList.add('copy-item');\n        const last = items[items.length - 1].cloneNode(true) as HTMLDivElement;\n        last.classList.add('copy-item');\n        _swiperContainer.appendChild(first);\n        _swiperContainer.insertBefore(last, items[0]);\n      }\n      move(0);\n      startAutoplay();\n      if (typeof props.current === 'number') {\n        state.isControl = true;\n        next(props.current);\n      }\n    };\n    onMounted(() => {\n      nextTick(() => {\n        console.info('swiper mounted');\n        initSwiper();\n      });\n    });\n    watch(\n      () => state.children.length,\n      () => {\n        nextTick(() => {\n          console.info('swiper mounted');\n          initSwiper();\n        });\n      },\n    );\n    // eslint-disable-next-line no-undef\n    let autoplayTimer: number | NodeJS.Timeout | null = null;\n    let actionIsTrust = true;\n    /**\n     * move item\n     */\n    const move = (targetIndex: number, isTrust = true) => {\n      const _swiperContainer = getContainer();\n      const moveDirection = props?.direction === 'horizontal' ? 'X' : 'Y';\n      const moveLength: number = props?.direction === 'vertical' ? height : state.itemWidth;\n      actionIsTrust = isTrust;\n      _swiperContainer.dataset.isTrust = `${isTrust}`;\n      // do not translate one item if not loop\n      const toIndex = props?.loop ? targetIndex + 1 : targetIndex;\n      _swiperContainer.style.transform = `translate${moveDirection}(-${moveLength * toIndex}px)`;\n    };\n    const addAnimation = () => {\n      const _swiperContainer = getContainer();\n      _swiperContainer.style.transition = `transform ${props?.duration}ms`;\n    };\n    const removeAnimation = () => {\n      const _swiperContainer = getContainer();\n      _swiperContainer.style.transition = 'none';\n    };\n    const handleAnimationEnd = () => {\n      state.btnDisabled = false;\n      removeAnimation();\n      if (state.activeIndex >= state.itemLength) {\n        state.activeIndex = 0;\n        move(0);\n      }\n      if (state.activeIndex <= -1) {\n        state.activeIndex = state.itemLength - 1;\n        move(state.itemLength - 1);\n      }\n      setTimeout(() => {\n        actionIsTrust && emitCurrentChange(state.activeIndex);\n      }, 0);\n    };\n    const stopAutoplay = () => {\n      if (!autoplayTimer) return;\n      clearInterval(autoplayTimer as number);\n      autoplayTimer = null;\n    };\n    const startAutoplay = () => {\n      if (typeof props.current === 'number') return false;\n      if (!props?.autoplay || autoplayTimer !== null) return false; // stop repeat autoplay\n      autoplayTimer = setInterval(() => {\n        state.activeIndex += 1;\n        if (!props?.loop && state.activeIndex >= state.children.length - 1) {\n          state.activeIndex = 0;\n        }\n        if (!props?.loop && state.activeIndex <= 0) {\n          state.activeIndex = state.children.length - 1;\n        }\n        addAnimation();\n        move(state.activeIndex);\n      }, props?.interval);\n    };\n    const emitCurrentChange = (index: number) => {\n      // if (!state.isControl) return false;\n      let resultIndex = index;\n      if (index >= state.itemLength) resultIndex = 0;\n      if (index < 0) resultIndex = state.itemLength - 1;\n      // emitEvent('change', resultIndex);\n      setSwiperValue(resultIndex);\n    };\n    const prev = (step = 1) => {\n      const cannotMovePrev = !props?.loop && state.activeIndex === 0;\n      if (state.btnDisabled || cannotMovePrev) {\n        move(state.activeIndex);\n        return false;\n      }\n      stopAutoplay();\n      state.activeIndex -= step;\n      addAnimation();\n      move(state.activeIndex);\n      startAutoplay();\n      state.btnDisabled = true;\n    };\n    const next = (step = 1) => {\n      const cannotMoveLast = !props?.loop && state.activeIndex === state.itemLength - 1;\n      if (state.btnDisabled || cannotMoveLast) {\n        move(state.activeIndex);\n        return false;\n      }\n      stopAutoplay();\n      state.activeIndex += step;\n      addAnimation();\n      move(state.activeIndex);\n      startAutoplay();\n      state.btnDisabled = true;\n    };\n    const { lengthX, lengthY } = useSwipe(swiperContainer, {\n      passive: false,\n      onSwipeStart(e: TouchEvent) {\n        if (state.btnDisabled) return false;\n        stopAutoplay();\n      },\n      onSwipe(e: TouchEvent) {\n        if (state.btnDisabled) return false;\n        onTouchMove(e);\n      },\n      onSwipeEnd() {\n        onTouchEnd();\n      },\n    });\n    const onTouchMove = (event: TouchEvent) => {\n      event.preventDefault();\n      const { activeIndex, itemWidth } = state;\n      const distanceX = lengthX.value;\n      const distanceY = lengthY.value;\n      const _container = getContainer();\n      removeAnimation();\n      const toIndex = props?.loop ? activeIndex + 1 : activeIndex;\n      if (props?.direction === 'horizontal') {\n        setOffset(_container, -(toIndex * itemWidth + distanceX));\n      } else {\n        const { height = 180 } = props;\n        setOffset(_container, -(toIndex * height + distanceY), 'Y');\n      }\n    };\n    const onTouchEnd = () => {\n      const distanceX = lengthX.value;\n      const distanceY = lengthY.value;\n      addAnimation();\n      if (\n        (props?.direction === 'horizontal' && distanceX < -100) ||\n        (props?.direction === 'vertical' && distanceY < -100)\n      ) {\n        prev(1);\n      } else if (\n        (props?.direction === 'horizontal' && distanceX > 100) ||\n        (props?.direction === 'vertical' && distanceY > 100)\n      ) {\n        next(1);\n      } else {\n        move(state.activeIndex);\n      }\n      startAutoplay();\n    };\n    const relation = (child: ComponentInternalInstance) => {\n      if (child.proxy) {\n        state.children.push(child.proxy);\n      }\n    };\n    provide('parent', {\n      props,\n      relation,\n    });\n    watch(\n      () => props.current,\n      (newPage, oldPage) => {\n        if (state.isControl) {\n          state.activeIndex = newPage || 0;\n          addAnimation();\n          move(state.activeIndex, false);\n        }\n      },\n    );\n    return {\n      swiperContainer,\n      name,\n      computedNavigation,\n      onTouchMove,\n      onTouchEnd,\n      handleAnimationEnd,\n      state,\n      paginationList,\n      showPageNum,\n      prev,\n      next,\n    };\n  },\n});\n</script>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}