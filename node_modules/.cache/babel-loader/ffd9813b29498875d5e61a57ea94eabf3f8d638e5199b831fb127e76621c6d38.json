{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * tdesign v0.14.1\n * (c) 2022 TDesign Group\n * @license MIT\n */\n\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport _slicedToArray from '@babel/runtime/helpers/slicedToArray';\nimport { defineComponent, reactive, ref, getCurrentInstance, computed, watch, toRefs, resolveComponent, openBlock, createBlock, normalizeClass, withCtx, createElementBlock, Fragment, createElementVNode, createCommentVNode, createVNode, renderList, normalizeStyle } from 'vue';\nimport { CloseCircleFilledIcon } from 'tdesign-icons-vue-next';\nimport config from '../config.js';\nimport ImageViewerProps from './props.js';\nimport '../shared/index.js';\nimport { Swiper, SwiperItem } from '../swiper/index.js';\nimport Overlay from '../overlay/index.js';\nimport TNodeComponent from '../shared/render-tnode.js';\nimport { useEmitEvent } from '../shared/useEmitEvent/index.js';\nimport { useDefault } from '../shared/useDefault/index.js';\nimport { useTouch } from '../shared/useTouch/index.js';\nimport { renderTNode } from '../shared/render.js';\nimport '../shared/functions.js';\nimport '../shared/util.js';\nimport '../shared/component.js';\nimport '../shared/constants.js';\nimport '../shared/useToggle/index.js';\nimport '../shared/useCountDown/index.js';\nimport '@babel/runtime/helpers/asyncToGenerator';\nimport '@babel/runtime/regenerator';\nimport '@vueuse/core';\nimport '../shared/useCountDown/utils.js';\nimport '../shared/useChildSlots/index.js';\nimport '@babel/runtime/helpers/toConsumableArray';\nimport '../shared/useVModel/index.js';\nimport '../shared/useScrollParent/index.js';\nimport '../shared/useExpose/index.js';\nimport '../shared/useTest/index.js';\nimport '@babel/runtime/helpers/typeof';\nimport 'lodash/camelCase';\nimport '../swiper/swiper.js';\nimport '../swiper/props.js';\nimport '../swiper/swiper-item.js';\nimport './style/css.js';\nimport '../swiper/type.js';\nimport '../overlay/overlay.js';\nimport '../overlay/props.js';\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n  return keys;\n}\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n  return target;\n}\nvar prefix = config.prefix;\nvar name = \"\".concat(prefix, \"-image-viewer\");\nvar getDistance = function getDistance(touches) {\n  return Math.sqrt(Math.pow(touches[0].clientX - touches[1].clientX, 2) + Math.pow(touches[0].clientY - touches[1].clientY, 2));\n};\nvar script = defineComponent({\n  name: name,\n  components: {\n    CloseCircleFilledIcon: CloseCircleFilledIcon,\n    TSwiper: Swiper,\n    TSwiperItem: SwiperItem,\n    TOverlay: Overlay,\n    TNode: TNodeComponent\n  },\n  props: ImageViewerProps,\n  emits: [\"close\", \"index-change\", \"update:visible\", \"update:modelValue\", \"change\"],\n  setup: function setup(props, context) {\n    var state = reactive({\n      zooming: false,\n      scale: 1\n    });\n    var emitEvent = useEmitEvent(props, context.emit);\n    var _useDefault = useDefault(props, context.emit, \"visible\", \"change\"),\n      _useDefault2 = _slicedToArray(_useDefault, 2),\n      visible = _useDefault2[0],\n      setVisible = _useDefault2[1];\n    var lazyVisible = ref(visible.value);\n    var touch = useTouch();\n    var internalInstance = getCurrentInstance();\n    var closeBtnTNode = computed(function () {\n      return renderTNode(internalInstance, \"closeBtn\");\n    });\n    var navigation = computed(function () {\n      if (props.showIndex) {\n        return {\n          type: \"fraction\"\n        };\n      }\n      return {\n        type: \"dots\",\n        showSlideBtn: false\n      };\n    });\n    var imageStyle = computed(function () {\n      var scale = state.scale,\n        zooming = state.zooming;\n      var style = {\n        transitionDuration: zooming ? \"0s\" : \".3s\"\n      };\n      if (scale !== 1) {\n        style.transform = \"scale(\".concat(scale, \", \").concat(scale, \")\");\n      }\n      return style;\n    });\n    var handleClose = function handleClose(e, trigger) {\n      setVisible(false);\n      emitEvent(\"close\", {\n        trigger: trigger,\n        e: e\n      });\n    };\n    var onSwiperChange = function onSwiperChange(index, context2) {\n      emitEvent(\"index-change\", index);\n    };\n    var fingerNum;\n    var startScale;\n    var startDistance;\n    var doubleTapTimer;\n    var touchStartTime;\n    var onTouchStart = function onTouchStart(event) {\n      event.preventDefault();\n      event.stopPropagation();\n      var touches = event.touches;\n      touch.start(event);\n      fingerNum = touches.length;\n      touchStartTime = Date.now();\n      state.zooming = fingerNum === 2;\n      if (state.zooming) {\n        startScale = state.scale;\n        startDistance = getDistance(event.touches);\n      }\n    };\n    var onTouchMove = function onTouchMove(event) {\n      var touches = event.touches;\n      touch.move(event);\n      event.preventDefault();\n      event.stopPropagation();\n      if (state.zooming) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      if (state.zooming && touches.length === 2) {\n        var distance = getDistance(touches);\n        var scale = startScale * distance / startDistance;\n        setScale(scale);\n      }\n    };\n    var setScale = function setScale(scale) {\n      scale = Math.min(scale, +props.maxZoom + 1);\n      if (scale !== state.scale) {\n        state.scale = scale;\n      }\n    };\n    var resetScale = function resetScale() {\n      setScale(1);\n    };\n    var toggleScale = function toggleScale() {\n      var scale = state.scale > 1 ? 1 : 2;\n      setScale(scale);\n    };\n    var checkTap = function checkTap(event) {\n      if (fingerNum > 1) {\n        return;\n      }\n      var offsetX = touch.offsetX,\n        offsetY = touch.offsetY;\n      var deltaTime = Date.now() - touchStartTime;\n      var TAP_TIME = 250;\n      var TAP_OFFSET = 5;\n      if (offsetX.value < TAP_OFFSET && offsetY.value < TAP_OFFSET && deltaTime < TAP_TIME) {\n        if (doubleTapTimer) {\n          clearTimeout(doubleTapTimer);\n          doubleTapTimer = null;\n          toggleScale();\n        } else {\n          doubleTapTimer = window.setTimeout(function () {\n            handleClose(event, \"overlay\");\n            doubleTapTimer = null;\n          }, TAP_TIME);\n        }\n      }\n    };\n    var onTouchEnd = function onTouchEnd(event) {\n      event.preventDefault();\n      if (state.zooming) {\n        event.stopPropagation();\n        if (!event.touches.length) {\n          if (state.zooming) {\n            state.zooming = false;\n          }\n          startScale = 1;\n          if (state.scale < 1) {\n            resetScale();\n          }\n          if (state.scale > props.maxZoom) {\n            state.scale = +props.maxZoom;\n          }\n        }\n      }\n      checkTap(event);\n      touch.reset();\n    };\n    watch(function () {\n      return visible.value;\n    }, function (value) {\n      if (!value) {\n        resetScale();\n      }\n      setTimeout(function () {\n        lazyVisible.value = value;\n      }, 300);\n    });\n    return _objectSpread(_objectSpread({\n      name: name,\n      prefix: prefix,\n      closeBtnTNode: closeBtnTNode,\n      navigation: navigation,\n      imageStyle: imageStyle,\n      lazyVisible: lazyVisible\n    }, toRefs(props)), {}, {\n      visible: visible,\n      handleClose: handleClose,\n      onSwiperChange: onSwiperChange,\n      onTouchStart: onTouchStart,\n      onTouchMove: onTouchMove,\n      onTouchEnd: onTouchEnd\n    });\n  }\n});\nvar _hoisted_1 = [\"src\"];\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_t_node = resolveComponent(\"t-node\");\n  var _component_close_circle_filled_icon = resolveComponent(\"close-circle-filled-icon\");\n  var _component_t_swiper_item = resolveComponent(\"t-swiper-item\");\n  var _component_t_swiper = resolveComponent(\"t-swiper\");\n  var _component_t_overlay = resolveComponent(\"t-overlay\");\n  return openBlock(), createBlock(_component_t_overlay, {\n    class: normalizeClass(\"\".concat(_ctx.prefix, \"-image-viewer\")),\n    visible: _ctx.visible\n  }, {\n    default: withCtx(function () {\n      return [_ctx.lazyVisible ? (openBlock(), createElementBlock(Fragment, {\n        key: 0\n      }, [createElementVNode(\"div\", {\n        class: normalizeClass(\"\".concat(_ctx.name, \"__close-icon\")),\n        onClick: _cache[0] || (_cache[0] = function ($event) {\n          return _ctx.handleClose($event, \"close-btn\");\n        })\n      }, [!(typeof _ctx.closeBtnTNode === \"boolean\") ? (openBlock(), createBlock(_component_t_node, {\n        key: 0,\n        content: _ctx.closeBtnTNode\n      }, null, 8, [\"content\"])) : typeof _ctx.closeBtn === \"boolean\" && _ctx.closeBtn ? (openBlock(), createBlock(_component_close_circle_filled_icon, {\n        key: 1\n      })) : createCommentVNode(\"\", true)], 2), createVNode(_component_t_swiper, {\n        autoplay: false,\n        class: normalizeClass(\"\".concat(_ctx.name, \"__swipe\")),\n        \"default-current\": _ctx.initialIndex,\n        navigation: _ctx.navigation,\n        \"on-change\": _ctx.onSwiperChange\n      }, {\n        default: withCtx(function () {\n          return [(openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.images, function (image, index) {\n            return openBlock(), createBlock(_component_t_swiper_item, {\n              key: image + index,\n              class: normalizeClass(\"\".concat(_ctx.name, \"__swipe-item\")),\n              onTouchstart: _ctx.onTouchStart,\n              onTouchmove: _ctx.onTouchMove,\n              onTouchend: _ctx.onTouchEnd\n            }, {\n              default: withCtx(function () {\n                return [createElementVNode(\"img\", {\n                  src: image,\n                  style: normalizeStyle(_ctx.imageStyle),\n                  class: normalizeClass(\"\".concat(_ctx.name, \"__image\"))\n                }, null, 14, _hoisted_1)];\n              }),\n              _: 2\n            }, 1032, [\"class\", \"onTouchstart\", \"onTouchmove\", \"onTouchend\"]);\n          }), 128))];\n        }),\n        _: 1\n      }, 8, [\"class\", \"default-current\", \"navigation\", \"on-change\"])], 64)) : createCommentVNode(\"\", true)];\n    }),\n    _: 1\n  }, 8, [\"class\", \"visible\"]);\n}\nscript.render = render;\nexport { script as default };","map":{"version":3,"mappings":"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","names":["prefix","config","name","getDistance","touches","Math","sqrt","clientX","clientY","defineComponent","components","CloseCircleFilledIcon","TSwiper","TSwiperItem","TOverlay","TNode","props","emits","setup","context","state","reactive","zooming","scale","emitEvent","emit","useDefault","_useDefault2","visible","setVisible","ref","value","touch","useTouch","internalInstance","getCurrentInstance","computed","showIndex","type","showSlideBtn","style","transitionDuration","handleClose","e","trigger","onSwiperChange","index","onTouchStart","event","preventDefault","stopPropagation","start","fingerNum","touchStartTime","Date","now","startScale","startDistance","onTouchMove","move","distance","setScale","min","maxZoom","resetScale","toggleScale","checkTap","offsetX","offsetY","TAP_TIME","TAP_OFFSET","deltaTime","doubleTapTimer","clearTimeout","setTimeout","onTouchEnd","length","reset","watch","lazyVisible","closeBtnTNode","navigation","imageStyle","toRefs","_component_t_overlay","class","_ctx","_createElementBlock","_Fragment","key","_createElementVNode","onClick","_cache","$event","_createBlock","_component_t_node","content","closeBtn","_createVNode","_component_t_swiper","autoplay","_openBlock","_component_t_swiper_item","image","onTouchstart","onTouchmove","onTouchend","src"],"sources":["../../src/image-viewer/image-viewer.vue","../../src/image-viewer/image-viewer.vue?vue&type=template&id=e7d34ef8&lang.js"],"sourcesContent":["<template>\n  <t-overlay :class=\"`${prefix}-image-viewer`\" :visible=\"visible\">\n    <template v-if=\"lazyVisible\">\n      <div :class=\"`${name}__close-icon`\" @click=\"handleClose($event, 'close-btn')\">\n        <t-node v-if=\"!(typeof closeBtnTNode === 'boolean')\" :content=\"closeBtnTNode\"></t-node>\n        <close-circle-filled-icon v-else-if=\"typeof closeBtn === 'boolean' && closeBtn\" />\n      </div>\n      <t-swiper\n        :autoplay=\"false\"\n        :class=\"`${name}__swipe`\"\n        :default-current=\"initialIndex\"\n        :navigation=\"navigation\"\n        :on-change=\"onSwiperChange\"\n      >\n        <t-swiper-item\n          v-for=\"(image, index) in images\"\n          :key=\"image + index\"\n          :class=\"`${name}__swipe-item`\"\n          @touchstart=\"onTouchStart\"\n          @touchmove=\"onTouchMove\"\n          @touchend=\"onTouchEnd\"\n        >\n          <img :src=\"image\" :style=\"imageStyle\" :class=\"`${name}__image`\" />\n        </t-swiper-item>\n      </t-swiper>\n    </template>\n  </t-overlay>\n</template>\n\n<script lang=\"ts\">\nimport {\n  computed,\n  toRefs,\n  ref,\n  defineComponent,\n  reactive,\n  watch,\n  getCurrentInstance,\n  CSSProperties,\n  SetupContext,\n} from 'vue';\nimport { CloseCircleFilledIcon } from 'tdesign-icons-vue-next';\nimport config from '../config';\nimport ImageViewerProps from './props';\nimport { renderTNode, TNode, useEmitEvent, useDefault, useTouch } from '../shared';\nimport { TdImageViewerProps } from './type';\nimport { Swiper as TSwiper, SwiperItem as TSwiperItem, SwiperNavigation } from '../swiper';\nimport TOverlay from '../overlay';\n\nexport type TriggerType = 'close-btn' | 'overlay' | 'esc';\nconst { prefix } = config;\nconst name = `${prefix}-image-viewer`;\n\n/*\ninitialIndex, 因 swiper 不支持 defaultCurrent\n\n\nonIndexChange, 因 swiper 未提供 'prev' | 'next'， 所以没有 context\n*/\nconst getDistance = (touches: TouchList) =>\n  Math.sqrt((touches[0].clientX - touches[1].clientX) ** 2 + (touches[0].clientY - touches[1].clientY) ** 2);\n\nexport default defineComponent({\n  name,\n  components: {\n    CloseCircleFilledIcon,\n    TSwiper,\n    TSwiperItem,\n    TOverlay,\n    TNode,\n  },\n  props: ImageViewerProps,\n  emits: ['close', 'index-change', 'update:visible', 'update:modelValue', 'change'],\n  setup(props, context: SetupContext) {\n    const state = reactive({\n      zooming: false,\n      scale: 1,\n    });\n    const emitEvent = useEmitEvent(props, context.emit);\n    const [visible, setVisible] = useDefault<TdImageViewerProps['visible'], TdImageViewerProps>(\n      props,\n      context.emit,\n      'visible',\n      'change',\n    );\n    // 因 Overlay 未提供lazy属性，先暂时自行实现\n    const lazyVisible = ref(visible.value);\n    const touch = useTouch();\n    const internalInstance = getCurrentInstance();\n    const closeBtnTNode = computed(() => {\n      return renderTNode(internalInstance, 'closeBtn');\n    });\n    const navigation = computed<SwiperNavigation>(() => {\n      if (props.showIndex) {\n        return { type: 'fraction' };\n      }\n      return { type: 'dots', showSlideBtn: false };\n    });\n\n    const imageStyle = computed(() => {\n      const { scale, zooming } = state;\n      const style: CSSProperties = {\n        transitionDuration: zooming ? '0s' : '.3s',\n      };\n\n      if (scale !== 1) {\n        style.transform = `scale(${scale}, ${scale})`;\n      }\n\n      return style;\n    });\n\n    const handleClose = (e: Event, trigger: TriggerType) => {\n      setVisible(false);\n      emitEvent('close', { trigger, e });\n    };\n\n    const onSwiperChange = (index: number, context: any) => {\n      emitEvent('index-change', index);\n    };\n\n    let fingerNum: number;\n    let startScale: number;\n    let startDistance: number;\n    let doubleTapTimer: number | null;\n    let touchStartTime: number;\n    const onTouchStart = (event: TouchEvent) => {\n      event.preventDefault();\n      event.stopPropagation();\n      const { touches } = event;\n\n      touch.start(event);\n\n      fingerNum = touches.length;\n      touchStartTime = Date.now();\n      state.zooming = fingerNum === 2;\n      if (state.zooming) {\n        startScale = state.scale;\n        startDistance = getDistance(event.touches);\n      }\n    };\n\n    const onTouchMove = (event: TouchEvent) => {\n      const { touches } = event;\n\n      touch.move(event);\n      event.preventDefault();\n      event.stopPropagation();\n      if (state.zooming) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      if (state.zooming && touches.length === 2) {\n        const distance = getDistance(touches);\n        const scale = (startScale * distance) / startDistance;\n\n        setScale(scale);\n      }\n    };\n\n    const setScale = (scale: number) => {\n      scale = Math.min(scale, +props.maxZoom + 1);\n\n      if (scale !== state.scale) {\n        state.scale = scale;\n      }\n    };\n    const resetScale = () => {\n      setScale(1);\n    };\n\n    const toggleScale = () => {\n      const scale = state.scale > 1 ? 1 : 2;\n\n      setScale(scale);\n    };\n\n    const checkTap = (event: Event) => {\n      if (fingerNum > 1) {\n        return;\n      }\n\n      const { offsetX, offsetY } = touch;\n      const deltaTime = Date.now() - touchStartTime;\n      const TAP_TIME = 250;\n      const TAP_OFFSET = 5;\n\n      if (offsetX.value < TAP_OFFSET && offsetY.value < TAP_OFFSET && deltaTime < TAP_TIME) {\n        if (doubleTapTimer) {\n          clearTimeout(doubleTapTimer);\n          doubleTapTimer = null;\n          toggleScale();\n        } else {\n          doubleTapTimer = window.setTimeout(() => {\n            handleClose(event, 'overlay');\n            doubleTapTimer = null;\n          }, TAP_TIME);\n        }\n      }\n    };\n\n    const onTouchEnd = (event: TouchEvent) => {\n      // eliminate tap delay on safari\n      event.preventDefault();\n\n      if (state.zooming) {\n        event.stopPropagation();\n        if (!event.touches.length) {\n          if (state.zooming) {\n            state.zooming = false;\n          }\n          startScale = 1;\n          if (state.scale < 1) {\n            resetScale();\n          }\n          if (state.scale > props.maxZoom) {\n            state.scale = +props.maxZoom;\n          }\n        }\n      }\n\n      checkTap(event);\n      touch.reset();\n    };\n\n    watch(\n      () => visible.value,\n      (value) => {\n        if (!value) {\n          resetScale();\n        }\n        setTimeout(() => {\n          lazyVisible.value = value;\n        }, 300);\n      },\n    );\n    return {\n      name,\n      prefix,\n      closeBtnTNode,\n      navigation,\n      imageStyle,\n      lazyVisible,\n      ...toRefs(props),\n      visible,\n      handleClose,\n      onSwiperChange,\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd,\n    };\n  },\n});\n</script>\n","<template>\n  <t-overlay :class=\"`${prefix}-image-viewer`\" :visible=\"visible\">\n    <template v-if=\"lazyVisible\">\n      <div :class=\"`${name}__close-icon`\" @click=\"handleClose($event, 'close-btn')\">\n        <t-node v-if=\"!(typeof closeBtnTNode === 'boolean')\" :content=\"closeBtnTNode\"></t-node>\n        <close-circle-filled-icon v-else-if=\"typeof closeBtn === 'boolean' && closeBtn\" />\n      </div>\n      <t-swiper\n        :autoplay=\"false\"\n        :class=\"`${name}__swipe`\"\n        :default-current=\"initialIndex\"\n        :navigation=\"navigation\"\n        :on-change=\"onSwiperChange\"\n      >\n        <t-swiper-item\n          v-for=\"(image, index) in images\"\n          :key=\"image + index\"\n          :class=\"`${name}__swipe-item`\"\n          @touchstart=\"onTouchStart\"\n          @touchmove=\"onTouchMove\"\n          @touchend=\"onTouchEnd\"\n        >\n          <img :src=\"image\" :style=\"imageStyle\" :class=\"`${name}__image`\" />\n        </t-swiper-item>\n      </t-swiper>\n    </template>\n  </t-overlay>\n</template>\n\n<script lang=\"ts\">\nimport {\n  computed,\n  toRefs,\n  ref,\n  defineComponent,\n  reactive,\n  watch,\n  getCurrentInstance,\n  CSSProperties,\n  SetupContext,\n} from 'vue';\nimport { CloseCircleFilledIcon } from 'tdesign-icons-vue-next';\nimport config from '../config';\nimport ImageViewerProps from './props';\nimport { renderTNode, TNode, useEmitEvent, useDefault, useTouch } from '../shared';\nimport { TdImageViewerProps } from './type';\nimport { Swiper as TSwiper, SwiperItem as TSwiperItem, SwiperNavigation } from '../swiper';\nimport TOverlay from '../overlay';\n\nexport type TriggerType = 'close-btn' | 'overlay' | 'esc';\nconst { prefix } = config;\nconst name = `${prefix}-image-viewer`;\n\n/*\ninitialIndex, 因 swiper 不支持 defaultCurrent\n\n\nonIndexChange, 因 swiper 未提供 'prev' | 'next'， 所以没有 context\n*/\nconst getDistance = (touches: TouchList) =>\n  Math.sqrt((touches[0].clientX - touches[1].clientX) ** 2 + (touches[0].clientY - touches[1].clientY) ** 2);\n\nexport default defineComponent({\n  name,\n  components: {\n    CloseCircleFilledIcon,\n    TSwiper,\n    TSwiperItem,\n    TOverlay,\n    TNode,\n  },\n  props: ImageViewerProps,\n  emits: ['close', 'index-change', 'update:visible', 'update:modelValue', 'change'],\n  setup(props, context: SetupContext) {\n    const state = reactive({\n      zooming: false,\n      scale: 1,\n    });\n    const emitEvent = useEmitEvent(props, context.emit);\n    const [visible, setVisible] = useDefault<TdImageViewerProps['visible'], TdImageViewerProps>(\n      props,\n      context.emit,\n      'visible',\n      'change',\n    );\n    // 因 Overlay 未提供lazy属性，先暂时自行实现\n    const lazyVisible = ref(visible.value);\n    const touch = useTouch();\n    const internalInstance = getCurrentInstance();\n    const closeBtnTNode = computed(() => {\n      return renderTNode(internalInstance, 'closeBtn');\n    });\n    const navigation = computed<SwiperNavigation>(() => {\n      if (props.showIndex) {\n        return { type: 'fraction' };\n      }\n      return { type: 'dots', showSlideBtn: false };\n    });\n\n    const imageStyle = computed(() => {\n      const { scale, zooming } = state;\n      const style: CSSProperties = {\n        transitionDuration: zooming ? '0s' : '.3s',\n      };\n\n      if (scale !== 1) {\n        style.transform = `scale(${scale}, ${scale})`;\n      }\n\n      return style;\n    });\n\n    const handleClose = (e: Event, trigger: TriggerType) => {\n      setVisible(false);\n      emitEvent('close', { trigger, e });\n    };\n\n    const onSwiperChange = (index: number, context: any) => {\n      emitEvent('index-change', index);\n    };\n\n    let fingerNum: number;\n    let startScale: number;\n    let startDistance: number;\n    let doubleTapTimer: number | null;\n    let touchStartTime: number;\n    const onTouchStart = (event: TouchEvent) => {\n      event.preventDefault();\n      event.stopPropagation();\n      const { touches } = event;\n\n      touch.start(event);\n\n      fingerNum = touches.length;\n      touchStartTime = Date.now();\n      state.zooming = fingerNum === 2;\n      if (state.zooming) {\n        startScale = state.scale;\n        startDistance = getDistance(event.touches);\n      }\n    };\n\n    const onTouchMove = (event: TouchEvent) => {\n      const { touches } = event;\n\n      touch.move(event);\n      event.preventDefault();\n      event.stopPropagation();\n      if (state.zooming) {\n        event.preventDefault();\n        event.stopPropagation();\n      }\n      if (state.zooming && touches.length === 2) {\n        const distance = getDistance(touches);\n        const scale = (startScale * distance) / startDistance;\n\n        setScale(scale);\n      }\n    };\n\n    const setScale = (scale: number) => {\n      scale = Math.min(scale, +props.maxZoom + 1);\n\n      if (scale !== state.scale) {\n        state.scale = scale;\n      }\n    };\n    const resetScale = () => {\n      setScale(1);\n    };\n\n    const toggleScale = () => {\n      const scale = state.scale > 1 ? 1 : 2;\n\n      setScale(scale);\n    };\n\n    const checkTap = (event: Event) => {\n      if (fingerNum > 1) {\n        return;\n      }\n\n      const { offsetX, offsetY } = touch;\n      const deltaTime = Date.now() - touchStartTime;\n      const TAP_TIME = 250;\n      const TAP_OFFSET = 5;\n\n      if (offsetX.value < TAP_OFFSET && offsetY.value < TAP_OFFSET && deltaTime < TAP_TIME) {\n        if (doubleTapTimer) {\n          clearTimeout(doubleTapTimer);\n          doubleTapTimer = null;\n          toggleScale();\n        } else {\n          doubleTapTimer = window.setTimeout(() => {\n            handleClose(event, 'overlay');\n            doubleTapTimer = null;\n          }, TAP_TIME);\n        }\n      }\n    };\n\n    const onTouchEnd = (event: TouchEvent) => {\n      // eliminate tap delay on safari\n      event.preventDefault();\n\n      if (state.zooming) {\n        event.stopPropagation();\n        if (!event.touches.length) {\n          if (state.zooming) {\n            state.zooming = false;\n          }\n          startScale = 1;\n          if (state.scale < 1) {\n            resetScale();\n          }\n          if (state.scale > props.maxZoom) {\n            state.scale = +props.maxZoom;\n          }\n        }\n      }\n\n      checkTap(event);\n      touch.reset();\n    };\n\n    watch(\n      () => visible.value,\n      (value) => {\n        if (!value) {\n          resetScale();\n        }\n        setTimeout(() => {\n          lazyVisible.value = value;\n        }, 300);\n      },\n    );\n    return {\n      name,\n      prefix,\n      closeBtnTNode,\n      navigation,\n      imageStyle,\n      lazyVisible,\n      ...toRefs(props),\n      visible,\n      handleClose,\n      onSwiperChange,\n      onTouchStart,\n      onTouchMove,\n      onTouchEnd,\n    };\n  },\n});\n</script>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}