{"ast":null,"code":"/**\n * tdesign v0.14.1\n * (c) 2022 TDesign Group\n * @license MIT\n */\n\nimport { defineComponent, computed, getCurrentInstance, ref, watch, resolveComponent, openBlock, createElementBlock, normalizeClass, normalizeStyle, createElementVNode, createVNode } from 'vue';\nimport { templateRef, useElementBounding } from '@vueuse/core';\nimport props from './props.js';\nimport config from '../config.js';\nimport '../shared/index.js';\nimport TNodeComponent from '../shared/render-tnode.js';\nimport { renderContent } from '../shared/render.js';\nimport { useEmitEvent } from '../shared/useEmitEvent/index.js';\nimport '../shared/functions.js';\nimport '../shared/util.js';\nimport '../shared/component.js';\nimport '../shared/constants.js';\nimport '../shared/useToggle/index.js';\nimport '../shared/useCountDown/index.js';\nimport '@babel/runtime/helpers/asyncToGenerator';\nimport '@babel/runtime/regenerator';\nimport '../shared/useCountDown/utils.js';\nimport '../shared/useDefault/index.js';\nimport 'lodash/camelCase';\nimport '../shared/useChildSlots/index.js';\nimport '@babel/runtime/helpers/toConsumableArray';\nimport '../shared/useVModel/index.js';\nimport '../shared/useTouch/index.js';\nimport '../shared/useScrollParent/index.js';\nimport '../shared/useExpose/index.js';\nimport '../shared/useTest/index.js';\nimport '@babel/runtime/helpers/defineProperty';\nimport '@babel/runtime/helpers/typeof';\nvar name = \"\".concat(config.prefix, \"-sticky\");\nvar script = defineComponent({\n  name: name,\n  components: {\n    TNode: TNodeComponent\n  },\n  props: props,\n  setup: function setup(props2, context) {\n    var boxClasses = name;\n    var stickyContent = computed(function () {\n      return renderContent(getCurrentInstance(), \"default\", \"\");\n    });\n    var emitEvent = useEmitEvent(props2, context.emit);\n    var boxRef = templateRef(\"boxRef\");\n    var _useElementBounding = useElementBounding(boxRef),\n      boxTop = _useElementBounding.top;\n    var contentRef = templateRef(\"contentRef\");\n    var _useElementBounding2 = useElementBounding(contentRef),\n      contentTop = _useElementBounding2.top,\n      height = _useElementBounding2.height;\n    var boxStyles = computed(function () {\n      return \"height:\".concat(height.value, \"px;\");\n    });\n    var container;\n    var containerHeight = ref(0);\n    var containerTop = ref(0);\n    watch(boxTop, function () {\n      if (props2.container) {\n        container = document.querySelector(props2.container);\n        var _container$getBoundin = container.getBoundingClientRect(),\n          top = _container$getBoundin.top,\n          height2 = _container$getBoundin.height;\n        containerHeight.value = height2;\n        containerTop.value = top;\n      }\n    });\n    var contentStyles = computed(function () {\n      var styleStr = \"z-index:\".concat(props2.zIndex, \";\");\n      var isFixed = false;\n      if (props2.disabled) return styleStr;\n      var offsetTop = Number(props2.offsetTop);\n      if (container) {\n        if (containerHeight.value + containerTop.value < offsetTop + height.value) {\n          styleStr += \"transform:translate3d(0, \".concat(containerHeight.value - height.value, \"px, 0);\");\n        } else if (boxTop.value <= offsetTop) {\n          styleStr += \"position:fixed;top:\".concat(offsetTop, \"px;\");\n          isFixed = true;\n        }\n      } else if (boxTop.value <= offsetTop) {\n        styleStr += \"position:fixed;top:\".concat(offsetTop, \"px;\");\n        isFixed = true;\n      }\n      emitEvent(\"scroll\", {\n        scrollTop: contentTop.value,\n        isFixed: isFixed\n      });\n      return styleStr;\n    });\n    return {\n      boxClasses: boxClasses,\n      boxStyles: boxStyles,\n      contentStyles: contentStyles,\n      stickyContent: stickyContent\n    };\n  }\n});\nfunction render(_ctx, _cache, $props, $setup, $data, $options) {\n  var _component_t_node = resolveComponent(\"t-node\");\n  return openBlock(), createElementBlock(\"div\", {\n    ref: \"boxRef\",\n    class: normalizeClass(_ctx.boxClasses),\n    style: normalizeStyle(_ctx.boxStyles)\n  }, [createElementVNode(\"div\", {\n    ref: \"contentRef\",\n    class: normalizeClass(\"\".concat(_ctx.boxClasses, \"__content\")),\n    style: normalizeStyle(_ctx.contentStyles)\n  }, [createVNode(_component_t_node, {\n    content: _ctx.stickyContent\n  }, null, 8, [\"content\"])], 6)], 6);\n}\nscript.render = render;\nexport { script as default };","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeA,IAAMA,iBAAUC,MAAO;AAEvB,aAAeC,eAAgB;EAC7BF;EACAG,YAAY;IAAEC,KAAM,EAANA;GAAM;EACpBC;EACAC,OAAMD,uBAAOE,OAAS;IACpB,IAAMC,UAAa;IACb,oBAAgBC,SAAS;MAAA,OAAMC,cAAcC,oBAAsB,aAAW,EAAE,CAAC;KAAA;IACvF,IAAMC,SAAY,gBAAaP,MAAO,UAAQQ,IAAI;IAI5C,aAASC,YAAY,QAAQ;IACnC,IAAwBC,yCAAmBC,MAAM;MAApCC,MAAO,uBAAZC;IACF,iBAAaJ,YAAY,YAAY;IAC3C,IAAoCC,0CAAmBI,UAAU;MAApDC,kCAALF,GAAK;MAAYG,MAAO,wBAAPA,MAAO;IAEhC,IAAMC,SAAY,YAAS;MAAA,OAAgBD,wBAAOE,KAAU;IAAA;IAGxD;IACE,sBAAkBC,IAAI,CAAC;IACvB,mBAAeA,IAAI,CAAC;IAG1BC,MAAMR,QAAQ,YAAM;MAClB,IAAIZ,OAAMqB,SAAW;QAEPA,qBAASC,aAActB,QAAMqB,SAAS;QAClD,IAAwBA,kCAAUE,qBAAsB;UAAhDV,GAAK,yBAALA,GAAK;UAAAG,OAAO,yBAAPA;QACbQ,gBAAgBN,KAAQF;QACxBS,aAAaP,KAAQ;MACvB;IACF,CAAC;IAGK,oBAAgBd,SAAS,YAAM;MAC/B,iCAAsBJ,MAAM;MAChC,IAAI0B,OAAU;MACd,IAAI1B,MAAM,WAAiB;MACrB,gBAAY2B,MAAO3B,QAAM4B,SAAS;MACxC,IAAIP,SAAW;QACb,IAAIG,gBAAgBN,KAAQ,gBAAaA,KAAQ,eAAYF,OAAOE,KAAO;UAC7DW,+CAA4BL,eAAgB,SAAQR,MAAO;QACzE,WAAWJ,MAAO,UAASgB,SAAW;UACpCC,yCAAkCD;UACxBF;QACZ;MACF,WAAWd,MAAO,UAASgB,SAAW;QACpCC,yCAAkCD;QACxBF;MACZ;MACAnB,UAAU,UAAU;QAAEuB,WAAWf,UAAW;QAAOW;MAAQ,CAAC;MACrD;IACT,CAAC;IAEM;MACLvB;MACAc;MACAc;MACAC;KACF;EACF;AACF,CAAC;;;oBC9EC,qBAIK;IAJAb,GAAI;IAAUc,qBAAO,MAAU9B;IAAG+B,qBAAO,MAASjB;MACrDkB,mBAEK;IAFAhB,GAAI;IAAcc,gCAAUG,KAAUjC;IAAc+B,qBAAO,MAAaH;MAC3EM,YAAyCC;IAAhCC,OAAS,OAAaP;EAAA","names":["name","config","defineComponent","components","TNode","props","setup","context","boxClasses","computed","renderContent","getCurrentInstance","emitEvent","emit","templateRef","useElementBounding","boxRef","boxTop","top","contentRef","contentTop","height","boxStyles","value","ref","watch","container","querySelector","getBoundingClientRect","containerHeight","containerTop","isFixed","Number","offsetTop","styleStr","scrollTop","contentStyles","stickyContent","class","style","_createElementVNode","_ctx","_createVNode","_component_t_node","content"],"sources":["../../src/sticky/sticky.vue","../../src/sticky/sticky.vue?vue&type=template&id=05741920&lang.js"],"sourcesContent":["<template>\n  <div ref=\"boxRef\" :class=\"boxClasses\" :style=\"boxStyles\">\n    <div ref=\"contentRef\" :class=\"`${boxClasses}__content`\" :style=\"contentStyles\">\n      <t-node :content=\"stickyContent\"></t-node>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { computed, getCurrentInstance, defineComponent, ref, watch } from 'vue';\nimport { useElementBounding, templateRef } from '@vueuse/core';\nimport props from './props';\nimport config from '../config';\nimport { renderContent, useEmitEvent, TNode } from '../shared';\n\nconst name = `${config.prefix}-sticky`;\n\nexport default defineComponent({\n  name,\n  components: { TNode },\n  props,\n  setup(props, context) {\n    const boxClasses = name;\n    const stickyContent = computed(() => renderContent(getCurrentInstance(), 'default', ''));\n    const emitEvent = useEmitEvent(props, context.emit);\n\n    // box 用于占位和记录边界\n    // content 用于实际定位\n    const boxRef = templateRef('boxRef');\n    const { top: boxTop } = useElementBounding(boxRef);\n    const contentRef = templateRef('contentRef');\n    const { top: contentTop, height } = useElementBounding(contentRef);\n\n    const boxStyles = computed(() => `height:${height.value}px;`);\n\n    // container 容器，sticky不会超出该边界\n    let container: HTMLElement;\n    const containerHeight = ref(0);\n    const containerTop = ref(0);\n\n    // 监听页面滚动事件\n    watch(boxTop, () => {\n      if (props.container) {\n        // @ts-ignore\n        container = document.querySelector(props.container);\n        const { top, height } = container.getBoundingClientRect();\n        containerHeight.value = height;\n        containerTop.value = top;\n      }\n    });\n\n    // 通过改变 content 的定位来实现 sticky 效果\n    const contentStyles = computed(() => {\n      let styleStr = `z-index:${props.zIndex};`;\n      let isFixed = false;\n      if (props.disabled) return styleStr;\n      const offsetTop = Number(props.offsetTop);\n      if (container) {\n        if (containerHeight.value + containerTop.value < offsetTop + height.value) {\n          styleStr += `transform:translate3d(0, ${containerHeight.value - height.value}px, 0);`;\n        } else if (boxTop.value <= offsetTop) {\n          styleStr += `position:fixed;top:${offsetTop}px;`;\n          isFixed = true;\n        }\n      } else if (boxTop.value <= offsetTop) {\n        styleStr += `position:fixed;top:${offsetTop}px;`;\n        isFixed = true;\n      }\n      emitEvent('scroll', { scrollTop: contentTop.value, isFixed });\n      return styleStr;\n    });\n\n    return {\n      boxClasses,\n      boxStyles,\n      contentStyles,\n      stickyContent,\n    };\n  },\n});\n</script>\n","<template>\n  <div ref=\"boxRef\" :class=\"boxClasses\" :style=\"boxStyles\">\n    <div ref=\"contentRef\" :class=\"`${boxClasses}__content`\" :style=\"contentStyles\">\n      <t-node :content=\"stickyContent\"></t-node>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport { computed, getCurrentInstance, defineComponent, ref, watch } from 'vue';\nimport { useElementBounding, templateRef } from '@vueuse/core';\nimport props from './props';\nimport config from '../config';\nimport { renderContent, useEmitEvent, TNode } from '../shared';\n\nconst name = `${config.prefix}-sticky`;\n\nexport default defineComponent({\n  name,\n  components: { TNode },\n  props,\n  setup(props, context) {\n    const boxClasses = name;\n    const stickyContent = computed(() => renderContent(getCurrentInstance(), 'default', ''));\n    const emitEvent = useEmitEvent(props, context.emit);\n\n    // box 用于占位和记录边界\n    // content 用于实际定位\n    const boxRef = templateRef('boxRef');\n    const { top: boxTop } = useElementBounding(boxRef);\n    const contentRef = templateRef('contentRef');\n    const { top: contentTop, height } = useElementBounding(contentRef);\n\n    const boxStyles = computed(() => `height:${height.value}px;`);\n\n    // container 容器，sticky不会超出该边界\n    let container: HTMLElement;\n    const containerHeight = ref(0);\n    const containerTop = ref(0);\n\n    // 监听页面滚动事件\n    watch(boxTop, () => {\n      if (props.container) {\n        // @ts-ignore\n        container = document.querySelector(props.container);\n        const { top, height } = container.getBoundingClientRect();\n        containerHeight.value = height;\n        containerTop.value = top;\n      }\n    });\n\n    // 通过改变 content 的定位来实现 sticky 效果\n    const contentStyles = computed(() => {\n      let styleStr = `z-index:${props.zIndex};`;\n      let isFixed = false;\n      if (props.disabled) return styleStr;\n      const offsetTop = Number(props.offsetTop);\n      if (container) {\n        if (containerHeight.value + containerTop.value < offsetTop + height.value) {\n          styleStr += `transform:translate3d(0, ${containerHeight.value - height.value}px, 0);`;\n        } else if (boxTop.value <= offsetTop) {\n          styleStr += `position:fixed;top:${offsetTop}px;`;\n          isFixed = true;\n        }\n      } else if (boxTop.value <= offsetTop) {\n        styleStr += `position:fixed;top:${offsetTop}px;`;\n        isFixed = true;\n      }\n      emitEvent('scroll', { scrollTop: contentTop.value, isFixed });\n      return styleStr;\n    });\n\n    return {\n      boxClasses,\n      boxStyles,\n      contentStyles,\n      stickyContent,\n    };\n  },\n});\n</script>\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}