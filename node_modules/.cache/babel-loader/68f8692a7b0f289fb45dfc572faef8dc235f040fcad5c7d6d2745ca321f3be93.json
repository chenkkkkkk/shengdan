{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * tdesign v0.14.1\n * (c) 2022 TDesign Group\n * @license MIT\n */\n\nimport { ref, watchEffect, computed } from 'vue';\nimport camelCase from 'lodash/camelCase';\nfunction getDefaultName(key) {\n  var str = camelCase(key);\n  return \"default\".concat(str[0].toLocaleUpperCase() + str.slice(1));\n}\nfunction getEventPropsName(eventName) {\n  var str = camelCase(eventName);\n  return \"on\".concat(str[0].toLocaleUpperCase()).concat(str.slice(1));\n}\nfunction useDefault(props, emit, key, eventName) {\n  var modelValue = \"modelValue\";\n  var defaultName = getDefaultName(String(key));\n  var isUsedModelValue = props[modelValue] !== void 0;\n  var isUsedKey = props[key] !== void 0;\n  var innerValue = ref();\n  if (isUsedKey) {\n    innerValue.value = props[key];\n  } else if (isUsedModelValue) {\n    innerValue.value = props[modelValue];\n  } else {\n    innerValue.value = props[defaultName];\n  }\n  watchEffect(function () {\n    if (isUsedModelValue) {\n      innerValue.value = props[modelValue];\n    }\n    if (isUsedKey) {\n      innerValue.value = props[key];\n    }\n  });\n  function emitEvents(value) {\n    var _props$propsEventName;\n    for (var _len = arguments.length, arg = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      arg[_key - 1] = arguments[_key];\n    }\n    var updateKeys = [\"update:\".concat(key)];\n    if (isUsedModelValue) {\n      updateKeys.push(\"update:modelValue\");\n    }\n    updateKeys.forEach(function (updateKey) {\n      emit.apply(void 0, [updateKey, value].concat(arg));\n    });\n    var propsEventName = getEventPropsName(eventName);\n    (_props$propsEventName = props[propsEventName]) === null || _props$propsEventName === void 0 ? void 0 : _props$propsEventName.call.apply(_props$propsEventName, [props, value].concat(arg));\n  }\n  function setInnerValue(value) {\n    if (!isUsedKey && !isUsedModelValue) {\n      innerValue.value = value;\n    }\n    for (var _len2 = arguments.length, arg = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      arg[_key2 - 1] = arguments[_key2];\n    }\n    emitEvents.apply(void 0, [value].concat(arg));\n  }\n  var innerValueRef = computed({\n    get: function get() {\n      return innerValue.value;\n    },\n    set: function set(value) {\n      setInnerValue(value);\n    }\n  });\n  return [innerValueRef, setInnerValue];\n}\nexport { useDefault };","map":{"version":3,"mappings":";;;;;;;;;AAGA,SAASA,eAAeC,GAAqB;EACrC,UAAMC,UAAUD,GAAG;EACzB,wBAAiBE,GAAI,IAAGC,mBAAsB,OAAIC,MAAM,CAAC;AAC3D;AAGA,SAASC,kBAAkBC,SAA2B;EAC9C,UAAML,UAAUK,SAAS;EAC/B,mBAAYJ,GAAI,IAAGC,mBAAsB,aAAIC,MAAM,CAAC;AACtD;AAWO,SAASG,UAAiB,QAAUC,IAA4B,OAAaF,SAAmB;EACrG,IAAMG,UAAa;EACnB,IAAMC,WAAc,kBAAeC,MAAO,IAAG,CAAC;EAExC,uBAAmBC,MAAMH,UAAgB;EACzC,gBAAYG,MAAMZ,GAAS;EAEjC,IAAMa,aAAaC,GAAO;EAE1B,IAAIC,SAAW;IACbF,WAAWG,QAAQJ,KAAM;aAChBK,gBAAkB;IAC3BJ,WAAWG,QAAQJ,KAAM;EAC3B,CAAO;IACLC,WAAWG,QAAQJ,KAAM;EAC3B;EACAM,YAAY,YAAM;IAChB,IAAID,gBAAkB;MACpBJ,WAAWG,QAAQJ,KAAM;IAC3B;IACA,IAAIG,SAAW;MACbF,WAAWG,QAAQJ,KAAM;IAC3B;EACF,CAAC;EAEQ,oBAAiCI,OAAqB;IAAA;IAAA,kCAARG,GAAQ;MAARA,GAAQ;IAAA;IACvD,iBAAa,CAAWnB,oBAAK;IACnC,IAAIiB,gBAAkB;MACpBG,WAAWC,KAAwB;IACrC;IAEWD,mBAAQ,UAACE,SAAc;MAC3Bd,+BAAWQ,KAAO,SAAGG,GAAG;IAC/B,CAAC;IACK,qBAAiBd,kBAAkBC,SAAS;IAC5C,wKAAkBU,KAAO,CAAGG,WAAG;EACvC;EAES,uBAAoCH,OAAqB;IAC5D,KAACD,SAAa,KAACE,gBAAkB;MACnCJ,WAAWG,KAAQ;IACrB;IAAA,mCAHwDG,GAAQ;MAARA,GAAQ;IAAA;IAIlDI,gCAAUJ,WAAG;EAC7B;EAEA,IAAMK,gBAAgBC,QAAY;IAChCC,GAAM;MACJ,OAAOb,UAAW;KACpB;IACAc,kBAAIX,KAAU;MACZY,cAAcZ,KAAK;IACrB;EACF,CAAC;EAEM,QAACQ,eAAeI,aAAa;AACtC","names":["getDefaultName","key","camelCase","str","toLocaleUpperCase","slice","getEventPropsName","eventName","useDefault","emit","modelValue","defaultName","String","props","innerValue","ref","isUsedKey","value","isUsedModelValue","watchEffect","arg","updateKeys","push","updateKey","emitEvents","innerValueRef","computed","get","set","setInnerValue"],"sources":["../../../src/shared/useDefault/index.ts"],"sourcesContent":["import { computed, ref, SetupContext, watchEffect, WritableComputedRef } from 'vue';\nimport camelCase from 'lodash/camelCase';\n\nfunction getDefaultName(key: string): string {\n  const str = camelCase(key);\n  return `default${str[0].toLocaleUpperCase() + str.slice(1)}`;\n}\n\n// eventName is keybase, change -> onChange; visible-change -> onVisibleChange\nfunction getEventPropsName(eventName: string): string {\n  const str = camelCase(eventName);\n  return `on${str[0].toLocaleUpperCase()}${str.slice(1)}`;\n}\n\n/**\n * 受控和非受控逻辑处理，包含 value / modelValue / events\n * @param props 属性\n * @param emit 触发方法，context.emit\n * @param key 受控属性名称\n * @param eventName 事件名称\n * @example const [value, setValue] = useDefault();\n * @returns [value, setValue]\n */\nexport function useDefault<V, T>(props: T, emit: SetupContext['emit'], key: string, eventName: string) {\n  const modelValue = 'modelValue';\n  const defaultName = getDefaultName(String(key));\n\n  const isUsedModelValue = props[modelValue] !== undefined;\n  const isUsedKey = props[key] !== undefined;\n\n  const innerValue = ref<V>();\n\n  if (isUsedKey) {\n    innerValue.value = props[key];\n  } else if (isUsedModelValue) {\n    innerValue.value = props[modelValue];\n  } else {\n    innerValue.value = props[defaultName];\n  }\n  watchEffect(() => {\n    if (isUsedModelValue) {\n      innerValue.value = props[modelValue];\n    }\n    if (isUsedKey) {\n      innerValue.value = props[key];\n    }\n  });\n\n  function emitEvents<T extends Array<any>>(value: V, ...arg: T) {\n    const updateKeys = [`update:${key}`];\n    if (isUsedModelValue) {\n      updateKeys.push(`update:modelValue`);\n    }\n    // Props Event exists in Vue3. `props.onChange()` is equal `context.emit('change')`\n    updateKeys.forEach((updateKey) => {\n      emit(updateKey, value, ...arg);\n    });\n    const propsEventName = getEventPropsName(eventName);\n    props[propsEventName]?.(value, ...arg);\n  }\n\n  function setInnerValue<M extends Array<any>>(value: V, ...arg: M) {\n    if (!isUsedKey && !isUsedModelValue) {\n      innerValue.value = value;\n    }\n    emitEvents<M>(value, ...arg);\n  }\n\n  const innerValueRef = computed<V>({\n    get() {\n      return innerValue.value as V;\n    },\n    set(value: V) {\n      setInnerValue(value);\n    },\n  });\n\n  return [innerValueRef, setInnerValue] as [WritableComputedRef<V>, typeof setInnerValue];\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}