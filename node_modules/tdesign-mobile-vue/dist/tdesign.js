/**
 * tdesign v0.14.1
 * (c) 2022 TDesign Group
 * @license MIT
 */

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('vue')) :
  typeof define === 'function' && define.amd ? define(['exports', 'vue'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.TDesign = {}, global.Vue));
})(this, (function (exports, vue) { 'use strict';

  function _defineProperty$2(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  function _defineProperty$1(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }

  function ownKeys$1b(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$1b(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1b(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1b(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function camel2Kebab(camelString) {
    var covertArr = ["fillOpacity", "fillRule", "clipRule"];
    if (covertArr.includes(camelString)) {
      return camelString.replace(/([a-z0-9]|(?=[A-Z]))([A-Z])/g, "$1-$2").toLowerCase();
    }
    return camelString;
  }
  function renderFn(node, props) {
    var kebabAttrs = Object.keys(node.attrs).reduce(function (result, key) {
      result[camel2Kebab(key)] = node.attrs[key];
      return result;
    }, {});
    return vue.h(node.tag, _objectSpread$1b(_objectSpread$1b({}, kebabAttrs), props), (node.children || []).map(function (child) {
      return renderFn(child, {});
    }));
  }

  var DEFAULT_CLASS_PREFIX = "t";
  var DEFAULT_LOCALE = "zh-CN";
  var ConfigContext = {
    classPrefix: DEFAULT_CLASS_PREFIX,
    locale: DEFAULT_LOCALE
  };

  function useCommonClassName() {
    var classPrefix = ConfigContext.classPrefix;
    return {
      SIZE: {
        default: "",
        xs: "".concat(classPrefix, "-size-xs"),
        small: "".concat(classPrefix, "-size-s"),
        medium: "".concat(classPrefix, "-size-m"),
        large: "".concat(classPrefix, "-size-l"),
        xl: "".concat(classPrefix, "-size-xl"),
        block: "".concat(classPrefix, "-size-full-width")
      },
      STATUS: {
        loading: "".concat(classPrefix, "-is-loading"),
        disabled: "".concat(classPrefix, "-is-disabled"),
        focused: "".concat(classPrefix, "-is-focused"),
        success: "".concat(classPrefix, "-is-success"),
        error: "".concat(classPrefix, "-is-error"),
        warning: "".concat(classPrefix, "-is-warning"),
        selected: "".concat(classPrefix, "-is-selected"),
        active: "".concat(classPrefix, "-is-active"),
        checked: "".concat(classPrefix, "-is-checked"),
        current: "".concat(classPrefix, "-is-current"),
        hidden: "".concat(classPrefix, "-is-hidden"),
        visible: "".concat(classPrefix, "-is-visible"),
        expanded: "".concat(classPrefix, "-is-expanded"),
        indeterminate: "".concat(classPrefix, "-is-indeterminate")
      }
    };
  }

  function useSizeProps(size) {
    var COMMON_SIZE_CLASS_NAMES = useCommonClassName().SIZE;
    var className = vue.computed(function () {
      if (size.value in COMMON_SIZE_CLASS_NAMES) {
        return COMMON_SIZE_CLASS_NAMES[size.value];
      }
      return "";
    });
    var style = vue.computed(function () {
      if (size.value === void 0 || size.value in COMMON_SIZE_CLASS_NAMES) {
        return {};
      }
      return {
        fontSize: size.value
      };
    });
    return {
      style: style,
      className: className
    };
  }

  function ownKeys$1a(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$1a(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1a(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1a(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$q = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M7.35 8.65v3.85h1.3V8.65h3.85v-1.3H8.65V3.5h-1.3v3.85H3.5v1.3h3.85z",
        "fillOpacity": 0.9
      }
    }]
  };
  var add = vue.defineComponent({
    name: "AddIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-add", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$1a(_objectSpread$1a({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$q, finalProps.value);
      };
    }
  });

  function ownKeys$19(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$19(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$19(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$19(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$p = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M2 3h12V2H2v1zM3.38 10.23l4.1-4.03v8.64H8.5V6.2l4.18 4.08.71-.7-5.05-4.93a.5.5 0 00-.7 0l-4.98 4.9.72.69z",
        "fillOpacity": 0.9
      }
    }]
  };
  var backtop = vue.defineComponent({
    name: "BacktopIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-backtop", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$19(_objectSpread$19({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$p, finalProps.value);
      };
    }
  });

  function ownKeys$18(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$18(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$18(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$18(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$o = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M11 6H5l3 4.5L11 6z",
        "fillOpacity": 0.9
      }
    }]
  };
  var caretDownSmall = vue.defineComponent({
    name: "CaretDownSmallIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-caret-down-small", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$18(_objectSpread$18({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$o, finalProps.value);
      };
    }
  });

  function ownKeys$17(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$17(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$17(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$17(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$n = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 15A7 7 0 108 1a7 7 0 000 14zM4.5 8.2l.7-.7L7 9.3l3.8-3.8.7.7L7 10.7 4.5 8.2z",
        "fillOpacity": 0.9
      }
    }]
  };
  var checkCircleFilled = vue.defineComponent({
    name: "CheckCircleFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-check-circle-filled", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$17(_objectSpread$17({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$n, finalProps.value);
      };
    }
  });

  function ownKeys$16(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$16(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$16(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$16(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$m = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M4.5 8.2L7 10.7l4.5-4.5-.7-.7L7 9.3 5.2 7.5l-.7.7z",
        "fillOpacity": 0.9
      }
    }, {
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M4.11 2.18a7 7 0 117.78 11.64A7 7 0 014.1 2.18zm.56 10.8a6 6 0 106.66-9.97A6 6 0 004.67 13z",
        "fillOpacity": 0.9
      }
    }]
  };
  var checkCircle = vue.defineComponent({
    name: "CheckCircleIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-check-circle", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$16(_objectSpread$16({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$m, finalProps.value);
      };
    }
  });

  function ownKeys$15(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$15(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$15(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$15(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$l = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M6.43 9.92l6.23-6.22.92.92-7.15 7.14L1.97 7.3l.92-.92 3.54 3.54z",
        "fillOpacity": 0.9
      }
    }]
  };
  var check = vue.defineComponent({
    name: "CheckIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-check", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$15(_objectSpread$15({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$l, finalProps.value);
      };
    }
  });

  function ownKeys$14(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$14(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$14(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$14(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$k = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M3.54 6.46l.92-.92L8 9.08l3.54-3.54.92.92L8 10.92 3.54 6.46z",
        "fillOpacity": 0.9
      }
    }]
  };
  var chevronDown = vue.defineComponent({
    name: "ChevronDownIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-chevron-down", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$14(_objectSpread$14({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$k, finalProps.value);
      };
    }
  });

  function ownKeys$13(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$13(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$13(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$13(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$j = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M9.54 3.54l.92.92L6.92 8l3.54 3.54-.92.92L5.08 8l4.46-4.46z",
        "fillOpacity": 0.9
      }
    }]
  };
  var chevronLeft = vue.defineComponent({
    name: "ChevronLeftIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-chevron-left", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$13(_objectSpread$13({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$j, finalProps.value);
      };
    }
  });

  function ownKeys$12(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$12(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$12(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$12(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$i = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M6.46 12.46l-.92-.92L9.08 8 5.54 4.46l.92-.92L10.92 8l-4.46 4.46z",
        "fillOpacity": 0.9
      }
    }]
  };
  var chevronRight = vue.defineComponent({
    name: "ChevronRightIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-chevron-right", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$12(_objectSpread$12({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$i, finalProps.value);
      };
    }
  });

  function ownKeys$11(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$11(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$11(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$11(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$h = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M12.46 9.54l-.92.92L8 6.92l-3.54 3.54-.92-.92L8 5.08l4.46 4.46z",
        "fillOpacity": 0.9
      }
    }]
  };
  var chevronUp = vue.defineComponent({
    name: "ChevronUpIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-chevron-up", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$11(_objectSpread$11({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$h, finalProps.value);
      };
    }
  });

  function ownKeys$10(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$10(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$10(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$10(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$g = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 1a7 7 0 110 14A7 7 0 018 1zm0 1a6 6 0 100 12A6 6 0 008 2z",
        "opacity": 0.9,
        "fillOpacity": 0.9
      }
    }]
  };
  var circle = vue.defineComponent({
    name: "CircleIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-circle", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$10(_objectSpread$10({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$g, finalProps.value);
      };
    }
  });

  function ownKeys$$(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$$(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$$(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$$(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$f = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M15 8A7 7 0 101 8a7 7 0 0014 0zM5.67 4.95L8 7.29l2.33-2.34.7.7L8.7 8l2.34 2.35-.71.7L8 8.71l-2.33 2.34-.7-.7L7.3 8 4.96 5.65l.71-.7z",
        "fillOpacity": 0.9
      }
    }]
  };
  var closeCircleFilled = vue.defineComponent({
    name: "CloseCircleFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-close-circle-filled", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$$(_objectSpread$$({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$f, finalProps.value);
      };
    }
  });

  function ownKeys$_(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$_(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$_(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$_(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$e = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M4.98 10.31L7.3 8 5 5.69l.7-.7L8 7.28 10.31 5l.7.7L8.72 8l2.3 2.31-.7.7L8 8.72 5.69 11l-.7-.7z",
        "fillOpacity": 0.9
      }
    }, {
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 1a7 7 0 110 14A7 7 0 018 1zm0 1a6 6 0 100 12A6 6 0 008 2z",
        "fillOpacity": 0.9
      }
    }]
  };
  var closeCircle = vue.defineComponent({
    name: "CloseCircleIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-close-circle", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$_(_objectSpread$_({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$e, finalProps.value);
      };
    }
  });

  function ownKeys$Z(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$Z(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$Z(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$Z(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$d = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 8.92L11.08 12l.92-.92L8.92 8 12 4.92 11.08 4 8 7.08 4.92 4 4 4.92 7.08 8 4 11.08l.92.92L8 8.92z",
        "fillOpacity": 0.9
      }
    }]
  };
  var close = vue.defineComponent({
    name: "CloseIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-close", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$Z(_objectSpread$Z({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$d, finalProps.value);
      };
    }
  });

  function ownKeys$Y(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$Y(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$Y(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$Y(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$c = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M3 9a1 1 0 110-2 1 1 0 010 2zM7 8a1 1 0 102 0 1 1 0 00-2 0zM12 8a1 1 0 102 0 1 1 0 00-2 0z",
        "fillOpacity": 0.9
      }
    }]
  };
  var ellipsis = vue.defineComponent({
    name: "EllipsisIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-ellipsis", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$Y(_objectSpread$Y({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$c, finalProps.value);
      };
    }
  });

  function ownKeys$X(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$X(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$X(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$X(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$b = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M15 8A7 7 0 101 8a7 7 0 0014 0zM8.5 4v5.5h-1V4h1zm-1.1 7h1.2v1.2H7.4V11z",
        "fillOpacity": 0.9
      }
    }]
  };
  var errorCircleFilled = vue.defineComponent({
    name: "ErrorCircleFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-error-circle-filled", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$X(_objectSpread$X({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$b, finalProps.value);
      };
    }
  });

  function ownKeys$W(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$W(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$W(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$W(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$a = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8.5 4v5.5h-1V4h1zM8.6 10.5H7.4v1.2h1.2v-1.2z",
        "fillOpacity": 0.9
      }
    }, {
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M15 8A7 7 0 101 8a7 7 0 0014 0zm-1 0A6 6 0 112 8a6 6 0 0112 0z",
        "fillOpacity": 0.9
      }
    }]
  };
  var errorCircle = vue.defineComponent({
    name: "ErrorCircleIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-error-circle", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$W(_objectSpread$W({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$a, finalProps.value);
      };
    }
  });

  function ownKeys$V(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$V(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$V(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$V(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$9 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M6 11v1h4v-1H6z",
        "fillOpacity": 0.9
      }
    }, {
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M7.65 1.65c.2-.2.5-.2.7 0l6.5 6.5-.7.7L13 7.71v5.79a1 1 0 01-1 1H4a1 1 0 01-1-1V7.7L1.85 8.86l-.7-.7 6.5-6.5zM8 2.7l-4 4v6.79h8V6.7l-4-4z",
        "fillOpacity": 0.9
      }
    }]
  };
  var home = vue.defineComponent({
    name: "HomeIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-home", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$V(_objectSpread$V({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$9, finalProps.value);
      };
    }
  });

  function ownKeys$U(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$U(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$U(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$U(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$8 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 15A7 7 0 108 1a7 7 0 000 14zM7.4 4h1.2v1.2H7.4V4zm.1 2.5h1V12h-1V6.5z",
        "fillOpacity": 0.9
      }
    }]
  };
  var infoCircleFilled = vue.defineComponent({
    name: "InfoCircleFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-info-circle-filled", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$U(_objectSpread$U({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$8, finalProps.value);
      };
    }
  });

  function ownKeys$T(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$T(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$T(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$T(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$7 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M7.5 12V6.5h1V12h-1zM8.6 4H7.4v1.2h1.2V4z",
        "fillOpacity": 0.9
      }
    }, {
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M1 8a7 7 0 1014 0A7 7 0 001 8zm1 0a6 6 0 1112 0A6 6 0 012 8z",
        "fillOpacity": 0.9
      }
    }]
  };
  var infoCircle = vue.defineComponent({
    name: "InfoCircleIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-info-circle", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$T(_objectSpread$T({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$7, finalProps.value);
      };
    }
  });

  function ownKeys$S(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$S(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$S(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$S(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$6 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 1.5a6.5 6.5 0 000 13v-1.63A4.87 4.87 0 1112.88 8h1.62A6.5 6.5 0 008 1.5z",
        "fillOpacity": 0.9
      }
    }]
  };
  var loading = vue.defineComponent({
    name: "LoadingIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-loading", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$S(_objectSpread$S({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$6, finalProps.value);
      };
    }
  });

  function ownKeys$R(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$R(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$R(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$R(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$5 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 15A7 7 0 108 1a7 7 0 000 14zm3.5-6.5h-7v-1h7v1z",
        "fillOpacity": 0.9,
        "fillRule": "evenodd",
        "clipRule": "evenodd"
      }
    }]
  };
  var minusCircleFilled = vue.defineComponent({
    name: "MinusCircleFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-minus-circle-filled", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$R(_objectSpread$R({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$5, finalProps.value);
      };
    }
  });

  function ownKeys$Q(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$Q(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$Q(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$Q(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$4 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M8 2.71c2.9 0 5.25 2.36 5.25 5.29h.96a6.2 6.2 0 00-11.5-3.28V2.64h-.96v3.1c0 .29.22.5.5.5h3.09v-.96H3.49A5.25 5.25 0 018 2.71zM1.79 8h.96a5.25 5.25 0 009.76 2.71h-1.85v-.96h3.09c.28 0 .5.22.5.5v3.1h-.96v-2.07A6.2 6.2 0 011.8 8z",
        "fillOpacity": 0.9
      }
    }]
  };
  var refresh = vue.defineComponent({
    name: "RefreshIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-refresh", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$Q(_objectSpread$Q({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$4, finalProps.value);
      };
    }
  });

  function ownKeys$P(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$P(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$P(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$P(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$3 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M3.5 7.35h9v1.3h-9v-1.3z",
        "fillOpacity": 0.9
      }
    }]
  };
  var remove = vue.defineComponent({
    name: "RemoveIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-remove", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$P(_objectSpread$P({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$3, finalProps.value);
      };
    }
  });

  function ownKeys$O(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$O(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$O(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$O(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$2 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M9.51 10.22a4.76 4.76 0 11.7-.7l3.54 3.52-.7.71-3.54-3.53zm.77-3.7a3.76 3.76 0 10-7.53 0 3.76 3.76 0 007.53 0z",
        "fillOpacity": 0.9
      }
    }]
  };
  var search = vue.defineComponent({
    name: "SearchIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-search", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$O(_objectSpread$O({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$2, finalProps.value);
      };
    }
  });

  function ownKeys$N(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$N(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$N(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$N(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element$1 = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M7.6 1.82a.45.45 0 01.8 0l1.8 3.65 4.03.58c.37.05.52.5.25.77l-2.91 2.84.69 4a.45.45 0 01-.66.48L8 12.25l-3.6 1.9a.45.45 0 01-.65-.48l.68-4.01-2.9-2.84a.45.45 0 01.24-.77l4.03-.58 1.8-3.65z",
        "fillOpacity": 0.9
      }
    }]
  };
  var starFilled = vue.defineComponent({
    name: "StarFilledIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-star-filled", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$N(_objectSpread$N({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element$1, finalProps.value);
      };
    }
  });

  function ownKeys$M(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread$M(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$M(Object(source), !0).forEach(function (key) {
        _defineProperty$1(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$M(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  var element = {
    "tag": "svg",
    "attrs": {
      "fill": "none",
      "viewBox": "0 0 16 16",
      "width": "1em",
      "height": "1em"
    },
    "children": [{
      "tag": "path",
      "attrs": {
        "fill": "currentColor",
        "d": "M9.54 6.38L8 3.26 6.46 6.38l-3.44.5L5.5 9.31l-.59 3.43L8 11.12l3.08 1.62-.59-3.43L13 6.88l-3.45-.5zm5-.29a.3.3 0 01.16.52l-3.13 3.05.74 4.3a.3.3 0 01-.44.32L8 12.25l-3.87 2.03a.3.3 0 01-.43-.31l.73-4.31L1.3 6.6a.3.3 0 01.17-.52l4.33-.62 1.93-3.92a.3.3 0 01.54 0l1.94 3.92 4.32.62z",
        "fillOpacity": 0.9
      }
    }]
  };
  var star = vue.defineComponent({
    name: "StarIcon",
    props: {
      size: {
        type: String
      },
      onClick: {
        type: Function
      }
    },
    setup: function setup(props, _ref) {
      var attrs = _ref.attrs;
      var propsSize = vue.computed(function () {
        return props.size;
      });
      var _useSizeProps = useSizeProps(propsSize),
        className = _useSizeProps.className,
        style = _useSizeProps.style;
      var finalCls = vue.computed(function () {
        return ["t-icon", "t-icon-star", className.value];
      });
      var finalStyle = vue.computed(function () {
        return _objectSpread$M(_objectSpread$M({}, style.value), attrs.style);
      });
      var finalProps = vue.computed(function () {
        return {
          class: finalCls.value,
          style: finalStyle.value,
          onClick: function onClick(e) {
            var _props$onClick;
            return (_props$onClick = props.onClick) === null || _props$onClick === void 0 ? void 0 : _props$onClick.call(props, {
              e: e
            });
          }
        };
      });
      return function () {
        return renderFn(element, finalProps.value);
      };
    }
  });

  var NOOP = function NOOP() {};

  var inBrowser = typeof window !== "undefined";
  function getCharacterLength(str, maxCharacter) {
    var hasMaxCharacter = typeof maxCharacter === "number";
    if (!str || str.length === 0) {
      if (hasMaxCharacter) {
        return {
          length: 0,
          characters: str
        };
      }
      return 0;
    }
    var len = 0;
    for (var i = 0; i < str.length; i++) {
      var currentStringLength = 0;
      if (str.charCodeAt(i) > 127 || str.charCodeAt(i) === 94) {
        currentStringLength = 2;
      } else {
        currentStringLength = 1;
      }
      if (hasMaxCharacter && len + currentStringLength > maxCharacter) {
        return {
          length: len,
          characters: str.slice(0, i)
        };
      }
      len += currentStringLength;
    }
    if (hasMaxCharacter) {
      return {
        length: len,
        characters: str
      };
    }
    return len;
  }

  var withInstall = function withInstall(comp) {
    var c = comp;
    c.install = function (app, name) {
      var defaultName = c.name;
      app.component(name || defaultName, comp);
    };
    return c;
  };
  function extendAPI(apis) {
    var instance = vue.getCurrentInstance();
    if (instance && instance.proxy) {
      Object.assign(instance.proxy, apis);
    }
  }

  var config = {
    prefix: "t"
  };

  var prefix$17 = config.prefix;
  var SIZE_CLASSNAMES = {
    small: "".concat(prefix$17, "-size-s"),
    medium: "".concat(prefix$17, "-size-m"),
    large: "".concat(prefix$17, "-size-l"),
    default: "",
    xs: "".concat(prefix$17, "-size-xs"),
    xl: "".concat(prefix$17, "-size-xl"),
    block: "".concat(prefix$17, "-size-full-width")
  };
  var STATUS_CLASSNAMES = {
    loading: "".concat(prefix$17, "-is-loading"),
    disabled: "".concat(prefix$17, "-is-disabled"),
    focused: "".concat(prefix$17, "-is-focused"),
    success: "".concat(prefix$17, "-is-success"),
    error: "".concat(prefix$17, "-is-error"),
    warning: "".concat(prefix$17, "-is-warning"),
    selected: "".concat(prefix$17, "-is-selected"),
    active: "".concat(prefix$17, "-is-active"),
    checked: "".concat(prefix$17, "-is-checked"),
    current: "".concat(prefix$17, "-is-current"),
    hidden: "".concat(prefix$17, "-is-hidden"),
    visible: "".concat(prefix$17, "-is-visible"),
    expanded: "".concat(prefix$17, "-is-expanded"),
    indeterminate: "".concat(prefix$17, "-is-indeterminate")
  };
  var ClASSNAMES = {
    SIZE: SIZE_CLASSNAMES,
    STATUS: STATUS_CLASSNAMES
  };

  function _typeof$1(obj) {
    "@babel/helpers - typeof";

    return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
      return typeof obj;
    } : function (obj) {
      return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, _typeof$1(obj);
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var freeGlobal$1 = _typeof$1(commonjsGlobal) == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
  var _freeGlobal = freeGlobal$1;

  var freeGlobal = _freeGlobal;

  /** Detect free variable `self`. */
  var freeSelf = (typeof self === "undefined" ? "undefined" : _typeof$1(self)) == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root$8 = freeGlobal || freeSelf || Function('return this')();
  var _root = root$8;

  var root$7 = _root;

  /** Built-in value references. */
  var _Symbol2 = root$7.Symbol;
  var _Symbol$4 = _Symbol2;

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap$3(array, iteratee) {
    var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);
    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }
  var _arrayMap = arrayMap$3;

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$a = Array.isArray;
  var isArray_1 = isArray$a;

  var _Symbol$3 = _Symbol$4;

  /** Used for built-in method references. */
  var objectProto$b = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$8 = objectProto$b.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString$1 = objectProto$b.toString;

  /** Built-in value references. */
  var symToStringTag$1 = _Symbol$3 ? _Symbol$3.toStringTag : undefined;

  /**
   * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the raw `toStringTag`.
   */
  function getRawTag$1(value) {
    var isOwn = hasOwnProperty$8.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];
    try {
      value[symToStringTag$1] = undefined;
      var unmasked = true;
    } catch (e) {}
    var result = nativeObjectToString$1.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag$1] = tag;
      } else {
        delete value[symToStringTag$1];
      }
    }
    return result;
  }
  var _getRawTag = getRawTag$1;

  /** Used for built-in method references. */
  var objectProto$a = Object.prototype;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var nativeObjectToString = objectProto$a.toString;

  /**
   * Converts `value` to a string using `Object.prototype.toString`.
   *
   * @private
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   */
  function objectToString$1(value) {
    return nativeObjectToString.call(value);
  }
  var _objectToString = objectToString$1;

  var _Symbol$2 = _Symbol$4,
    getRawTag = _getRawTag,
    objectToString = _objectToString;

  /** `Object#toString` result references. */
  var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

  /** Built-in value references. */
  var symToStringTag = _Symbol$2 ? _Symbol$2.toStringTag : undefined;

  /**
   * The base implementation of `getTag` without fallbacks for buggy environments.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag$6(value) {
    if (value == null) {
      return value === undefined ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  var _baseGetTag = baseGetTag$6;

  function isObjectLike$7(value) {
    return value != null && _typeof$1(value) == 'object';
  }
  var isObjectLike_1 = isObjectLike$7;

  var baseGetTag$5 = _baseGetTag,
    isObjectLike$6 = isObjectLike_1;

  /** `Object#toString` result references. */
  var symbolTag$1 = '[object Symbol]';

  /**
   * Checks if `value` is classified as a `Symbol` primitive or object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
   * @example
   *
   * _.isSymbol(Symbol.iterator);
   * // => true
   *
   * _.isSymbol('abc');
   * // => false
   */
  function isSymbol$4(value) {
    return _typeof$1(value) == 'symbol' || isObjectLike$6(value) && baseGetTag$5(value) == symbolTag$1;
  }
  var isSymbol_1 = isSymbol$4;

  var _Symbol$1 = _Symbol$4,
    arrayMap$2 = _arrayMap,
    isArray$9 = isArray_1,
    isSymbol$3 = isSymbol_1;

  /** Used as references for various `Number` constants. */
  var INFINITY$2 = 1 / 0;

  /** Used to convert symbols to primitives and strings. */
  var symbolProto$1 = _Symbol$1 ? _Symbol$1.prototype : undefined,
    symbolToString = symbolProto$1 ? symbolProto$1.toString : undefined;

  /**
   * The base implementation of `_.toString` which doesn't convert nullish
   * values to empty strings.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString$1(value) {
    // Exit early for strings to avoid a performance hit in some environments.
    if (typeof value == 'string') {
      return value;
    }
    if (isArray$9(value)) {
      // Recursively convert values (susceptible to call stack limits).
      return arrayMap$2(value, baseToString$1) + '';
    }
    if (isSymbol$3(value)) {
      return symbolToString ? symbolToString.call(value) : '';
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$2 ? '-0' : result;
  }
  var _baseToString = baseToString$1;

  var baseToString = _baseToString;

  /**
   * Converts `value` to a string. An empty string is returned for `null`
   * and `undefined` values. The sign of `-0` is preserved.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.toString(null);
   * // => ''
   *
   * _.toString(-0);
   * // => '-0'
   *
   * _.toString([1, 2, 3]);
   * // => '1,2,3'
   */
  function toString$5(value) {
    return value == null ? '' : baseToString(value);
  }
  var toString_1 = toString$5;

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice$1(array, start, end) {
    var index = -1,
      length = array.length;
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }
  var _baseSlice = baseSlice$1;

  var baseSlice = _baseSlice;

  /**
   * Casts `array` to a slice if it's needed.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {number} start The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the cast slice.
   */
  function castSlice$1(array, start, end) {
    var length = array.length;
    end = end === undefined ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }
  var _castSlice = castSlice$1;

  /** Used to compose unicode character classes. */
  var rsAstralRange$2 = "\\ud800-\\udfff",
    rsComboMarksRange$3 = "\\u0300-\\u036f",
    reComboHalfMarksRange$3 = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange$3 = "\\u20d0-\\u20ff",
    rsComboRange$3 = rsComboMarksRange$3 + reComboHalfMarksRange$3 + rsComboSymbolsRange$3,
    rsVarRange$2 = "\\ufe0e\\ufe0f";

  /** Used to compose unicode capture groups. */
  var rsZWJ$2 = "\\u200d";

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ$2 + rsAstralRange$2 + rsComboRange$3 + rsVarRange$2 + ']');

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode$2(string) {
    return reHasUnicode.test(string);
  }
  var _hasUnicode = hasUnicode$2;

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray$1(string) {
    return string.split('');
  }
  var _asciiToArray = asciiToArray$1;

  /** Used to compose unicode character classes. */
  var rsAstralRange$1 = "\\ud800-\\udfff",
    rsComboMarksRange$2 = "\\u0300-\\u036f",
    reComboHalfMarksRange$2 = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange$2 = "\\u20d0-\\u20ff",
    rsComboRange$2 = rsComboMarksRange$2 + reComboHalfMarksRange$2 + rsComboSymbolsRange$2,
    rsVarRange$1 = "\\ufe0e\\ufe0f";

  /** Used to compose unicode capture groups. */
  var rsAstral = '[' + rsAstralRange$1 + ']',
    rsCombo$2 = '[' + rsComboRange$2 + ']',
    rsFitz$1 = "\\ud83c[\\udffb-\\udfff]",
    rsModifier$1 = '(?:' + rsCombo$2 + '|' + rsFitz$1 + ')',
    rsNonAstral$1 = '[^' + rsAstralRange$1 + ']',
    rsRegional$1 = "(?:\\ud83c[\\udde6-\\uddff]){2}",
    rsSurrPair$1 = "[\\ud800-\\udbff][\\udc00-\\udfff]",
    rsZWJ$1 = "\\u200d";

  /** Used to compose unicode regexes. */
  var reOptMod$1 = rsModifier$1 + '?',
    rsOptVar$1 = '[' + rsVarRange$1 + ']?',
    rsOptJoin$1 = '(?:' + rsZWJ$1 + '(?:' + [rsNonAstral$1, rsRegional$1, rsSurrPair$1].join('|') + ')' + rsOptVar$1 + reOptMod$1 + ')*',
    rsSeq$1 = rsOptVar$1 + reOptMod$1 + rsOptJoin$1,
    rsSymbol = '(?:' + [rsNonAstral$1 + rsCombo$2 + '?', rsCombo$2, rsRegional$1, rsSurrPair$1, rsAstral].join('|') + ')';

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz$1 + '(?=' + rsFitz$1 + ')|' + rsSymbol + rsSeq$1, 'g');

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray$1(string) {
    return string.match(reUnicode) || [];
  }
  var _unicodeToArray = unicodeToArray$1;

  var asciiToArray = _asciiToArray,
    hasUnicode$1 = _hasUnicode,
    unicodeToArray = _unicodeToArray;

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray$1(string) {
    return hasUnicode$1(string) ? unicodeToArray(string) : asciiToArray(string);
  }
  var _stringToArray = stringToArray$1;

  var castSlice = _castSlice,
    hasUnicode = _hasUnicode,
    stringToArray = _stringToArray,
    toString$4 = toString_1;

  /**
   * Creates a function like `_.lowerFirst`.
   *
   * @private
   * @param {string} methodName The name of the `String` case method to use.
   * @returns {Function} Returns the new case function.
   */
  function createCaseFirst$1(methodName) {
    return function (string) {
      string = toString$4(string);
      var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
      var chr = strSymbols ? strSymbols[0] : string.charAt(0);
      var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
      return chr[methodName]() + trailing;
    };
  }
  var _createCaseFirst = createCaseFirst$1;

  var createCaseFirst = _createCaseFirst;

  /**
   * Converts the first character of `string` to upper case.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the converted string.
   * @example
   *
   * _.upperFirst('fred');
   * // => 'Fred'
   *
   * _.upperFirst('FRED');
   * // => 'FRED'
   */
  var upperFirst$1 = createCaseFirst('toUpperCase');
  var upperFirst_1 = upperFirst$1;

  var toString$3 = toString_1,
    upperFirst = upperFirst_1;

  /**
   * Converts the first character of `string` to upper case and the remaining
   * to lower case.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to capitalize.
   * @returns {string} Returns the capitalized string.
   * @example
   *
   * _.capitalize('FRED');
   * // => 'Fred'
   */
  function capitalize$1(string) {
    return upperFirst(toString$3(string).toLowerCase());
  }
  var capitalize_1 = capitalize$1;

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce$1(array, iteratee, accumulator, initAccum) {
    var index = -1,
      length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }
  var _arrayReduce = arrayReduce$1;

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf$1(object) {
    return function (key) {
      return object == null ? undefined : object[key];
    };
  }
  var _basePropertyOf = basePropertyOf$1;

  var basePropertyOf = _basePropertyOf;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',
    '\xc1': 'A',
    '\xc2': 'A',
    '\xc3': 'A',
    '\xc4': 'A',
    '\xc5': 'A',
    '\xe0': 'a',
    '\xe1': 'a',
    '\xe2': 'a',
    '\xe3': 'a',
    '\xe4': 'a',
    '\xe5': 'a',
    '\xc7': 'C',
    '\xe7': 'c',
    '\xd0': 'D',
    '\xf0': 'd',
    '\xc8': 'E',
    '\xc9': 'E',
    '\xca': 'E',
    '\xcb': 'E',
    '\xe8': 'e',
    '\xe9': 'e',
    '\xea': 'e',
    '\xeb': 'e',
    '\xcc': 'I',
    '\xcd': 'I',
    '\xce': 'I',
    '\xcf': 'I',
    '\xec': 'i',
    '\xed': 'i',
    '\xee': 'i',
    '\xef': 'i',
    '\xd1': 'N',
    '\xf1': 'n',
    '\xd2': 'O',
    '\xd3': 'O',
    '\xd4': 'O',
    '\xd5': 'O',
    '\xd6': 'O',
    '\xd8': 'O',
    '\xf2': 'o',
    '\xf3': 'o',
    '\xf4': 'o',
    '\xf5': 'o',
    '\xf6': 'o',
    '\xf8': 'o',
    '\xd9': 'U',
    '\xda': 'U',
    '\xdb': 'U',
    '\xdc': 'U',
    '\xf9': 'u',
    '\xfa': 'u',
    '\xfb': 'u',
    '\xfc': 'u',
    '\xdd': 'Y',
    '\xfd': 'y',
    '\xff': 'y',
    '\xc6': 'Ae',
    '\xe6': 'ae',
    '\xde': 'Th',
    '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    "\u0100": 'A',
    "\u0102": 'A',
    "\u0104": 'A',
    "\u0101": 'a',
    "\u0103": 'a',
    "\u0105": 'a',
    "\u0106": 'C',
    "\u0108": 'C',
    "\u010A": 'C',
    "\u010C": 'C',
    "\u0107": 'c',
    "\u0109": 'c',
    "\u010B": 'c',
    "\u010D": 'c',
    "\u010E": 'D',
    "\u0110": 'D',
    "\u010F": 'd',
    "\u0111": 'd',
    "\u0112": 'E',
    "\u0114": 'E',
    "\u0116": 'E',
    "\u0118": 'E',
    "\u011A": 'E',
    "\u0113": 'e',
    "\u0115": 'e',
    "\u0117": 'e',
    "\u0119": 'e',
    "\u011B": 'e',
    "\u011C": 'G',
    "\u011E": 'G',
    "\u0120": 'G',
    "\u0122": 'G',
    "\u011D": 'g',
    "\u011F": 'g',
    "\u0121": 'g',
    "\u0123": 'g',
    "\u0124": 'H',
    "\u0126": 'H',
    "\u0125": 'h',
    "\u0127": 'h',
    "\u0128": 'I',
    "\u012A": 'I',
    "\u012C": 'I',
    "\u012E": 'I',
    "\u0130": 'I',
    "\u0129": 'i',
    "\u012B": 'i',
    "\u012D": 'i',
    "\u012F": 'i',
    "\u0131": 'i',
    "\u0134": 'J',
    "\u0135": 'j',
    "\u0136": 'K',
    "\u0137": 'k',
    "\u0138": 'k',
    "\u0139": 'L',
    "\u013B": 'L',
    "\u013D": 'L',
    "\u013F": 'L',
    "\u0141": 'L',
    "\u013A": 'l',
    "\u013C": 'l',
    "\u013E": 'l',
    "\u0140": 'l',
    "\u0142": 'l',
    "\u0143": 'N',
    "\u0145": 'N',
    "\u0147": 'N',
    "\u014A": 'N',
    "\u0144": 'n',
    "\u0146": 'n',
    "\u0148": 'n',
    "\u014B": 'n',
    "\u014C": 'O',
    "\u014E": 'O',
    "\u0150": 'O',
    "\u014D": 'o',
    "\u014F": 'o',
    "\u0151": 'o',
    "\u0154": 'R',
    "\u0156": 'R',
    "\u0158": 'R',
    "\u0155": 'r',
    "\u0157": 'r',
    "\u0159": 'r',
    "\u015A": 'S',
    "\u015C": 'S',
    "\u015E": 'S',
    "\u0160": 'S',
    "\u015B": 's',
    "\u015D": 's',
    "\u015F": 's',
    "\u0161": 's',
    "\u0162": 'T',
    "\u0164": 'T',
    "\u0166": 'T',
    "\u0163": 't',
    "\u0165": 't',
    "\u0167": 't',
    "\u0168": 'U',
    "\u016A": 'U',
    "\u016C": 'U',
    "\u016E": 'U',
    "\u0170": 'U',
    "\u0172": 'U',
    "\u0169": 'u',
    "\u016B": 'u',
    "\u016D": 'u',
    "\u016F": 'u',
    "\u0171": 'u',
    "\u0173": 'u',
    "\u0174": 'W',
    "\u0175": 'w',
    "\u0176": 'Y',
    "\u0177": 'y',
    "\u0178": 'Y',
    "\u0179": 'Z',
    "\u017B": 'Z',
    "\u017D": 'Z',
    "\u017A": 'z',
    "\u017C": 'z',
    "\u017E": 'z',
    "\u0132": 'IJ',
    "\u0133": 'ij',
    "\u0152": 'Oe',
    "\u0153": 'oe',
    "\u0149": "'n",
    "\u017F": 's'
  };

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter$1 = basePropertyOf(deburredLetters);
  var _deburrLetter = deburrLetter$1;

  var deburrLetter = _deburrLetter,
    toString$2 = toString_1;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to compose unicode character classes. */
  var rsComboMarksRange$1 = "\\u0300-\\u036f",
    reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange$1 = "\\u20d0-\\u20ff",
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;

  /** Used to compose unicode capture groups. */
  var rsCombo$1 = '[' + rsComboRange$1 + ']';

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo$1, 'g');

  /**
   * Deburrs `string` by converting
   * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
   * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
   * letters to basic Latin letters and removing
   * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to deburr.
   * @returns {string} Returns the deburred string.
   * @example
   *
   * _.deburr('dj vu');
   * // => 'deja vu'
   */
  function deburr$1(string) {
    string = toString$2(string);
    return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
  }
  var deburr_1 = deburr$1;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords$1(string) {
    return string.match(reAsciiWord) || [];
  }
  var _asciiWords = asciiWords$1;

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord$1(string) {
    return reHasUnicodeWord.test(string);
  }
  var _hasUnicodeWord = hasUnicodeWord$1;

  /** Used to compose unicode character classes. */
  var rsAstralRange = "\\ud800-\\udfff",
    rsComboMarksRange = "\\u0300-\\u036f",
    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
    rsComboSymbolsRange = "\\u20d0-\\u20ff",
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = "\\u2700-\\u27bf",
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = "\\u2000-\\u206f",
    rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = "\\ufe0e\\ufe0f",
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos$1 = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = "\\ud83c[\\udffb-\\udfff]",
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
    rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = "\\u200d";

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')', rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower, rsUpper + '+' + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join('|'), 'g');

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords$1(string) {
    return string.match(reUnicodeWord) || [];
  }
  var _unicodeWords = unicodeWords$1;

  var asciiWords = _asciiWords,
    hasUnicodeWord = _hasUnicodeWord,
    toString$1 = toString_1,
    unicodeWords = _unicodeWords;

  /**
   * Splits `string` into an array of its words.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to inspect.
   * @param {RegExp|string} [pattern] The pattern to match words.
   * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
   * @returns {Array} Returns the words of `string`.
   * @example
   *
   * _.words('fred, barney, & pebbles');
   * // => ['fred', 'barney', 'pebbles']
   *
   * _.words('fred, barney, & pebbles', /[^, ]+/g);
   * // => ['fred', 'barney', '&', 'pebbles']
   */
  function words$1(string, pattern, guard) {
    string = toString$1(string);
    pattern = guard ? undefined : pattern;
    if (pattern === undefined) {
      return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
    }
    return string.match(pattern) || [];
  }
  var words_1 = words$1;

  var arrayReduce = _arrayReduce,
    deburr = deburr_1,
    words = words_1;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]";

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Creates a function like `_.camelCase`.
   *
   * @private
   * @param {Function} callback The function to combine each word.
   * @returns {Function} Returns the new compounder function.
   */
  function createCompounder$1(callback) {
    return function (string) {
      return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
    };
  }
  var _createCompounder = createCompounder$1;

  var capitalize = capitalize_1,
    createCompounder = _createCompounder;

  /**
   * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category String
   * @param {string} [string=''] The string to convert.
   * @returns {string} Returns the camel cased string.
   * @example
   *
   * _.camelCase('Foo Bar');
   * // => 'fooBar'
   *
   * _.camelCase('--foo-bar--');
   * // => 'fooBar'
   *
   * _.camelCase('__FOO_BAR__');
   * // => 'fooBar'
   */
  var camelCase = createCompounder(function (result, word, index) {
    word = word.toLowerCase();
    return result + (index ? capitalize(word) : word);
  });
  var camelCase_1 = camelCase;

  var renderTNode = function renderTNode(instance, name, options) {
    var _instance$slots$name3;
    if (instance === null) {
      return vue.h("", null);
    }
    var params = _typeof$1(options) === "object" && "params" in options ? options.params : null;
    var defaultNode = _typeof$1(options) === "object" && "defaultNode" in options ? options.defaultNode : options;
    var propsNode;
    if (name in instance.props || camelCase_1(name) in instance.props) {
      propsNode = instance.props[name] || instance.props[camelCase_1(name)];
    }
    if (instance.slots[name]) {
      var _instance$slots$name;
      return (_instance$slots$name = instance.slots[name]) === null || _instance$slots$name === void 0 ? void 0 : _instance$slots$name.call(params);
    }
    if (propsNode === true && defaultNode) {
      var _instance$slots$name2;
      return instance.slots[name] ? (_instance$slots$name2 = instance.slots[name]) === null || _instance$slots$name2 === void 0 ? void 0 : _instance$slots$name2.call(params) : defaultNode;
    }
    if (typeof propsNode === "function") return propsNode(vue.h, params);
    var isPropsEmpty = [void 0, params, ""].includes(propsNode);
    if (isPropsEmpty && instance.slots[name]) return (_instance$slots$name3 = instance.slots[name]) === null || _instance$slots$name3 === void 0 ? void 0 : _instance$slots$name3.call(params);
    return propsNode;
  };
  var renderContent = function renderContent(instance, name1, name2, options) {
    if (instance === null) {
      return vue.h("", null);
    }
    var params = _typeof$1(options) === "object" && "params" in options ? options.params : null;
    var defaultNode = _typeof$1(options) === "object" && "defaultNode" in options ? options.defaultNode : options;
    var toParams = params ? {
      params: params
    } : void 0;
    var node1 = renderTNode(instance, name1, toParams);
    var node2 = renderTNode(instance, name2, toParams);
    var r = [void 0, null, ""].includes(node1) ? node2 : node1;
    return [void 0, null, ""].includes(r) ? defaultNode : r;
  };

  var TNodeComponent = function TNodeComponent(props) {
    return props.content;
  };
  TNodeComponent.props = ["content"];

  function useToggle(values, defaultValue) {
    var innerValues = values || [true, false];
    var state = vue.ref();
    if (defaultValue === void 0) {
      state = vue.ref(innerValues[1]);
    } else if (vue.isRef(defaultValue)) {
      state = defaultValue;
    } else {
      state = vue.ref(defaultValue);
    }
    var toggle = function toggle(value) {
      if (value !== void 0) {
        state.value = value;
      } else {
        state.value = state.value === innerValues[1] ? innerValues[0] : innerValues[1];
      }
    };
    return {
      state: state,
      toggle: toggle
    };
  }

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
        args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(undefined);
      });
    };
  }

  var regeneratorRuntime$1 = {exports: {}};

  var _typeof = {exports: {}};

  (function (module) {
    function _typeof(obj) {
      "@babel/helpers - typeof";

      return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
        return typeof obj;
      } : function (obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(obj);
    }
    module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(_typeof);

  (function (module) {
    var _typeof$1 = _typeof.exports["default"];
    function _regeneratorRuntime() {

      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
      module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
        return exports;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      var exports = {},
        Op = Object.prototype,
        hasOwn = Op.hasOwnProperty,
        defineProperty = Object.defineProperty || function (obj, key, desc) {
          obj[key] = desc.value;
        },
        $Symbol = "function" == typeof Symbol ? Symbol : {},
        iteratorSymbol = $Symbol.iterator || "@@iterator",
        asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
        toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
      function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
          value: value,
          enumerable: !0,
          configurable: !0,
          writable: !0
        }), obj[key];
      }
      try {
        define({}, "");
      } catch (err) {
        define = function define(obj, key, value) {
          return obj[key] = value;
        };
      }
      function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
          generator = Object.create(protoGenerator.prototype),
          context = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", {
          value: makeInvokeMethod(innerFn, self, context)
        }), generator;
      }
      function tryCatch(fn, obj, arg) {
        try {
          return {
            type: "normal",
            arg: fn.call(obj, arg)
          };
        } catch (err) {
          return {
            type: "throw",
            arg: err
          };
        }
      }
      exports.wrap = wrap;
      var ContinueSentinel = {};
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}
      var IteratorPrototype = {};
      define(IteratorPrototype, iteratorSymbol, function () {
        return this;
      });
      var getProto = Object.getPrototypeOf,
        NativeIteratorPrototype = getProto && getProto(getProto(values([])));
      NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
      var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
      function defineIteratorMethods(prototype) {
        ["next", "throw", "return"].forEach(function (method) {
          define(prototype, method, function (arg) {
            return this._invoke(method, arg);
          });
        });
      }
      function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
          var record = tryCatch(generator[method], generator, arg);
          if ("throw" !== record.type) {
            var result = record.arg,
              value = result.value;
            return value && "object" == _typeof$1(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
              invoke("next", value, resolve, reject);
            }, function (err) {
              invoke("throw", err, resolve, reject);
            }) : PromiseImpl.resolve(value).then(function (unwrapped) {
              result.value = unwrapped, resolve(result);
            }, function (error) {
              return invoke("throw", error, resolve, reject);
            });
          }
          reject(record.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", {
          value: function value(method, arg) {
            function callInvokeWithMethodAndArg() {
              return new PromiseImpl(function (resolve, reject) {
                invoke(method, arg, resolve, reject);
              });
            }
            return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(innerFn, self, context) {
        var state = "suspendedStart";
        return function (method, arg) {
          if ("executing" === state) throw new Error("Generator is already running");
          if ("completed" === state) {
            if ("throw" === method) throw arg;
            return doneResult();
          }
          for (context.method = method, context.arg = arg;;) {
            var delegate = context.delegate;
            if (delegate) {
              var delegateResult = maybeInvokeDelegate(delegate, context);
              if (delegateResult) {
                if (delegateResult === ContinueSentinel) continue;
                return delegateResult;
              }
            }
            if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
              if ("suspendedStart" === state) throw state = "completed", context.arg;
              context.dispatchException(context.arg);
            } else "return" === context.method && context.abrupt("return", context.arg);
            state = "executing";
            var record = tryCatch(innerFn, self, context);
            if ("normal" === record.type) {
              if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
              return {
                value: record.arg,
                done: context.done
              };
            }
            "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
          }
        };
      }
      function maybeInvokeDelegate(delegate, context) {
        var method = delegate.iterator[context.method];
        if (undefined === method) {
          if (context.delegate = null, "throw" === context.method) {
            if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
            context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
          }
          return ContinueSentinel;
        }
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
      }
      function pushTryEntry(locs) {
        var entry = {
          tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
      }
      function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
      }
      function Context(tryLocsList) {
        this.tryEntries = [{
          tryLoc: "root"
        }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
      }
      function values(iterable) {
        if (iterable) {
          var iteratorMethod = iterable[iteratorSymbol];
          if (iteratorMethod) return iteratorMethod.call(iterable);
          if ("function" == typeof iterable.next) return iterable;
          if (!isNaN(iterable.length)) {
            var i = -1,
              next = function next() {
                for (; ++i < iterable.length;) {
                  if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
                }
                return next.value = undefined, next.done = !0, next;
              };
            return next.next = next;
          }
        }
        return {
          next: doneResult
        };
      }
      function doneResult() {
        return {
          value: undefined,
          done: !0
        };
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: !0
      }), defineProperty(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: !0
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
      }, exports.mark = function (genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
      }, exports.awrap = function (arg) {
        return {
          __await: arg
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
        return this;
      }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
          return result.done ? result.value : iter.next();
        });
      }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
        return this;
      }), define(Gp, "toString", function () {
        return "[object Generator]";
      }), exports.keys = function (val) {
        var object = Object(val),
          keys = [];
        for (var key in object) {
          keys.push(key);
        }
        return keys.reverse(), function next() {
          for (; keys.length;) {
            var key = keys.pop();
            if (key in object) return next.value = key, next.done = !1, next;
          }
          return next.done = !0, next;
        };
      }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {
            "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
          }
        },
        stop: function stop() {
          this.done = !0;
          var rootRecord = this.tryEntries[0].completion;
          if ("throw" === rootRecord.type) throw rootRecord.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(exception) {
          if (this.done) throw exception;
          var context = this;
          function handle(loc, caught) {
            return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
          }
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i],
              record = entry.completion;
            if ("root" === entry.tryLoc) return handle("end");
            if (entry.tryLoc <= this.prev) {
              var hasCatch = hasOwn.call(entry, "catchLoc"),
                hasFinally = hasOwn.call(entry, "finallyLoc");
              if (hasCatch && hasFinally) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              } else if (hasCatch) {
                if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
              } else {
                if (!hasFinally) throw new Error("try statement without catch or finally");
                if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(type, arg) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
              var finallyEntry = entry;
              break;
            }
          }
          finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
          var record = finallyEntry ? finallyEntry.completion : {};
          return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
          if ("throw" === record.type) throw record.arg;
          return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
          }
        },
        "catch": function _catch(tryLoc) {
          for (var i = this.tryEntries.length - 1; i >= 0; --i) {
            var entry = this.tryEntries[i];
            if (entry.tryLoc === tryLoc) {
              var record = entry.completion;
              if ("throw" === record.type) {
                var thrown = record.arg;
                resetTryEntry(entry);
              }
              return thrown;
            }
          }
          throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
          return this.delegate = {
            iterator: values(iterable),
            resultName: resultName,
            nextLoc: nextLoc
          }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
      }, exports;
    }
    module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;
  })(regeneratorRuntime$1);

  // TODO(Babel 8): Remove this file.

  var runtime = regeneratorRuntime$1.exports();
  var regenerator = runtime;

  // Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    if ((typeof globalThis === "undefined" ? "undefined" : _typeof$1(globalThis)) === "object") {
      globalThis.regeneratorRuntime = runtime;
    } else {
      Function("r", "regeneratorRuntime = r")(runtime);
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArrayLimit(arr, i) {
    var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
    if (_i == null) return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _s, _e;
    try {
      for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }
    return _arr;
  }

  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
    return arr2;
  }

  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _arrayLikeToArray$1(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen);
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return _arrayLikeToArray$1(arr);
  }

  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
  }

  var _a;
  var isClient = typeof window !== "undefined";
  var isDef = function isDef(val) {
    return typeof val !== "undefined";
  };
  var isString = function isString(val) {
    return typeof val === "string";
  };
  var noop = function noop() {};
  isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);
  function tryOnScopeDispose(fn) {
    if (vue.getCurrentScope()) {
      vue.onScopeDispose(fn);
      return true;
    }
    return false;
  }
  function tryOnMounted(fn) {
    var sync = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
    if (vue.getCurrentInstance()) vue.onMounted(fn);else if (sync) fn();else vue.nextTick(fn);
  }

  function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
  function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
  function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
  function unrefElement(elRef) {
    var _a;
    var plain = vue.unref(elRef);
    return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;
  }
  var defaultWindow = isClient ? window : void 0;
  function useEventListener() {
    var target;
    var event;
    var listener;
    var options;
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    if (isString(args[0])) {
      event = args[0];
      listener = args[1];
      options = args[2];
      target = defaultWindow;
    } else {
      target = args[0];
      event = args[1];
      listener = args[2];
      options = args[3];
    }
    if (!target) return noop;
    var _cleanup = noop;
    var stopWatch = vue.watch(function () {
      return unrefElement(target);
    }, function (el) {
      _cleanup();
      if (!el) return;
      el.addEventListener(event, listener, options);
      _cleanup = function cleanup() {
        el.removeEventListener(event, listener, options);
        _cleanup = noop;
      };
    }, {
      immediate: true,
      flush: "post"
    });
    var stop = function stop() {
      stopWatch();
      _cleanup();
    };
    tryOnScopeDispose(stop);
    return stop;
  }
  function onClickOutside(target, handler) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _options$window = options.window,
      window = _options$window === void 0 ? defaultWindow : _options$window,
      ignore = options.ignore,
      _options$capture = options.capture,
      capture = _options$capture === void 0 ? true : _options$capture,
      _options$detectIframe = options.detectIframe,
      detectIframe = _options$detectIframe === void 0 ? false : _options$detectIframe;
    if (!window) return;
    var shouldListen = vue.ref(true);
    var fallback;
    var listener = function listener(event) {
      window.clearTimeout(fallback);
      var el = unrefElement(target);
      var composedPath = event.composedPath();
      if (!el || el === event.target || composedPath.includes(el) || !shouldListen.value) return;
      if (ignore && ignore.length > 0) {
        if (ignore.some(function (target2) {
          var el2 = unrefElement(target2);
          return el2 && (event.target === el2 || composedPath.includes(el2));
        })) return;
      }
      handler(event);
    };
    var cleanup = [useEventListener(window, "click", listener, {
      passive: true,
      capture: capture
    }), useEventListener(window, "pointerdown", function (e) {
      var el = unrefElement(target);
      shouldListen.value = !!el && !e.composedPath().includes(el);
    }, {
      passive: true
    }), useEventListener(window, "pointerup", function (e) {
      if (e.button === 0) {
        var path = e.composedPath();
        e.composedPath = function () {
          return path;
        };
        fallback = window.setTimeout(function () {
          return listener(e);
        }, 50);
      }
    }, {
      passive: true
    }), detectIframe && useEventListener(window, "blur", function (event) {
      var _a;
      var el = unrefElement(target);
      if (((_a = document.activeElement) == null ? void 0 : _a.tagName) === "IFRAME" && !(el == null ? void 0 : el.contains(document.activeElement))) handler(event);
    })].filter(Boolean);
    var stop = function stop() {
      return cleanup.forEach(function (fn) {
        return fn();
      });
    };
    return stop;
  }
  function templateRef(key) {
    var initialValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var instance = vue.getCurrentInstance();
    var _trigger = function _trigger() {};
    var element = vue.customRef(function (track, trigger) {
      _trigger = trigger;
      return {
        get: function get() {
          var _a, _b;
          track();
          return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;
        },
        set: function set() {}
      };
    });
    tryOnMounted(_trigger);
    vue.onUpdated(_trigger);
    return element;
  }
  function useActiveElement() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _options$window2 = options.window,
      window = _options$window2 === void 0 ? defaultWindow : _options$window2;
    var counter = vue.ref(0);
    if (window) {
      useEventListener(window, "blur", function () {
        return counter.value += 1;
      }, true);
      useEventListener(window, "focus", function () {
        return counter.value += 1;
      }, true);
    }
    return vue.computed(function () {
      counter.value;
      return window == null ? void 0 : window.document.activeElement;
    });
  }
  var _global = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  var globalKey = "__vueuse_ssr_handlers__";
  _global[globalKey] = _global[globalKey] || {};
  _global[globalKey];
  var __getOwnPropSymbols$e = Object.getOwnPropertySymbols;
  var __hasOwnProp$e = Object.prototype.hasOwnProperty;
  var __propIsEnum$e = Object.prototype.propertyIsEnumerable;
  var __objRest$2 = function __objRest$2(source, exclude) {
    var target = {};
    for (var prop in source) {
      if (__hasOwnProp$e.call(source, prop) && exclude.indexOf(prop) < 0) target[prop] = source[prop];
    }
    if (source != null && __getOwnPropSymbols$e) {
      var _iterator10 = _createForOfIteratorHelper(__getOwnPropSymbols$e(source)),
        _step10;
      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var prop = _step10.value;
          if (exclude.indexOf(prop) < 0 && __propIsEnum$e.call(source, prop)) target[prop] = source[prop];
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
    }
    return target;
  };
  function useResizeObserver(target, callback) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var _a = options,
      _a$window = _a.window,
      window = _a$window === void 0 ? defaultWindow : _a$window,
      observerOptions = __objRest$2(_a, ["window"]);
    var observer;
    var isSupported = window && "ResizeObserver" in window;
    var cleanup = function cleanup() {
      if (observer) {
        observer.disconnect();
        observer = void 0;
      }
    };
    var stopWatch = vue.watch(function () {
      return unrefElement(target);
    }, function (el) {
      cleanup();
      if (isSupported && window && el) {
        observer = new ResizeObserver(callback);
        observer.observe(el, observerOptions);
      }
    }, {
      immediate: true,
      flush: "post"
    });
    var stop = function stop() {
      cleanup();
      stopWatch();
    };
    tryOnScopeDispose(stop);
    return {
      isSupported: isSupported,
      stop: stop
    };
  }
  function useElementBounding(target) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options$reset = options.reset,
      reset = _options$reset === void 0 ? true : _options$reset,
      _options$windowResize = options.windowResize,
      windowResize = _options$windowResize === void 0 ? true : _options$windowResize,
      _options$windowScroll = options.windowScroll,
      windowScroll = _options$windowScroll === void 0 ? true : _options$windowScroll,
      _options$immediate = options.immediate,
      immediate = _options$immediate === void 0 ? true : _options$immediate;
    var height = vue.ref(0);
    var bottom = vue.ref(0);
    var left = vue.ref(0);
    var right = vue.ref(0);
    var top = vue.ref(0);
    var width = vue.ref(0);
    var x = vue.ref(0);
    var y = vue.ref(0);
    function update() {
      var el = unrefElement(target);
      if (!el) {
        if (reset) {
          height.value = 0;
          bottom.value = 0;
          left.value = 0;
          right.value = 0;
          top.value = 0;
          width.value = 0;
          x.value = 0;
          y.value = 0;
        }
        return;
      }
      var rect = el.getBoundingClientRect();
      height.value = rect.height;
      bottom.value = rect.bottom;
      left.value = rect.left;
      right.value = rect.right;
      top.value = rect.top;
      width.value = rect.width;
      x.value = rect.x;
      y.value = rect.y;
    }
    useResizeObserver(target, update);
    vue.watch(function () {
      return unrefElement(target);
    }, function (ele) {
      return !ele && update();
    });
    if (windowScroll) useEventListener("scroll", update, {
      passive: true
    });
    if (windowResize) useEventListener("resize", update, {
      passive: true
    });
    tryOnMounted(function () {
      if (immediate) update();
    });
    return {
      height: height,
      bottom: bottom,
      left: left,
      right: right,
      top: top,
      width: width,
      x: x,
      y: y,
      update: update
    };
  }
  function useRafFn(fn) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options$immediate2 = options.immediate,
      immediate = _options$immediate2 === void 0 ? true : _options$immediate2,
      _options$window11 = options.window,
      window = _options$window11 === void 0 ? defaultWindow : _options$window11;
    var isActive = vue.ref(false);
    var rafId = null;
    function loop() {
      if (!isActive.value || !window) return;
      fn();
      rafId = window.requestAnimationFrame(loop);
    }
    function resume() {
      if (!isActive.value && window) {
        isActive.value = true;
        loop();
      }
    }
    function pause() {
      isActive.value = false;
      if (rafId != null && window) {
        window.cancelAnimationFrame(rafId);
        rafId = null;
      }
    }
    if (immediate) resume();
    tryOnScopeDispose(pause);
    return {
      isActive: isActive,
      pause: pause,
      resume: resume
    };
  }
  function useElementSize(target) {
    var initialSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
      width: 0,
      height: 0
    };
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var width = vue.ref(initialSize.width);
    var height = vue.ref(initialSize.height);
    useResizeObserver(target, function (_ref16) {
      var _ref17 = _slicedToArray(_ref16, 1),
        entry = _ref17[0];
      width.value = entry.contentRect.width;
      height.value = entry.contentRect.height;
    }, options);
    vue.watch(function () {
      return unrefElement(target);
    }, function (ele) {
      width.value = ele ? initialSize.width : 0;
      height.value = ele ? initialSize.height : 0;
    });
    return {
      width: width,
      height: height
    };
  }
  function useFocus(target) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options$initialValue2 = options.initialValue,
      initialValue = _options$initialValue2 === void 0 ? false : _options$initialValue2;
    var activeElement = useActiveElement(options);
    var targetElement = vue.computed(function () {
      return unrefElement(target);
    });
    var focused = vue.computed({
      get: function get() {
        return isDef(activeElement.value) && isDef(targetElement.value) && activeElement.value === targetElement.value;
      },
      set: function set(value) {
        var _a, _b;
        if (!value && focused.value) (_a = targetElement.value) == null ? void 0 : _a.blur();
        if (value && !focused.value) (_b = targetElement.value) == null ? void 0 : _b.focus();
      }
    });
    vue.watch(targetElement, function () {
      focused.value = initialValue;
    }, {
      immediate: true,
      flush: "post"
    });
    return {
      focused: focused
    };
  }
  function useIntersectionObserver(target, callback) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var root = options.root,
      _options$rootMargin = options.rootMargin,
      rootMargin = _options$rootMargin === void 0 ? "0px" : _options$rootMargin,
      _options$threshold = options.threshold,
      threshold = _options$threshold === void 0 ? 0.1 : _options$threshold,
      _options$window13 = options.window,
      window = _options$window13 === void 0 ? defaultWindow : _options$window13;
    var isSupported = window && "IntersectionObserver" in window;
    var _cleanup2 = noop;
    var stopWatch = isSupported ? vue.watch(function () {
      return {
        el: unrefElement(target),
        root: unrefElement(root)
      };
    }, function (_ref25) {
      var el = _ref25.el,
        root2 = _ref25.root;
      _cleanup2();
      if (!el) return;
      var observer = new IntersectionObserver(callback, {
        root: root2,
        rootMargin: rootMargin,
        threshold: threshold
      });
      observer.observe(el);
      _cleanup2 = function cleanup() {
        observer.disconnect();
        _cleanup2 = noop;
      };
    }, {
      immediate: true,
      flush: "post"
    }) : noop;
    var stop = function stop() {
      _cleanup2();
      stopWatch();
    };
    tryOnScopeDispose(stop);
    return {
      isSupported: isSupported,
      stop: stop
    };
  }
  var SwipeDirection;
  (function (SwipeDirection2) {
    SwipeDirection2["UP"] = "UP";
    SwipeDirection2["RIGHT"] = "RIGHT";
    SwipeDirection2["DOWN"] = "DOWN";
    SwipeDirection2["LEFT"] = "LEFT";
    SwipeDirection2["NONE"] = "NONE";
  })(SwipeDirection || (SwipeDirection = {}));
  function useSwipe(target) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var _options$threshold2 = options.threshold,
      threshold = _options$threshold2 === void 0 ? 50 : _options$threshold2,
      onSwipe = options.onSwipe,
      onSwipeEnd = options.onSwipeEnd,
      onSwipeStart = options.onSwipeStart,
      _options$passive3 = options.passive,
      passive = _options$passive3 === void 0 ? true : _options$passive3,
      _options$window22 = options.window,
      window = _options$window22 === void 0 ? defaultWindow : _options$window22;
    var coordsStart = vue.reactive({
      x: 0,
      y: 0
    });
    var coordsEnd = vue.reactive({
      x: 0,
      y: 0
    });
    var diffX = vue.computed(function () {
      return coordsStart.x - coordsEnd.x;
    });
    var diffY = vue.computed(function () {
      return coordsStart.y - coordsEnd.y;
    });
    var max = Math.max,
      abs = Math.abs;
    var isThresholdExceeded = vue.computed(function () {
      return max(abs(diffX.value), abs(diffY.value)) >= threshold;
    });
    var isSwiping = vue.ref(false);
    var direction = vue.computed(function () {
      if (!isThresholdExceeded.value) return SwipeDirection.NONE;
      if (abs(diffX.value) > abs(diffY.value)) {
        return diffX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;
      } else {
        return diffY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;
      }
    });
    var getTouchEventCoords = function getTouchEventCoords(e) {
      return [e.touches[0].clientX, e.touches[0].clientY];
    };
    var updateCoordsStart = function updateCoordsStart(x, y) {
      coordsStart.x = x;
      coordsStart.y = y;
    };
    var updateCoordsEnd = function updateCoordsEnd(x, y) {
      coordsEnd.x = x;
      coordsEnd.y = y;
    };
    var listenerOptions;
    var isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);
    if (!passive) listenerOptions = isPassiveEventSupported ? {
      passive: false,
      capture: true
    } : {
      capture: true
    };else listenerOptions = isPassiveEventSupported ? {
      passive: true
    } : {
      capture: false
    };
    var onTouchEnd = function onTouchEnd(e) {
      if (isSwiping.value) onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);
      isSwiping.value = false;
    };
    var stops = [useEventListener(target, "touchstart", function (e) {
      if (listenerOptions.capture && !listenerOptions.passive) e.preventDefault();
      var _getTouchEventCoords = getTouchEventCoords(e),
        _getTouchEventCoords2 = _slicedToArray(_getTouchEventCoords, 2),
        x = _getTouchEventCoords2[0],
        y = _getTouchEventCoords2[1];
      updateCoordsStart(x, y);
      updateCoordsEnd(x, y);
      onSwipeStart == null ? void 0 : onSwipeStart(e);
    }, listenerOptions), useEventListener(target, "touchmove", function (e) {
      var _getTouchEventCoords3 = getTouchEventCoords(e),
        _getTouchEventCoords4 = _slicedToArray(_getTouchEventCoords3, 2),
        x = _getTouchEventCoords4[0],
        y = _getTouchEventCoords4[1];
      updateCoordsEnd(x, y);
      if (!isSwiping.value && isThresholdExceeded.value) isSwiping.value = true;
      if (isSwiping.value) onSwipe == null ? void 0 : onSwipe(e);
    }, listenerOptions), useEventListener(target, "touchend", onTouchEnd, listenerOptions), useEventListener(target, "touchcancel", onTouchEnd, listenerOptions)];
    var stop = function stop() {
      return stops.forEach(function (s) {
        return s();
      });
    };
    return {
      isPassiveEventSupported: isPassiveEventSupported,
      isSwiping: isSwiping,
      direction: direction,
      coordsStart: coordsStart,
      coordsEnd: coordsEnd,
      lengthX: diffX,
      lengthY: diffY,
      stop: stop
    };
  }
  function checkPassiveEventSupport(document) {
    if (!document) return false;
    var supportsPassive = false;
    var optionsBlock = {
      get passive() {
        supportsPassive = true;
        return false;
      }
    };
    document.addEventListener("x", noop, optionsBlock);
    document.removeEventListener("x", noop);
    return supportsPassive;
  }
  function useWindowSize() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var _options$window33 = options.window,
      window = _options$window33 === void 0 ? defaultWindow : _options$window33,
      _options$initialWidth = options.initialWidth,
      initialWidth = _options$initialWidth === void 0 ? Infinity : _options$initialWidth,
      _options$initialHeigh = options.initialHeight,
      initialHeight = _options$initialHeigh === void 0 ? Infinity : _options$initialHeigh,
      _options$listenOrient = options.listenOrientation,
      listenOrientation = _options$listenOrient === void 0 ? true : _options$listenOrient;
    var width = vue.ref(initialWidth);
    var height = vue.ref(initialHeight);
    var update = function update() {
      if (window) {
        width.value = window.innerWidth;
        height.value = window.innerHeight;
      }
    };
    update();
    tryOnMounted(update);
    useEventListener("resize", update, {
      passive: true
    });
    if (listenOrientation) useEventListener("orientationchange", update, {
      passive: true
    });
    return {
      width: width,
      height: height
    };
  }

  var getRemainTimes = function getRemainTimes(time) {
    if (!time) {
      return {
        days: 0,
        hours: 0,
        minutes: 0,
        seconds: 0,
        milliseconds: 0
      };
    }
    var stime = Math.floor(time / 1e3);
    return {
      days: Math.floor(stime / 3600 / 24),
      hours: Math.floor(stime / 3600 % 24),
      minutes: Math.floor(stime / 60 % 60),
      seconds: stime % 60,
      milliseconds: time % 1e3
    };
  };
  var fillZero = function fillZero(num) {
    var isMillieconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    if (isMillieconds) {
      if (num >= 100) {
        return num;
      }
      return num >= 10 ? "0".concat(num) : "00".concat(num);
    }
    return num >= 10 ? num : "0".concat(num);
  };
  var getMark = function getMark(format, type) {
    var _format$split, _format$split$call, _format$split$call$, _format$split$call$$s, _format$split$call$$s2;
    return format === null || format === void 0 ? void 0 : (_format$split = format.split) === null || _format$split === void 0 ? void 0 : (_format$split$call = _format$split.call(format, type)) === null || _format$split$call === void 0 ? void 0 : (_format$split$call$ = _format$split$call[1]) === null || _format$split$call$ === void 0 ? void 0 : (_format$split$call$$s = _format$split$call$.split) === null || _format$split$call$$s === void 0 ? void 0 : (_format$split$call$$s2 = _format$split$call$$s.call(_format$split$call$, "")) === null || _format$split$call$$s2 === void 0 ? void 0 : _format$split$call$$s2[0];
  };
  var getShowTimes = function getShowTimes(times, format) {
    var _ref, _ref$toUpperCase, _format, _format2, _format3, _format4, _format5;
    var milliseconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
    format = (_ref = format || "DD:HH:mm:ss") === null || _ref === void 0 ? void 0 : (_ref$toUpperCase = _ref.toUpperCase) === null || _ref$toUpperCase === void 0 ? void 0 : _ref$toUpperCase.call(_ref);
    milliseconds && !format.includes(":SSS") && (format = format.concat(":SSS"));
    var showTimes = [];
    if (((_format = format) === null || _format === void 0 ? void 0 : _format.indexOf("DD")) > -1) {
      showTimes === null || showTimes === void 0 ? void 0 : showTimes.push({
        mark: getMark(format, "DD"),
        value: fillZero(times === null || times === void 0 ? void 0 : times.days)
      });
    }
    if (((_format2 = format) === null || _format2 === void 0 ? void 0 : _format2.indexOf("HH")) > -1) {
      showTimes === null || showTimes === void 0 ? void 0 : showTimes.push({
        mark: getMark(format, "HH"),
        value: fillZero(times === null || times === void 0 ? void 0 : times.hours)
      });
    }
    if (((_format3 = format) === null || _format3 === void 0 ? void 0 : _format3.indexOf("MM")) > -1) {
      showTimes === null || showTimes === void 0 ? void 0 : showTimes.push({
        mark: getMark(format, "MM"),
        value: fillZero(times === null || times === void 0 ? void 0 : times.minutes)
      });
    }
    if (((_format4 = format) === null || _format4 === void 0 ? void 0 : _format4.indexOf("SS")) > -1) {
      showTimes === null || showTimes === void 0 ? void 0 : showTimes.push({
        mark: getMark(format, "SS"),
        value: fillZero(times === null || times === void 0 ? void 0 : times.seconds)
      });
    }
    if (((_format5 = format) === null || _format5 === void 0 ? void 0 : _format5.indexOf("SSS")) > -1) {
      showTimes === null || showTimes === void 0 ? void 0 : showTimes.push({
        mark: getMark(format, "SSS"),
        value: fillZero(times === null || times === void 0 ? void 0 : times.milliseconds, true)
      });
    }
    return showTimes;
  };
  var getScreenFps = function () {
    var _ref2, _ref2$find;
    var _window = window,
      requestAnimationFrame = _window.requestAnimationFrame,
      mozRequestAnimationFrame = _window.mozRequestAnimationFrame,
      webkitRequestAnimationFrame = _window.webkitRequestAnimationFrame;
    var nextFrame = (_ref2 = [requestAnimationFrame, mozRequestAnimationFrame, webkitRequestAnimationFrame]) === null || _ref2 === void 0 ? void 0 : (_ref2$find = _ref2.find) === null || _ref2$find === void 0 ? void 0 : _ref2$find.call(_ref2, function (fn) {
      return fn;
    });
    if (!nextFrame) {
      console.error("requestAnimationFrame is not supported!");
      return;
    }
    return function () {
      var targetCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
      if (targetCount < 1) {
        return;
      }
      var count = 0;
      var beginDate = Date.now();
      return new Promise(function (resolve) {
        (function log() {
          nextFrame === null || nextFrame === void 0 ? void 0 : nextFrame(function () {
            if (++count >= targetCount) {
              var diffDate = Date.now() - beginDate;
              var fps = count / diffDate * 1e3;
              return resolve(fps);
            }
            log();
          });
        })();
      });
    };
  }();

  function useCountDown(props) {
    var _ref = props || {},
      _ref$time = _ref.time,
      time = _ref$time === void 0 ? 0 : _ref$time,
      autoStart = _ref.autoStart,
      millisecond = _ref.millisecond,
      _ref$format = _ref.format,
      format = _ref$format === void 0 ? "HH:mm:ss" : _ref$format,
      onFinish = _ref.onFinish,
      onChange = _ref.onChange;
    var fps = vue.ref();
    var count = vue.ref(Number(time));
    var showTimes = vue.reactive(getShowTimes(getRemainTimes(time), format, !!millisecond));
    var _useRafFn = useRafFn( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
        var _getShowTimes, _getShowTimes$forEach;
        var res, times;
        return regenerator.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                if (fps.value) {
                  _context.next = 5;
                  break;
                }
                _context.next = 3;
                return getScreenFps === null || getScreenFps === void 0 ? void 0 : getScreenFps();
              case 3:
                res = _context.sent;
                fps.value = res || 60;
              case 5:
                count.value = parseInt("".concat(Number(count.value) - 1e3 / fps.value), 10);
                if (count.value <= 0) {
                  pause === null || pause === void 0 ? void 0 : pause();
                  count.value = 0;
                }
                times = getRemainTimes(count.value);
                onChange === null || onChange === void 0 ? void 0 : onChange(times);
                count.value === 0 && (onFinish === null || onFinish === void 0 ? void 0 : onFinish());
                (_getShowTimes = getShowTimes(times, format)) === null || _getShowTimes === void 0 ? void 0 : (_getShowTimes$forEach = _getShowTimes.forEach) === null || _getShowTimes$forEach === void 0 ? void 0 : _getShowTimes$forEach.call(_getShowTimes, function (i, idx) {
                  return showTimes[idx].value = i === null || i === void 0 ? void 0 : i.value;
                });
              case 11:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })), {
        immediate: autoStart
      }),
      pause = _useRafFn.pause,
      resume = _useRafFn.resume;
    return {
      time: count,
      showTimes: showTimes,
      pause: pause,
      resume: resume
    };
  }

  function getDefaultName(key) {
    var str = camelCase_1(key);
    return "default".concat(str[0].toLocaleUpperCase() + str.slice(1));
  }
  function getEventPropsName(eventName) {
    var str = camelCase_1(eventName);
    return "on".concat(str[0].toLocaleUpperCase()).concat(str.slice(1));
  }
  function useDefault(props, emit, key, eventName) {
    var modelValue = "modelValue";
    var defaultName = getDefaultName(String(key));
    var isUsedModelValue = props[modelValue] !== void 0;
    var isUsedKey = props[key] !== void 0;
    var innerValue = vue.ref();
    if (isUsedKey) {
      innerValue.value = props[key];
    } else if (isUsedModelValue) {
      innerValue.value = props[modelValue];
    } else {
      innerValue.value = props[defaultName];
    }
    vue.watchEffect(function () {
      if (isUsedModelValue) {
        innerValue.value = props[modelValue];
      }
      if (isUsedKey) {
        innerValue.value = props[key];
      }
    });
    function emitEvents(value) {
      var _props$propsEventName;
      for (var _len = arguments.length, arg = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        arg[_key - 1] = arguments[_key];
      }
      var updateKeys = ["update:".concat(key)];
      if (isUsedModelValue) {
        updateKeys.push("update:modelValue");
      }
      updateKeys.forEach(function (updateKey) {
        emit.apply(void 0, [updateKey, value].concat(arg));
      });
      var propsEventName = getEventPropsName(eventName);
      (_props$propsEventName = props[propsEventName]) === null || _props$propsEventName === void 0 ? void 0 : _props$propsEventName.call.apply(_props$propsEventName, [props, value].concat(arg));
    }
    function setInnerValue(value) {
      if (!isUsedKey && !isUsedModelValue) {
        innerValue.value = value;
      }
      for (var _len2 = arguments.length, arg = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        arg[_key2 - 1] = arguments[_key2];
      }
      emitEvents.apply(void 0, [value].concat(arg));
    }
    var innerValueRef = vue.computed({
      get: function get() {
        return innerValue.value;
      },
      set: function set(value) {
        setInnerValue(value);
      }
    });
    return [innerValueRef, setInnerValue];
  }

  function useEmitEvent(props, emit) {
    return function emitEvent(eventName) {
      var emitEventMethodName = "";
      if (typeof eventName === "string") {
        emitEventMethodName = camelCase_1("on-".concat(eventName));
      }
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      if (typeof props[emitEventMethodName] === "function") {
        props[emitEventMethodName].apply(props, args);
      } else {
        emit.apply(void 0, [eventName].concat(args));
      }
    };
  }

  function useChildSlots(childComponentName, childInSlots) {
    var recurChildren = function recurChildren(children) {
      var result = [];
      if (Array.isArray(children)) {
        children.forEach(function (child) {
          if (vue.isVNode(child)) {
            var _child$component;
            result.push(child);
            if ((_child$component = child.component) !== null && _child$component !== void 0 && _child$component.subTree) {
              result.push(child.component.subTree);
              result.push.apply(result, _toConsumableArray(recurChildren(child.component.subTree.children)));
            }
            if (child.children) {
              result.push.apply(result, _toConsumableArray(recurChildren(child.children)));
            }
          }
        });
      }
      return result;
    };
    var targetChildren = [];
    if (childInSlots !== void 0) {
      targetChildren.push.apply(targetChildren, _toConsumableArray(recurChildren(childInSlots)));
    } else {
      var _getCurrentInstance;
      targetChildren.push.apply(targetChildren, _toConsumableArray(recurChildren((_getCurrentInstance = vue.getCurrentInstance()) === null || _getCurrentInstance === void 0 ? void 0 : _getCurrentInstance.subTree.children)));
    }
    return targetChildren.filter(function (child) {
      var _child$type;
      return ((_child$type = child.type) === null || _child$type === void 0 ? void 0 : _child$type.name) === childComponentName;
    });
  }

  function useVModel(value, modelValue, defaultValue, onChange) {
    var propName = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : "value";
    var _getCurrentInstance = vue.getCurrentInstance(),
      emit = _getCurrentInstance.emit;
    var internalValue = vue.ref();
    internalValue.value = defaultValue;
    if (typeof value.value !== "undefined") {
      return [value, function (newValue) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        emit === null || emit === void 0 ? void 0 : emit.apply(void 0, ["update:".concat(propName), newValue].concat(args));
        onChange === null || onChange === void 0 ? void 0 : onChange.apply(void 0, [newValue].concat(args));
      }];
    }
    if (typeof modelValue.value !== "undefined") {
      return [modelValue, function (newValue) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        emit === null || emit === void 0 ? void 0 : emit.apply(void 0, ["update:modelValue", newValue].concat(args));
        onChange === null || onChange === void 0 ? void 0 : onChange.apply(void 0, [newValue].concat(args));
      }];
    }
    return [internalValue, function (newValue) {
      internalValue.value = newValue;
      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }
      onChange === null || onChange === void 0 ? void 0 : onChange.apply(void 0, [newValue].concat(args));
    }];
  }

  function getDirection(x, y) {
    if (x > y) {
      return "horizontal";
    }
    if (y > x) {
      return "vertical";
    }
    return "";
  }
  function useTouch$1() {
    var startX = vue.ref(0);
    var startY = vue.ref(0);
    var deltaX = vue.ref(0);
    var deltaY = vue.ref(0);
    var offsetX = vue.ref(0);
    var offsetY = vue.ref(0);
    var direction = vue.ref("");
    var isVertical = function isVertical() {
      return direction.value === "vertical";
    };
    var isHorizontal = function isHorizontal() {
      return direction.value === "horizontal";
    };
    var reset = function reset() {
      deltaX.value = 0;
      deltaY.value = 0;
      offsetX.value = 0;
      offsetY.value = 0;
      direction.value = "";
    };
    var start = function start(event) {
      reset();
      startX.value = event.touches[0].clientX;
      startY.value = event.touches[0].clientY;
    };
    var move = function move(event) {
      var touch = event.touches[0];
      deltaX.value = (touch.clientX < 0 ? 0 : touch.clientX) - startX.value;
      deltaY.value = touch.clientY - startY.value;
      offsetX.value = Math.abs(deltaX.value);
      offsetY.value = Math.abs(deltaY.value);
      var LOCK_DIRECTION_DISTANCE = 10;
      if (!direction.value || offsetX.value < LOCK_DIRECTION_DISTANCE && offsetY.value < LOCK_DIRECTION_DISTANCE) {
        direction.value = getDirection(offsetX.value, offsetY.value);
      }
    };
    return {
      move: move,
      start: start,
      reset: reset,
      startX: startX,
      startY: startY,
      deltaX: deltaX,
      deltaY: deltaY,
      offsetX: offsetX,
      offsetY: offsetY,
      direction: direction,
      isVertical: isVertical,
      isHorizontal: isHorizontal
    };
  }

  var overflowScrollReg = /scroll|auto/i;
  var defaultRoot = inBrowser ? window : void 0;
  function isElement$1(node) {
    var ELEMENT_NODE_TYPE = 1;
    return node.tagName !== "HTML" && node.tagName !== "BODY" && node.nodeType === ELEMENT_NODE_TYPE;
  }
  function getScrollParent$1(el) {
    var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultRoot;
    var node = el;
    while (node && node !== root && isElement$1(node)) {
      var _window$getComputedSt = window.getComputedStyle(node),
        overflowY = _window$getComputedSt.overflowY;
      if (overflowScrollReg.test(overflowY)) {
        return node;
      }
      node = node.parentNode;
    }
    return root;
  }
  function useScrollParent(el) {
    var root = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : defaultRoot;
    var scrollParent = vue.ref();
    vue.onMounted(function () {
      if (el.value) {
        scrollParent.value = getScrollParent$1(el.value, root);
      }
    });
    return scrollParent;
  }

  function useExpose(apis) {
    var instance = vue.getCurrentInstance();
    if (instance) {
      Object.assign(instance.proxy, apis);
    }
  }

  var ButtonProps = {
    block: Boolean,
    content: {
      type: [String, Function]
    },
    disabled: Boolean,
    ghost: Boolean,
    icon: {
      type: Function
    },
    loading: Boolean,
    shape: {
      type: String,
      default: "rectangle",
      validator: function validator(val) {
        if (!val) return true;
        return ["rectangle", "square", "round", "circle"].includes(val);
      }
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator(val) {
        if (!val) return true;
        return ["small", "medium", "large"].includes(val);
      }
    },
    theme: {
      type: String,
      default: "default",
      validator: function validator(val) {
        if (!val) return true;
        return ["default", "primary", "danger"].includes(val);
      }
    },
    variant: {
      type: String,
      default: "base",
      validator: function validator(val) {
        if (!val) return true;
        return ["base", "outline", "text"].includes(val);
      }
    },
    onClick: Function
  };

  function ownKeys$L(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$L(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$L(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$L(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$16 = config.prefix;
  var name$11 = "".concat(prefix$16, "-button");
  var loadingContent = vue.h(loading);
  var script$19 = vue.defineComponent({
    name: name$11,
    components: {
      TNode: TNodeComponent
    },
    props: ButtonProps,
    emits: ["click"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var buttonClass = vue.computed(function () {
        var _ref;
        return ["".concat(name$11), props.size ? ClASSNAMES.SIZE[props.size] : "", "".concat(name$11, "--").concat(props.variant), (_ref = {}, _defineProperty$2(_ref, "".concat(name$11, "--").concat(props.theme), props.theme), _defineProperty$2(_ref, "".concat(name$11, "--shape-").concat(props.shape), props.shape), _defineProperty$2(_ref, "".concat(name$11, "--ghost"), props.ghost), _defineProperty$2(_ref, "".concat(prefix$16, "-is-block"), props.block), _defineProperty$2(_ref, ClASSNAMES.STATUS.disabled, props.disabled), _defineProperty$2(_ref, ClASSNAMES.STATUS.loading, props.loading), _ref)];
      });
      var buttonContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var iconContent = vue.computed(function () {
        return props.loading ? loadingContent : renderTNode(internalInstance, "icon");
      });
      var onClick = function onClick(e) {
        if (!props.loading && !props.disabled) {
          emitEvent("click", e);
        } else {
          e.stopPropagation();
        }
      };
      return _objectSpread$L(_objectSpread$L({
        name: name$11
      }, vue.toRefs(props)), {}, {
        buttonContent: buttonContent,
        iconContent: iconContent,
        buttonClass: buttonClass,
        onClick: onClick
      });
    }
  });

  var _hoisted_1$r = ["disabled", "aria-disabled"];
  function render$17(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("button", {
      class: vue.normalizeClass(_ctx.buttonClass),
      disabled: _ctx.disabled,
      role: "button",
      "aria-disabled": _ctx.disabled,
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.onClick && _ctx.onClick.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"]), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, "__text"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.buttonContent
    }, null, 8, ["content"])], 2)], 10, _hoisted_1$r);
  }

  script$19.render = render$17;

  var _Button = withInstall(script$19);

  var prefix$15 = config.prefix;
  var name$10 = "".concat(prefix$15, "-button-group");
  var script$18 = vue.defineComponent({
    name: name$10,
    props: {
      type: {
        type: String,
        default: "default"
      }
    },
    setup: function setup(props) {
      var classes = vue.computed(function () {
        return ["".concat(name$10), "".concat(name$10, "--").concat(props.type)];
      });
      return {
        classes: classes
      };
    }
  });

  function render$16(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [vue.renderSlot(_ctx.$slots, "default")], 2);
  }

  script$18.render = render$16;

  var _ButtonGroup = withInstall(script$18);

  var DividerProps = {
    align: {
      type: String,
      default: "center",
      validator: function validator(val) {
        if (!val) return true;
        return ["left", "right", "center"].includes(val);
      }
    },
    content: {
      type: [String, Function]
    },
    dashed: Boolean,
    default: {
      type: [String, Function]
    },
    layout: {
      type: String,
      default: "horizontal",
      validator: function validator(val) {
        if (!val) return true;
        return ["horizontal", "vertical"].includes(val);
      }
    },
    lineColor: {
      type: String,
      default: ""
    }
  };

  function ownKeys$K(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$K(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$K(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$K(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$14 = config.prefix;
  var name$$ = "".concat(prefix$14, "-divider");
  var script$17 = vue.defineComponent({
    name: name$$,
    components: {
      TNode: TNodeComponent
    },
    props: DividerProps,
    setup: function setup(props) {
      var internalInstance = vue.getCurrentInstance();
      var dividerContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var dividerClass = vue.computed(function () {
        var _ref;
        return ["".concat(name$$), "".concat(name$$, "--hairline"), (_ref = {}, _defineProperty$2(_ref, "".concat(name$$, "--content-").concat(props.align), dividerContent.value), _defineProperty$2(_ref, "".concat(name$$, "--dashed"), props.dashed), _defineProperty$2(_ref, "".concat(name$$, "-vertical"), props.layout === "vertical"), _ref)];
      });
      return _objectSpread$K(_objectSpread$K({}, vue.toRefs(props)), {}, {
        dividerContent: dividerContent,
        dividerClass: dividerClass
      });
    }
  });

  function render$15(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      role: "separator",
      class: vue.normalizeClass(_ctx.dividerClass),
      style: vue.normalizeStyle("border-color:".concat(_ctx.lineColor))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.dividerContent
    }, null, 8, ["content"])], 6);
  }

  script$17.render = render$15;

  var Divider = withInstall(script$17);

  var popupProps = {
    closeOnOverlayClick: {
      type: Boolean,
      default: true
    },
    customStyle: {
      type: String,
      default: ""
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    overlayProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    placement: {
      type: String,
      default: "top",
      validator: function validator(val) {
        if (!val) return true;
        return ["top", "left", "right", "bottom", "center"].includes(val);
      }
    },
    showOverlay: {
      type: Boolean,
      default: true
    },
    to: String,
    transitionName: {
      type: String,
      default: ""
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: Boolean,
    zIndex: {
      type: Number
    },
    onClose: Function,
    onClosed: Function,
    onOpen: Function,
    onOpened: Function,
    onVisibleChange: Function
  };

  var props$6 = {
    duration: {
      type: Number,
      default: 300
    },
    preventScrollThrough: {
      type: Boolean,
      default: true
    },
    transparent: Boolean,
    visible: {
      type: Boolean,
      default: true,
      required: true
    },
    zIndex: {
      type: Number,
      default: 1e3
    },
    customStyle: {
      type: String,
      default: ""
    },
    onClick: Function
  };

  var prefix$13 = config.prefix;
  var name$_ = "".concat(prefix$13, "-overlay");
  var script$16 = vue.defineComponent({
    name: name$_,
    props: props$6,
    setup: function setup(props2) {
      var classes = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$_), true), _defineProperty$2(_ref, "".concat(name$_, "--active"), props2.visible), _defineProperty$2(_ref, "".concat(name$_, "--transparent"), props2.transparent), _ref;
      });
      var rootStyles = vue.computed(function () {
        return props2.customStyle || props2.zIndex || props2.duration ? (props2.customStyle && "".concat(props2.customStyle, ";")) + (props2.zIndex && "z-index:".concat(props2.zIndex, ";")) + (props2.duration && "transition-duration:".concat(props2.duration, "ms;")) : void 0;
      });
      var handleTouchMove = function handleTouchMove(e) {
        if (props2.preventScrollThrough) {
          e.stopPropagation();
          e.preventDefault();
        }
      };
      var handleClick = function handleClick(e) {
        var _props2$onClick;
        (_props2$onClick = props2.onClick) === null || _props2$onClick === void 0 ? void 0 : _props2$onClick.call(props2, {
          e: e
        });
      };
      return {
        name: name$_,
        classes: classes,
        rootStyles: rootStyles,
        handleClick: handleClick,
        handleTouchMove: handleTouchMove
      };
    }
  });

  function render$14(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createBlock(vue.Transition, {
      name: _ctx.name
    }, {
      default: vue.withCtx(function () {
        return [vue.withDirectives(vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.classes),
          style: vue.normalizeStyle(_ctx.rootStyles),
          onClick: _cache[0] || (_cache[0] = function () {
            return _ctx.handleClick && _ctx.handleClick.apply(_ctx, arguments);
          }),
          onTouchmove: _cache[1] || (_cache[1] = function () {
            return _ctx.handleTouchMove && _ctx.handleTouchMove.apply(_ctx, arguments);
          })
        }, [vue.renderSlot(_ctx.$slots, "default")], 38), [[vue.vShow, _ctx.visible]])];
      }),
      _: 3
    }, 8, ["name"]);
  }

  script$16.render = render$14;

  var Overlay = withInstall(script$16);

  var prefix$12 = config.prefix;
  var name$Z = "".concat(prefix$12, "-popup");
  var script$15 = vue.defineComponent({
    name: name$Z,
    components: {
      TOverlay: Overlay
    },
    props: popupProps,
    emits: ["open", "close", "opened", "closed", "visible-change", "update:visible", "update:modelValue"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var _useDefault = useDefault(props, context.emit, "visible", "visible-change"),
        _useDefault2 = _slicedToArray(_useDefault, 1),
        currentVisible = _useDefault2[0];
      var rootClasses = vue.computed(function () {
        return name$Z;
      });
      var rootStyles = vue.computed(function () {
        return props.customStyle || props.zIndex ? (props.customStyle && "".concat(props.customStyle, ";")) + (props.zIndex && "z-index:".concat(props.zIndex, ";")) : void 0;
      });
      var contentClasses = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$Z, "--content"), true), _defineProperty$2(_ref, "".concat(name$Z, "--content-").concat(props.placement), true), _ref;
      });
      var contentTransitionName = vue.computed(function () {
        var transitionName = props.transitionName,
          placement = props.placement;
        if (transitionName) return transitionName;
        if (placement === "center") return "fade-zoom";
        return "slide-".concat(placement);
      });
      vue.watch(function () {
        return currentVisible.value;
      }, function (val) {
        var cls = "".concat(prefix$12, "-overflow-hidden");
        if (val) {
          document.body.classList.add(cls);
          emitEvent("open");
          currentVisible.value = true;
        } else {
          document.body.classList.remove(cls);
        }
      });
      var handleOverlayClick = function handleOverlayClick() {
        if (!props.closeOnOverlayClick) {
          return;
        }
        emitEvent("close");
        currentVisible.value = false;
      };
      var handleMove = function handleMove(e) {
        if (props.lockScroll) {
          e.preventDefault();
        }
      };
      var afterLeave = function afterLeave() {
        return emitEvent("closed");
      };
      var afterEnter = function afterEnter() {
        return emitEvent("opened");
      };
      return {
        name: vue.ref(name$Z),
        currentVisible: currentVisible,
        rootClasses: rootClasses,
        rootStyles: rootStyles,
        contentClasses: contentClasses,
        contentTransitionName: contentTransitionName,
        afterEnter: afterEnter,
        afterLeave: afterLeave,
        handleOverlayClick: handleOverlayClick,
        handleMove: handleMove
      };
    }
  });

  function render$13(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_overlay = vue.resolveComponent("t-overlay");
    return vue.openBlock(), vue.createBlock(vue.Teleport, {
      to: _ctx.to,
      disabled: !_ctx.to
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass([_ctx.rootClasses, _ctx.$attrs.class]),
      style: vue.normalizeStyle(_ctx.rootStyles),
      onTouchmove: _cache[0] || (_cache[0] = function () {
        return _ctx.handleMove && _ctx.handleMove.apply(_ctx, arguments);
      })
    }, [vue.createVNode(vue.Transition, {
      name: "fade"
    }, {
      default: vue.withCtx(function () {
        return [vue.createVNode(_component_t_overlay, vue.mergeProps(_ctx.overlayProps, {
          visible: _ctx.currentVisible,
          transparent: !_ctx.showOverlay,
          onClick: _ctx.handleOverlayClick
        }), null, 16, ["visible", "transparent", "onClick"])];
      }),
      _: 1
    }), vue.createVNode(vue.Transition, {
      name: _ctx.contentTransitionName,
      onAfterEnter: _ctx.afterEnter,
      onAfterLeave: _ctx.afterLeave
    }, {
      default: vue.withCtx(function () {
        return [vue.withDirectives(vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.contentClasses)
        }, [vue.renderSlot(_ctx.$slots, "default")], 2), [[vue.vShow, _ctx.currentVisible]])];
      }),
      _: 3
    }, 8, ["name", "onAfterEnter", "onAfterLeave"])], 38)], 8, ["to", "disabled"]);
  }

  script$15.render = render$13;

  var _Popup = withInstall(script$15);

  var calendarProps = {
    confirmBtn: {
      type: [String, Object, Function],
      default: ""
    },
    firstDayOfWeek: {
      type: Number,
      default: 0
    },
    format: {
      type: Function
    },
    maxDate: {
      type: [Number, Date]
    },
    minDate: {
      type: [Number, Date]
    },
    title: {
      type: [String, Function]
    },
    type: {
      type: String,
      default: "single",
      validator: function validator(val) {
        if (!val) return true;
        return ["single", "multiple", "range"].includes(val);
      }
    },
    value: {
      type: [Number, Array, Date]
    },
    visible: Boolean,
    onConfirm: Function,
    onSelect: Function
  };

  function ownKeys$J(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$J(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$J(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$J(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var _hoisted_1$q = ["onClick"];
  var _hoisted_2$9 = {
    class: "t-calendar__footer"
  };
  var prefix$11 = config.prefix;
  var name$Y = "".concat(prefix$11, "-calendar");
  var __default__ = {
    name: name$Y,
    components: {
      TPopup: _Popup,
      TButton: _Button
    }
  };
  var script$14 = /* @__PURE__ */vue.defineComponent(_objectSpread$J(_objectSpread$J({}, __default__), {}, {
    props: calendarProps,
    emits: ["select", "confirm", "update:modelValue", "update:value", "update:visible"],
    setup: function setup(__props, _ref) {
      var emit = _ref.emit;
      var props = __props;
      var getYearMonthDay = function getYearMonthDay(date) {
        return {
          year: date.getFullYear(),
          month: date.getMonth(),
          date: date.getDate()
        };
      };
      var popup = vue.ref(props.visible);
      var valueRef = vue.ref(props.value);
      var selectedDate = vue.ref();
      var firstDayOfWeek = vue.computed(function () {
        return props.firstDayOfWeek;
      });
      var type = vue.computed(function () {
        return props.type;
      });
      var days = vue.computed(function () {
        var raw = "\u65E5\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D";
        var ans = [];
        var i = firstDayOfWeek.value % 7;
        while (ans.length < 7) {
          ans.push(raw[i]);
          i = (i + 1) % 7;
        }
        return ans;
      });
      var today = new Date();
      var minDate = props.minDate ? new Date(props.minDate) : today;
      var maxDate = props.maxDate ? new Date(props.maxDate) : new Date(today.getFullYear(), today.getMonth() + 6, today.getDate());
      var getDate = function getDate(year, month, day) {
        return new Date(year, month, day);
      };
      var handleSelect = function handleSelect(year, month, date, dateItem) {
        var _props$onSelect;
        if (dateItem.type === "disabled") return;
        var selected = new Date(year, month, date);
        if (type.value === "range" && Array.isArray(selectedDate.value)) {
          if (selectedDate.value.length === 1) {
            if (selectedDate.value[0] > selected) {
              selectedDate.value = [selected];
            } else {
              selectedDate.value = [selectedDate.value[0], selected];
            }
          } else {
            selectedDate.value = [selected];
          }
        } else if (props.type === "multiple") {
          var newVal = _toConsumableArray(selectedDate.value);
          var index = selectedDate.value.findIndex(function (item) {
            return isSameDate(item, selected);
          });
          if (index > -1) {
            newVal.splice(index, 1);
          } else {
            newVal.push(selected);
          }
          selectedDate.value = newVal;
        } else {
          selectedDate.value = selected;
        }
        (_props$onSelect = props.onSelect) === null || _props$onSelect === void 0 ? void 0 : _props$onSelect.call(props, vue.toRaw(selectedDate.value));
      };
      var handleConfirm = function handleConfirm() {
        var _props$onConfirm;
        popup.value = false;
        (_props$onConfirm = props.onConfirm) === null || _props$onConfirm === void 0 ? void 0 : _props$onConfirm.call(props, vue.toRaw(selectedDate.value));
      };
      var getMonthDates = function getMonthDates(date) {
        var _getYearMonthDay = getYearMonthDay(date),
          year = _getYearMonthDay.year,
          month = _getYearMonthDay.month;
        var firstDay = getDate(year, month, 1);
        var weekdayOfFirstDay = firstDay.getDay();
        var lastDate = new Date(+getDate(year, month + 1, 1) - 24 * 3600 * 1e3).getDate();
        return {
          year: year,
          month: month,
          weekdayOfFirstDay: weekdayOfFirstDay,
          lastDate: lastDate
        };
      };
      var isSameDate = function isSameDate(date1, date2) {
        if (date1 instanceof Date) date1 = getYearMonthDay(date1);
        if (date2 instanceof Date) date2 = getYearMonthDay(date2);
        var keys = ["year", "month", "date"];
        return keys.every(function (key) {
          return date1[key] === date2[key];
        });
      };
      var months = vue.computed(function () {
        var ans = [];
        var _getYearMonthDay2 = getYearMonthDay(minDate),
          minYear = _getYearMonthDay2.year,
          minMonth = _getYearMonthDay2.month;
        var _getYearMonthDay3 = getYearMonthDay(maxDate),
          maxYear = _getYearMonthDay3.year,
          maxMonth = _getYearMonthDay3.month;
        var calcType = function calcType(year, month, date) {
          var curDate = new Date(year, month, date, 23, 59, 59);
          if (type.value === "single") {
            if (isSameDate({
              year: year,
              month: month,
              date: date
            }, selectedDate.value)) return "selected";
          }
          if (type.value === "multiple") {
            var hit = selectedDate.value.some(function (item) {
              return isSameDate({
                year: year,
                month: month,
                date: date
              }, item);
            });
            if (hit) {
              return "selected";
            }
          }
          if (type.value === "range") {
            if (Array.isArray(selectedDate.value)) {
              var _selectedDate$value = _slicedToArray(selectedDate.value, 2),
                startDate = _selectedDate$value[0],
                endDate = _selectedDate$value[1];
              if (startDate && isSameDate({
                year: year,
                month: month,
                date: date
              }, startDate)) return "start";
              if (endDate && isSameDate({
                year: year,
                month: month,
                date: date
              }, endDate)) return "end";
              if (startDate && endDate && curDate.getTime() > startDate.getTime() && curDate.getTime() < endDate.getTime()) return "centre";
            }
          }
          var minCurDate = new Date(year, month, date, 0, 0, 0);
          if (curDate.getTime() < minDate.getTime() || minCurDate.getTime() > maxDate.getTime()) {
            return "disabled";
          }
          return "";
        };
        while (minYear < maxYear || minYear === maxYear && minMonth <= maxMonth) {
          var target = getMonthDates(getDate(minYear, minMonth, 1));
          var months2 = [];
          for (var i = 1; i <= 31; i++) {
            if (i > target.lastDate) break;
            var dateObj = {
              date: getDate(minYear, minMonth, i),
              day: i,
              type: calcType(minYear, minMonth, i)
            };
            months2.push(props.format ? props.format(dateObj) : dateObj);
          }
          ans.push({
            year: minYear,
            month: minMonth,
            months: months2,
            weekdayOfFirstDay: target.weekdayOfFirstDay
          });
          var curDate = getYearMonthDay(getDate(minYear, minMonth + 1, 1));
          minYear = curDate.year;
          minMonth = curDate.month;
        }
        return ans;
      });
      var confirmBtn = vue.computed(function () {
        if (typeof props.confirmBtn === "string" || props.confirmBtn === "") return {
          content: props.confirmBtn || "\u786E\u8BA4"
        };
        return props.confirmBtn;
      });
      vue.watch(function () {
        return props.visible;
      }, function (val) {
        popup.value = val;
      });
      vue.watch(function () {
        return popup.value;
      }, function (val) {
        emit("update:visible", val);
      });
      vue.watch(valueRef, function () {
        if (Array.isArray(valueRef.value)) {
          selectedDate.value = valueRef.value.map(function (item) {
            return new Date(item);
          });
        } else if (valueRef.value) {
          selectedDate.value = new Date(valueRef.value);
        } else {
          selectedDate.value = props.type === "multiple" ? [new Date()] : new Date();
        }
      }, {
        immediate: true
      });
      return function (_ctx, _cache) {
        return vue.openBlock(), vue.createElementBlock("div", null, [vue.createVNode(vue.unref(_Popup), {
          modelValue: popup.value,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = function ($event) {
            return popup.value = $event;
          }),
          placement: "bottom"
        }, {
          default: vue.withCtx(function () {
            return [vue.createElementVNode("div", {
              class: vue.normalizeClass(name$Y)
            }, [vue.createElementVNode("div", {
              class: vue.normalizeClass("".concat(name$Y, "__title"))
            }, [vue.renderSlot(_ctx.$slots, "title", {}, function () {
              return [vue.createTextVNode(vue.toDisplayString(_ctx.title || "\u8BF7\u9009\u62E9\u65E5\u671F"), 1)];
            })], 2), vue.createVNode(vue.unref(close), {
              class: vue.normalizeClass("".concat(name$Y, "__close-btn")),
              size: "24",
              onClick: _cache[0] || (_cache[0] = function ($event) {
                return popup.value = false;
              })
            }, null, 8, ["class"]), vue.createElementVNode("div", {
              class: vue.normalizeClass("".concat(name$Y, "__days"))
            }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(days), function (item, index) {
              return vue.openBlock(), vue.createElementBlock("div", {
                key: index,
                class: vue.normalizeClass("".concat(name$Y, "__days-item"))
              }, vue.toDisplayString(item), 3);
            }), 128))], 2), vue.createElementVNode("div", {
              class: vue.normalizeClass("".concat(name$Y, "__months"))
            }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(vue.unref(months), function (item, index) {
              return vue.openBlock(), vue.createElementBlock(vue.Fragment, {
                key: index
              }, [vue.createElementVNode("div", {
                class: vue.normalizeClass("".concat(name$Y, "__month"))
              }, vue.toDisplayString(item.year) + " \u5E74 " + vue.toDisplayString(item.month + 1) + " \u6708", 3), vue.createElementVNode("div", {
                class: vue.normalizeClass("".concat(name$Y, "__dates"))
              }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(item.months, function (dateItem, dateIndex) {
                var _dateItem$className, _normalizeClass2;
                return vue.openBlock(), vue.createElementBlock("div", {
                  key: dateIndex,
                  class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, "".concat(name$Y, "__dates-item"), true), _defineProperty$2(_normalizeClass2, "".concat(name$Y, "__dates-item--").concat(dateItem.type), !!dateItem.type), _defineProperty$2(_normalizeClass2, "".concat((_dateItem$className = dateItem.className) !== null && _dateItem$className !== void 0 ? _dateItem$className : ""), true), _normalizeClass2)),
                  style: vue.normalizeStyle({
                    marginLeft: dateIndex === 0 ? "".concat(49 * ((item.weekdayOfFirstDay - vue.unref(firstDayOfWeek) + 7) % 7), "px") : 0
                  }),
                  onClick: function onClick($event) {
                    return handleSelect(item.year, item.month, dateItem.day, dateItem);
                  }
                }, [vue.renderSlot(_ctx.$slots, "cell", {
                  item: dateItem
                }, function () {
                  var _normalizeClass3;
                  return [dateItem.prefix ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 0,
                    class: vue.normalizeClass("".concat(name$Y, "__dates-item-prefix"))
                  }, vue.toDisplayString(dateItem.prefix), 3)) : vue.createCommentVNode("", true), vue.createTextVNode(" " + vue.toDisplayString(dateItem.day) + " ", 1), dateItem.suffix ? (vue.openBlock(), vue.createElementBlock("div", {
                    key: 1,
                    class: vue.normalizeClass((_normalizeClass3 = {}, _defineProperty$2(_normalizeClass3, "".concat(name$Y, "__dates-item-suffix"), true), _defineProperty$2(_normalizeClass3, "".concat(name$Y, "__dates-item-suffix--").concat(dateItem.type), !!dateItem.type), _normalizeClass3))
                  }, vue.toDisplayString(dateItem.suffix), 3)) : vue.createCommentVNode("", true)];
                })], 14, _hoisted_1$q);
              }), 128))], 2)], 64);
            }), 128))], 2), vue.createElementVNode("div", _hoisted_2$9, [vue.renderSlot(_ctx.$slots, "confirmBtn", {}, function () {
              return [vue.unref(confirmBtn) && _typeof$1(vue.unref(confirmBtn)) === "object" ? (vue.openBlock(), vue.createBlock(vue.unref(_Button), vue.mergeProps({
                key: 0,
                block: "",
                theme: "primary"
              }, vue.unref(confirmBtn), {
                onClick: handleConfirm
              }), null, 16)) : vue.createCommentVNode("", true)];
            })])])];
          }),
          _: 3
        }, 8, ["modelValue"])]);
      };
    }
  }));

  var _Calendar = withInstall(script$14);

  var CellProps = {
    align: {
      type: String,
      default: "middle",
      validator: function validator(val) {
        if (!val) return true;
        return ["top", "middle", "bottom"].includes(val);
      }
    },
    arrow: Boolean,
    bordered: {
      type: Boolean,
      default: true
    },
    description: {
      type: [String, Function]
    },
    hover: Boolean,
    image: {
      type: [String, Function]
    },
    leftIcon: {
      type: Function
    },
    note: {
      type: [String, Function]
    },
    required: Boolean,
    rightIcon: {
      type: Function
    },
    title: {
      type: [String, Function]
    },
    onClick: Function
  };

  function ownKeys$I(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$I(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$I(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$I(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$10 = config.prefix;
  var name$X = "".concat(prefix$10, "-cell");
  var script$13 = vue.defineComponent({
    name: name$X,
    components: {
      TNode: TNodeComponent
    },
    props: CellProps,
    emits: ["click"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var noteContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "note");
      });
      var titleContent = vue.computed(function () {
        return renderTNode(internalInstance, "title");
      });
      var descriptionContent = vue.computed(function () {
        return renderTNode(internalInstance, "description");
      });
      var chevronRightIcon = vue.h(chevronRight);
      var rightIconContent = vue.computed(function () {
        if (props.arrow) {
          return chevronRightIcon;
        }
        return renderTNode(internalInstance, "rightIcon");
      });
      var imageContent = vue.computed(function () {
        return renderTNode(internalInstance, "image");
      });
      var leftIconContent = vue.computed(function () {
        return renderTNode(internalInstance, "leftIcon");
      });
      var styleCell = vue.computed(function () {
        var _ref;
        return ["".concat(name$X), "".concat(name$X, "--").concat(props.align), (_ref = {}, _defineProperty$2(_ref, "".concat(name$X, "--hover"), props.hover), _defineProperty$2(_ref, "".concat(name$X, "--bordered"), props.bordered), _ref)];
      });
      var onClick = function onClick(e) {
        return emitEvent("click", e);
      };
      return _objectSpread$I(_objectSpread$I({}, vue.toRefs(props)), {}, {
        name: name$X,
        onClick: onClick,
        styleCell: styleCell,
        imageContent: imageContent,
        rightIconContent: rightIconContent,
        leftIconContent: leftIconContent,
        noteContent: noteContent,
        titleContent: titleContent,
        descriptionContent: descriptionContent
      });
    }
  });

  var _hoisted_1$p = ["src"];
  function render$12(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.styleCell),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.onClick && _ctx.onClick.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__left-icon"))
    }, [_ctx.leftIconContent ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.leftIconContent
    }, null, 8, ["content"])) : vue.createCommentVNode("", true), _ctx.image ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 1
    }, [typeof _ctx.image === "string" ? (vue.openBlock(), vue.createElementBlock("img", {
      key: 0,
      src: _ctx.image,
      class: vue.normalizeClass("".concat(_ctx.name, "__image"))
    }, null, 10, _hoisted_1$p)) : (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 1,
      content: _ctx.imageContent
    }, null, 8, ["content"]))], 64)) : vue.createCommentVNode("", true)], 2), _ctx.titleContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__title"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.titleContent
    }, null, 8, ["content"]), _ctx.required ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "--required"))
    }, "\xA0*", 2)) : vue.createCommentVNode("", true), _ctx.descriptionContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__description"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.descriptionContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2)) : vue.createCommentVNode("", true), _ctx.noteContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__note"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.noteContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), _ctx.rightIconContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 2,
      class: vue.normalizeClass("".concat(_ctx.name, "__right-icon"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.rightIconContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2);
  }

  script$13.render = render$12;

  var _Cell = withInstall(script$13);

  var CellGroupProps = {
    bordered: Boolean,
    title: {
      type: String,
      default: ""
    }
  };

  var prefix$$ = config.prefix;
  var name$W = "".concat(prefix$$, "-cell-group");
  var script$12 = vue.defineComponent({
    name: name$W,
    props: CellGroupProps,
    setup: function setup() {
      return {
        name: name$W
      };
    }
  });

  function render$11(_ctx, _cache, $props, $setup, $data, $options) {
    var _normalizeClass2;
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.name)
    }, [_ctx.title ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__title"))
    }, [vue.renderSlot(_ctx.$slots, "title", {}, function () {
      return [vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)];
    })], 2)) : vue.createCommentVNode("", true), vue.createElementVNode("div", {
      class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, "".concat(_ctx.name, "__container"), true), _defineProperty$2(_normalizeClass2, "border--top-bottom", _ctx.bordered), _normalizeClass2))
    }, [vue.renderSlot(_ctx.$slots, "default")], 2)], 2);
  }

  script$12.render = render$11;

  var _CellGroup = withInstall(script$12);

  var CheckboxProps$1 = {
    align: {
      type: String,
      default: "left",
      validator: function validator(val) {
        if (!val) return true;
        return ["left", "right"].includes(val);
      }
    },
    checkAll: Boolean,
    checked: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultChecked: Boolean,
    content: {
      type: [String, Function]
    },
    contentDisabled: Boolean,
    default: {
      type: [String, Function]
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    icon: {
      type: Array
    },
    indeterminate: Boolean,
    label: {
      type: [String, Function]
    },
    maxContentRow: {
      type: Number,
      default: 5
    },
    maxLabelRow: {
      type: Number,
      default: 3
    },
    name: {
      type: String,
      default: ""
    },
    readonly: Boolean,
    value: {
      type: [String, Number]
    },
    onChange: Function
  };

  function ownKeys$H(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$H(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$H(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$H(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$_ = config.prefix;
  var name$V = "".concat(prefix$_, "-checkbox");
  var script$11 = vue.defineComponent({
    name: name$V,
    components: {
      TNode: TNodeComponent,
      MinusCircleFilledIcon: minusCircleFilled
    },
    props: _objectSpread$H(_objectSpread$H({}, CheckboxProps$1), {}, {
      borderless: {
        type: Boolean,
        value: false
      }
    }),
    emits: ["update:checked", "update:modelValue", "change"],
    setup: function setup(props, context) {
      var flagName = name$V;
      var checkIcons = props.icon || [vue.h(checkCircleFilled), vue.h(circle)];
      var _useDefault = useDefault(props, context.emit, "checked", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 2),
        innerChecked = _useDefault2[0],
        setInnerChecked = _useDefault2[1];
      var internalInstance = vue.getCurrentInstance();
      var checkboxGroup = vue.inject("checkboxGroup", void 0);
      var labelContent = vue.computed(function () {
        return renderContent(internalInstance, "label", "default");
      });
      var checkboxContent = vue.computed(function () {
        return renderTNode(internalInstance, "content");
      });
      var indeterminate = vue.computed(function () {
        if (props.checkAll && checkboxGroup != null) return checkboxGroup.checkAllStatus.value === "indeterminate";
        return props.indeterminate;
      });
      var isChecked = vue.computed(function () {
        if (props.checkAll) return (checkboxGroup === null || checkboxGroup === void 0 ? void 0 : checkboxGroup.checkAllStatus.value) === "checked";
        if (checkboxGroup != null && props.value != null) {
          var _checkboxGroup$checke;
          return !!((_checkboxGroup$checke = checkboxGroup.checkedSet.value) !== null && _checkboxGroup$checke !== void 0 && _checkboxGroup$checke.has(props.value));
        }
        return innerChecked.value;
      });
      var isDisabled = vue.computed(function () {
        if (checkboxGroup !== null && checkboxGroup !== void 0 && checkboxGroup.max.value) return checkboxGroup.max.value <= checkboxGroup.innerValue.value.length && !isChecked.value;
        if (props.disabled != null) return props.disabled;
        return !!(checkboxGroup !== null && checkboxGroup !== void 0 && checkboxGroup.disabled.value);
      });
      var componentClass = vue.computed(function () {
        var _ref;
        return ["".concat(flagName), (_ref = {}, _defineProperty$2(_ref, ClASSNAMES.STATUS.checked, isChecked.value), _defineProperty$2(_ref, ClASSNAMES.STATUS.disabled, isDisabled.value), _defineProperty$2(_ref, ClASSNAMES.STATUS.indeterminate, indeterminate.value), _ref)];
      });
      var getLimitRowStyle = function getLimitRowStyle(row) {
        return {
          display: "-webkit-box",
          overflow: "hidden",
          WebkitBoxOrient: "vertical",
          WebkitLineClamp: row
        };
      };
      var labelStyle = vue.computed(function () {
        return _objectSpread$H({
          color: isDisabled.value ? "#dcdcdc" : "inherit"
        }, getLimitRowStyle(props.maxLabelRow));
      });
      var contentStyle = vue.computed(function () {
        return _objectSpread$H({}, getLimitRowStyle(props.maxContentRow));
      });
      var handleChange = function handleChange(e, source) {
        if (isDisabled.value) return;
        if (source === "content" && props.contentDisabled) return;
        var value = !isChecked.value;
        setInnerChecked(value, {
          e: e
        });
        e.stopPropagation();
        if (checkboxGroup && checkboxGroup !== null && checkboxGroup !== void 0 && checkboxGroup.onCheckedChange) {
          checkboxGroup.onCheckedChange({
            checked: value,
            checkAll: props.checkAll,
            e: e,
            option: props
          });
        }
      };
      return _objectSpread$H(_objectSpread$H({}, vue.toRefs(props)), {}, {
        isChecked: isChecked,
        checkIcons: checkIcons,
        labelContent: labelContent,
        labelStyle: labelStyle,
        checkboxContent: checkboxContent,
        contentStyle: contentStyle,
        isDisabled: isDisabled,
        flagName: flagName,
        componentClass: componentClass,
        indeterminate: indeterminate,
        handleChange: handleChange
      });
    }
  });

  var _hoisted_1$o = ["name", "value", "disabled", "readonly", "checked", "indeterminate"];
  var _hoisted_2$8 = ["name", "value", "disabled", "readonly", "checked", "indeterminate"];
  function render$10(_ctx, _cache, $props, $setup, $data, $options) {
    var _normalizeClass2;
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_minus_circle_filled_icon = vue.resolveComponent("minus-circle-filled-icon");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.componentClass)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.flagName, "__content-wrap"))
    }, [_ctx.align === "left" ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.flagName, "__icon-left"))
    }, [vue.createElementVNode("input", {
      type: "checkbox",
      name: _ctx.name,
      class: vue.normalizeClass("".concat(_ctx.flagName, "__original-left")),
      value: _ctx.value,
      disabled: _ctx.isDisabled,
      readonly: _ctx.readonly,
      checked: _ctx.isChecked,
      indeterminate: _ctx.indeterminate,
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.handleChange && _ctx.handleChange.apply(_ctx, arguments);
      })
    }, null, 10, _hoisted_1$o), !_ctx.indeterminate ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.checkIcons[_ctx.isChecked ? 0 : 1]
    }, null, 8, ["content"])) : (vue.openBlock(), vue.createBlock(_component_minus_circle_filled_icon, {
      key: 1
    }))], 2)) : vue.createCommentVNode("", true), _ctx.labelContent || _ctx.checkboxContent ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 1,
      class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, "".concat(_ctx.flagName, "__label"), true), _defineProperty$2(_normalizeClass2, "".concat(_ctx.flagName, "__label-left"), _ctx.align === "right"), _normalizeClass2)),
      onClick: _cache[1] || (_cache[1] = function (e) {
        return _ctx.handleChange(e, "content");
      })
    }, [_ctx.labelContent ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      style: vue.normalizeStyle(_ctx.labelStyle)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.labelContent
    }, null, 8, ["content"])], 4)) : vue.createCommentVNode("", true), _ctx.checkboxContent ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.flagName, "__description")),
      style: vue.normalizeStyle(_ctx.contentStyle)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.checkboxContent
    }, null, 8, ["content"])], 6)) : vue.createCommentVNode("", true)], 2)) : vue.createCommentVNode("", true), _ctx.align === "right" ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 2,
      class: vue.normalizeClass("".concat(_ctx.flagName, "__icon-right"))
    }, [vue.createElementVNode("input", {
      type: "checkbox",
      name: _ctx.name,
      class: vue.normalizeClass("".concat(_ctx.flagName, "__original-right")),
      value: _ctx.value,
      disabled: _ctx.isDisabled,
      readonly: _ctx.readonly,
      checked: _ctx.isChecked,
      indeterminate: _ctx.indeterminate,
      onClick: _cache[2] || (_cache[2] = function () {
        return _ctx.handleChange && _ctx.handleChange.apply(_ctx, arguments);
      })
    }, null, 10, _hoisted_2$8), !_ctx.indeterminate ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.checkIcons[_ctx.isChecked ? 0 : 1]
    }, null, 8, ["content"])) : (vue.openBlock(), vue.createBlock(_component_minus_circle_filled_icon, {
      key: 1
    }))], 2)) : vue.createCommentVNode("", true)], 2), !_ctx.borderless ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.flagName, "__border ").concat(_ctx.flagName, "__border--").concat(_ctx.align))
    }, null, 2)) : vue.createCommentVNode("", true)], 2);
  }

  script$11.render = render$10;

  var CheckboxProps = {
    disabled: Boolean,
    max: {
      type: Number,
      default: void 0
    },
    name: {
      type: String,
      default: ""
    },
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    value: {
      type: Array,
      default: void 0
    },
    modelValue: {
      type: Array,
      default: void 0
    },
    defaultValue: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    onChange: Function
  };

  function ownKeys$G(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$G(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$G(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$G(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var getOptionListBySlots = function getOptionListBySlots(nodes) {
    var arr = [];
    nodes === null || nodes === void 0 ? void 0 : nodes.forEach(function (node) {
      var option = node.props;
      if ((option === null || option === void 0 ? void 0 : option["check-all"]) === "" || (option === null || option === void 0 ? void 0 : option["check-all"]) === true) {
        option.checkAll = true;
      }
      option && arr.push(option);
    });
    return arr;
  };
  var getOptions = function getOptions(props, slots) {
    var _toRefs = vue.toRefs(props),
      options = _toRefs.options;
    var optionList = vue.ref([]);
    vue.watch(options, function (options2) {
      if (!options2) return [];
      optionList.value = options2.map(function (item) {
        var r = {};
        if (_typeof$1(item) !== "object") {
          r = {
            label: String(item),
            value: item
          };
        } else {
          r = _objectSpread$G({}, item);
          r.disabled = r.disabled === void 0 ? props.disabled : r.disabled;
        }
        return r;
      });
    }, {
      immediate: true
    });
    vue.onMounted(function () {
      var nodes = slots.default && slots.default();
      if (nodes !== void 0) {
        optionList.value = getOptionListBySlots(useChildSlots("t-checkbox"));
      }
    });
    return optionList;
  };

  function isObject$4(value) {
    var type = _typeof$1(value);
    return value != null && (type == 'object' || type == 'function');
  }
  var isObject_1 = isObject$4;
  var isObject$5 = isObject_1;

  var baseGetTag$4 = _baseGetTag,
    isObject$3 = isObject_1;

  /** `Object#toString` result references. */
  var asyncTag = '[object AsyncFunction]',
    funcTag$1 = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$2(value) {
    if (!isObject$3(value)) {
      return false;
    }
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 9 which returns 'object' for typed arrays and other constructors.
    var tag = baseGetTag$4(value);
    return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  var isFunction_1 = isFunction$2;
  var isFunction$3 = isFunction_1;

  var root$6 = _root;

  /** Used to detect overreaching core-js shims. */
  var coreJsData$1 = root$6['__core-js_shared__'];
  var _coreJsData = coreJsData$1;

  var coreJsData = _coreJsData;

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = function () {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? 'Symbol(src)_1.' + uid : '';
  }();

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked$1(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  var _isMasked = isMasked$1;

  /** Used for built-in method references. */
  var funcProto$1 = Function.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString$1 = funcProto$1.toString;

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to convert.
   * @returns {string} Returns the source code.
   */
  function toSource$2(func) {
    if (func != null) {
      try {
        return funcToString$1.call(func);
      } catch (e) {}
      try {
        return func + '';
      } catch (e) {}
    }
    return '';
  }
  var _toSource = toSource$2;

  var isFunction$1 = isFunction_1,
    isMasked = _isMasked,
    isObject$2 = isObject_1,
    toSource$1 = _toSource;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used for built-in method references. */
  var funcProto = Function.prototype,
    objectProto$9 = Object.prototype;

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty$7 = objectProto$9.hasOwnProperty;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative$1(value) {
    if (!isObject$2(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction$1(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource$1(value));
  }
  var _baseIsNative = baseIsNative$1;

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue$1(object, key) {
    return object == null ? undefined : object[key];
  }
  var _getValue = getValue$1;

  var baseIsNative = _baseIsNative,
    getValue = _getValue;

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative$7(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }
  var _getNative = getNative$7;

  var getNative$6 = _getNative;

  /* Built-in method references that are verified to be native. */
  var nativeCreate$4 = getNative$6(Object, 'create');
  var _nativeCreate = nativeCreate$4;

  var nativeCreate$3 = _nativeCreate;

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear$1() {
    this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
    this.size = 0;
  }
  var _hashClear = hashClear$1;

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete$1(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  var _hashDelete = hashDelete$1;

  var nativeCreate$2 = _nativeCreate;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

  /** Used for built-in method references. */
  var objectProto$8 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$6 = objectProto$8.hasOwnProperty;

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet$1(key) {
    var data = this.__data__;
    if (nativeCreate$2) {
      var result = data[key];
      return result === HASH_UNDEFINED$2 ? undefined : result;
    }
    return hasOwnProperty$6.call(data, key) ? data[key] : undefined;
  }
  var _hashGet = hashGet$1;

  var nativeCreate$1 = _nativeCreate;

  /** Used for built-in method references. */
  var objectProto$7 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$5 = objectProto$7.hasOwnProperty;

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas$1(key) {
    var data = this.__data__;
    return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$5.call(data, key);
  }
  var _hashHas = hashHas$1;

  var nativeCreate = _nativeCreate;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet$1(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED$1 : value;
    return this;
  }
  var _hashSet = hashSet$1;

  var hashClear = _hashClear,
    hashDelete = _hashDelete,
    hashGet = _hashGet,
    hashHas = _hashHas,
    hashSet = _hashSet;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash$1(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `Hash`.
  Hash$1.prototype.clear = hashClear;
  Hash$1.prototype['delete'] = hashDelete;
  Hash$1.prototype.get = hashGet;
  Hash$1.prototype.has = hashHas;
  Hash$1.prototype.set = hashSet;
  var _Hash = Hash$1;

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear$1() {
    this.__data__ = [];
    this.size = 0;
  }
  var _listCacheClear = listCacheClear$1;

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq$2(value, other) {
    return value === other || value !== value && other !== other;
  }
  var eq_1 = eq$2;

  var eq$1 = eq_1;

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf$4(array, key) {
    var length = array.length;
    while (length--) {
      if (eq$1(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  var _assocIndexOf = assocIndexOf$4;

  var assocIndexOf$3 = _assocIndexOf;

  /** Used for built-in method references. */
  var arrayProto = Array.prototype;

  /** Built-in value references. */
  var splice = arrayProto.splice;

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete$1(key) {
    var data = this.__data__,
      index = assocIndexOf$3(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  var _listCacheDelete = listCacheDelete$1;

  var assocIndexOf$2 = _assocIndexOf;

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet$1(key) {
    var data = this.__data__,
      index = assocIndexOf$2(data, key);
    return index < 0 ? undefined : data[index][1];
  }
  var _listCacheGet = listCacheGet$1;

  var assocIndexOf$1 = _assocIndexOf;

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas$1(key) {
    return assocIndexOf$1(this.__data__, key) > -1;
  }
  var _listCacheHas = listCacheHas$1;

  var assocIndexOf = _assocIndexOf;

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet$1(key, value) {
    var data = this.__data__,
      index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  var _listCacheSet = listCacheSet$1;

  var listCacheClear = _listCacheClear,
    listCacheDelete = _listCacheDelete,
    listCacheGet = _listCacheGet,
    listCacheHas = _listCacheHas,
    listCacheSet = _listCacheSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache$4(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `ListCache`.
  ListCache$4.prototype.clear = listCacheClear;
  ListCache$4.prototype['delete'] = listCacheDelete;
  ListCache$4.prototype.get = listCacheGet;
  ListCache$4.prototype.has = listCacheHas;
  ListCache$4.prototype.set = listCacheSet;
  var _ListCache = ListCache$4;

  var getNative$5 = _getNative,
    root$5 = _root;

  /* Built-in method references that are verified to be native. */
  var Map$3 = getNative$5(root$5, 'Map');
  var _Map = Map$3;

  var Hash = _Hash,
    ListCache$3 = _ListCache,
    Map$2 = _Map;

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear$1() {
    this.size = 0;
    this.__data__ = {
      'hash': new Hash(),
      'map': new (Map$2 || ListCache$3)(),
      'string': new Hash()
    };
  }
  var _mapCacheClear = mapCacheClear$1;

  function isKeyable$1(value) {
    var type = _typeof$1(value);
    return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
  }
  var _isKeyable = isKeyable$1;

  var isKeyable = _isKeyable;

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData$4(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
  }
  var _getMapData = getMapData$4;

  var getMapData$3 = _getMapData;

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete$1(key) {
    var result = getMapData$3(this, key)['delete'](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  var _mapCacheDelete = mapCacheDelete$1;

  var getMapData$2 = _getMapData;

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet$1(key) {
    return getMapData$2(this, key).get(key);
  }
  var _mapCacheGet = mapCacheGet$1;

  var getMapData$1 = _getMapData;

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas$1(key) {
    return getMapData$1(this, key).has(key);
  }
  var _mapCacheHas = mapCacheHas$1;

  var getMapData = _getMapData;

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet$1(key, value) {
    var data = getMapData(this, key),
      size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  var _mapCacheSet = mapCacheSet$1;

  var mapCacheClear = _mapCacheClear,
    mapCacheDelete = _mapCacheDelete,
    mapCacheGet = _mapCacheGet,
    mapCacheHas = _mapCacheHas,
    mapCacheSet = _mapCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache$3(entries) {
    var index = -1,
      length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  // Add methods to `MapCache`.
  MapCache$3.prototype.clear = mapCacheClear;
  MapCache$3.prototype['delete'] = mapCacheDelete;
  MapCache$3.prototype.get = mapCacheGet;
  MapCache$3.prototype.has = mapCacheHas;
  MapCache$3.prototype.set = mapCacheSet;
  var _MapCache = MapCache$3;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /**
   * Adds `value` to the array cache.
   *
   * @private
   * @name add
   * @memberOf SetCache
   * @alias push
   * @param {*} value The value to cache.
   * @returns {Object} Returns the cache instance.
   */
  function setCacheAdd$1(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  var _setCacheAdd = setCacheAdd$1;

  /**
   * Checks if `value` is in the array cache.
   *
   * @private
   * @name has
   * @memberOf SetCache
   * @param {*} value The value to search for.
   * @returns {number} Returns `true` if `value` is found, else `false`.
   */
  function setCacheHas$1(value) {
    return this.__data__.has(value);
  }
  var _setCacheHas = setCacheHas$1;

  var MapCache$2 = _MapCache,
    setCacheAdd = _setCacheAdd,
    setCacheHas = _setCacheHas;

  /**
   *
   * Creates an array cache object to store unique values.
   *
   * @private
   * @constructor
   * @param {Array} [values] The values to cache.
   */
  function SetCache$2(values) {
    var index = -1,
      length = values == null ? 0 : values.length;
    this.__data__ = new MapCache$2();
    while (++index < length) {
      this.add(values[index]);
    }
  }

  // Add methods to `SetCache`.
  SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
  SetCache$2.prototype.has = setCacheHas;
  var _SetCache = SetCache$2;

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex$2(array, predicate, fromIndex, fromRight) {
    var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  var _baseFindIndex = baseFindIndex$2;

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN$1(value) {
    return value !== value;
  }
  var _baseIsNaN = baseIsNaN$1;

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf$1(array, value, fromIndex) {
    var index = fromIndex - 1,
      length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  var _strictIndexOf = strictIndexOf$1;

  var baseFindIndex$1 = _baseFindIndex,
    baseIsNaN = _baseIsNaN,
    strictIndexOf = _strictIndexOf;

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf$1(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex$1(array, baseIsNaN, fromIndex);
  }
  var _baseIndexOf = baseIndexOf$1;

  var baseIndexOf = _baseIndexOf;

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes$1(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }
  var _arrayIncludes = arrayIncludes$1;

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith$1(array, value, comparator) {
    var index = -1,
      length = array == null ? 0 : array.length;
    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }
  var _arrayIncludesWith = arrayIncludesWith$1;

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary$2(func) {
    return function (value) {
      return func(value);
    };
  }
  var _baseUnary = baseUnary$2;

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas$2(cache, key) {
    return cache.has(key);
  }
  var _cacheHas = cacheHas$2;

  var SetCache$1 = _SetCache,
    arrayIncludes = _arrayIncludes,
    arrayIncludesWith = _arrayIncludesWith,
    arrayMap$1 = _arrayMap,
    baseUnary$1 = _baseUnary,
    cacheHas$1 = _cacheHas;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMin = Math.min;

  /**
   * The base implementation of methods like `_.intersection`, without support
   * for iteratee shorthands, that accepts an array of arrays to inspect.
   *
   * @private
   * @param {Array} arrays The arrays to inspect.
   * @param {Function} [iteratee] The iteratee invoked per element.
   * @param {Function} [comparator] The comparator invoked per element.
   * @returns {Array} Returns the new array of shared values.
   */
  function baseIntersection$1(arrays, iteratee, comparator) {
    var includes = comparator ? arrayIncludesWith : arrayIncludes,
      length = arrays[0].length,
      othLength = arrays.length,
      othIndex = othLength,
      caches = Array(othLength),
      maxLength = Infinity,
      result = [];
    while (othIndex--) {
      var array = arrays[othIndex];
      if (othIndex && iteratee) {
        array = arrayMap$1(array, baseUnary$1(iteratee));
      }
      maxLength = nativeMin(array.length, maxLength);
      caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache$1(othIndex && array) : undefined;
    }
    array = arrays[0];
    var index = -1,
      seen = caches[0];
    outer: while (++index < length && result.length < maxLength) {
      var value = array[index],
        computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (!(seen ? cacheHas$1(seen, computed) : includes(result, computed, comparator))) {
        othIndex = othLength;
        while (--othIndex) {
          var cache = caches[othIndex];
          if (!(cache ? cacheHas$1(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }
  var _baseIntersection = baseIntersection$1;

  /**
   * This method returns the first argument it receives.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Util
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'a': 1 };
   *
   * console.log(_.identity(object) === object);
   * // => true
   */
  function identity$3(value) {
    return value;
  }
  var identity_1 = identity$3;

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply$1(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  var _apply = apply$1;

  var apply = _apply;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax$1 = Math.max;

  /**
   * A specialized version of `baseRest` which transforms the rest array.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @param {Function} transform The rest array transform.
   * @returns {Function} Returns the new function.
   */
  function overRest$1(func, start, transform) {
    start = nativeMax$1(start === undefined ? func.length - 1 : start, 0);
    return function () {
      var args = arguments,
        index = -1,
        length = nativeMax$1(args.length - start, 0),
        array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  var _overRest = overRest$1;

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new constant function.
   * @example
   *
   * var objects = _.times(2, _.constant({ 'a': 1 }));
   *
   * console.log(objects);
   * // => [{ 'a': 1 }, { 'a': 1 }]
   *
   * console.log(objects[0] === objects[1]);
   * // => true
   */
  function constant$1(value) {
    return function () {
      return value;
    };
  }
  var constant_1 = constant$1;

  var getNative$4 = _getNative;
  var defineProperty$1 = function () {
    try {
      var func = getNative$4(Object, 'defineProperty');
      func({}, '', {});
      return func;
    } catch (e) {}
  }();
  var _defineProperty = defineProperty$1;

  var constant = constant_1,
    defineProperty = _defineProperty,
    identity$2 = identity_1;

  /**
   * The base implementation of `setToString` without support for hot loop shorting.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var baseSetToString$1 = !defineProperty ? identity$2 : function (func, string) {
    return defineProperty(func, 'toString', {
      'configurable': true,
      'enumerable': false,
      'value': constant(string),
      'writable': true
    });
  };
  var _baseSetToString = baseSetToString$1;

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
    HOT_SPAN = 16;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeNow = Date.now;

  /**
   * Creates a function that'll short out and invoke `identity` instead
   * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
   * milliseconds.
   *
   * @private
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new shortable function.
   */
  function shortOut$1(func) {
    var count = 0,
      lastCalled = 0;
    return function () {
      var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(undefined, arguments);
    };
  }
  var _shortOut = shortOut$1;

  var baseSetToString = _baseSetToString,
    shortOut = _shortOut;

  /**
   * Sets the `toString` method of `func` to return `string`.
   *
   * @private
   * @param {Function} func The function to modify.
   * @param {Function} string The `toString` result.
   * @returns {Function} Returns `func`.
   */
  var setToString$1 = shortOut(baseSetToString);
  var _setToString = setToString$1;

  var identity$1 = identity_1,
    overRest = _overRest,
    setToString = _setToString;

  /**
   * The base implementation of `_.rest` which doesn't validate or coerce arguments.
   *
   * @private
   * @param {Function} func The function to apply a rest parameter to.
   * @param {number} [start=func.length-1] The start position of the rest parameter.
   * @returns {Function} Returns the new function.
   */
  function baseRest$1(func, start) {
    return setToString(overRest(func, start, identity$1), func + '');
  }
  var _baseRest = baseRest$1;

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER$1 = 9007199254740991;

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength$3(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
  }
  var isLength_1 = isLength$3;

  var isFunction = isFunction_1,
    isLength$2 = isLength_1;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike$2(value) {
    return value != null && isLength$2(value.length) && !isFunction(value);
  }
  var isArrayLike_1 = isArrayLike$2;

  var isArrayLike$1 = isArrayLike_1,
    isObjectLike$5 = isObjectLike_1;

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject$1(value) {
    return isObjectLike$5(value) && isArrayLike$1(value);
  }
  var isArrayLikeObject_1 = isArrayLikeObject$1;

  var isArrayLikeObject = isArrayLikeObject_1;

  /**
   * Casts `value` to an empty array if it's not an array like object.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {Array|Object} Returns the cast array-like object.
   */
  function castArrayLikeObject$1(value) {
    return isArrayLikeObject(value) ? value : [];
  }
  var _castArrayLikeObject = castArrayLikeObject$1;

  var arrayMap = _arrayMap,
    baseIntersection = _baseIntersection,
    baseRest = _baseRest,
    castArrayLikeObject = _castArrayLikeObject;

  /**
   * Creates an array of unique values that are included in all given arrays
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons. The order and references of result values are
   * determined by the first array.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @returns {Array} Returns the new array of intersecting values.
   * @example
   *
   * _.intersection([2, 1], [2, 3]);
   * // => [2]
   */
  var intersection = baseRest(function (arrays) {
    var mapped = arrayMap(arrays, castArrayLikeObject);
    return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
  });
  var intersection_1 = intersection;

  var setCheckAllStatus = function setCheckAllStatus(optionList, innerValue, checkedSet) {
    var isArray = Array.isArray;
    var intersectionLen = vue.computed(function () {
      var _optionList$value;
      var values = (_optionList$value = optionList.value) === null || _optionList$value === void 0 ? void 0 : _optionList$value.map(function (item) {
        return item.value;
      });
      if (isArray(innerValue.value)) {
        return intersection_1(innerValue.value, values).length;
      }
      return 0;
    });
    var isAllChecked = vue.computed(function () {
      if (checkedSet.value.size !== optionList.value.length - 1) {
        return false;
      }
      return intersectionLen.value === optionList.value.length - 1;
    });
    var indeterminate = vue.computed(function () {
      return !isAllChecked.value && intersectionLen.value < optionList.value.length && intersectionLen.value > 0;
    });
    return vue.computed(function () {
      if (isAllChecked.value) return "checked";
      if (indeterminate.value) return "indeterminate";
      return "uncheck";
    });
  };

  function ownKeys$F(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$F(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$F(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$F(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$Z = config.prefix;
  var name$U = "".concat(prefix$Z, "-checkbox-group");
  var script$10 = vue.defineComponent({
    name: name$U,
    components: {
      Checkbox: script$11
    },
    props: CheckboxProps,
    emits: ["update:value", "update:modelValue", "change"],
    setup: function setup(props, context) {
      var isArray = Array.isArray;
      var _useDefault = useDefault(props, context.emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 2),
        innerValue = _useDefault2[0],
        setinnerValue = _useDefault2[1];
      var optionList = getOptions(props, context.slots);
      var checkedSet = vue.computed(function () {
        if (isArray(innerValue.value)) {
          return new Set(innerValue.value);
        }
        return /* @__PURE__ */new Set();
      });
      var checkAllStatus = setCheckAllStatus(optionList, innerValue, checkedSet);
      var maxExceeded = vue.computed(function () {
        return props.max !== void 0 && innerValue.value.length === props.max;
      });
      var onCheckedChange = function onCheckedChange(p) {
        var checked = p.checked,
          checkAll = p.checkAll,
          e = p.e;
        if (checkAll) {
          onCheckAllChange(checked, {
            e: e
          });
        } else {
          handleCheckboxChange(p);
        }
      };
      var handleCheckboxChange = function handleCheckboxChange(data) {
        var currentValue = data.option.value;
        if (isArray(innerValue.value)) {
          if (currentValue === void 0) {
            return;
          }
          var val = _toConsumableArray(innerValue.value);
          if (data.checked) {
            val.push(currentValue);
          } else {
            var i = val.indexOf(currentValue);
            val.splice(i, 1);
          }
          setinnerValue(val, {
            e: data.e,
            current: data.option.value,
            type: data.checked ? "check" : "uncheck"
          });
        } else {
          console.warn("TDesign CheckboxGroup Warn: `value` must be an array, instead of ".concat(_typeof$1(innerValue.value)));
        }
      };
      var getAllCheckboxValue = function getAllCheckboxValue() {
        var val = /* @__PURE__ */new Set();
        for (var i = 0, len = optionList.value.length; i < len; i++) {
          var item = optionList.value[i];
          if (item.checkAll) continue;
          if (item.value === void 0) continue;
          val.add(item.value);
          if (maxExceeded.value) break;
        }
        return _toConsumableArray(val);
      };
      var onCheckAllChange = function onCheckAllChange(checked, context2) {
        var value = checked ? getAllCheckboxValue() : [];
        setinnerValue(value, {
          e: context2.e,
          type: checked ? "check" : "uncheck",
          current: void 0
        });
      };
      vue.provide("checkboxGroup", _objectSpread$F(_objectSpread$F({}, vue.toRefs(props)), {}, {
        innerValue: innerValue,
        checkAllStatus: checkAllStatus,
        checkedSet: checkedSet,
        onCheckedChange: onCheckedChange
      }));
      return {
        prefix: prefix$Z,
        optionList: optionList
      };
    }
  });

  var _hoisted_1$n = {
    key: 1
  };
  function render$$(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_checkbox = vue.resolveComponent("checkbox");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass("".concat(_ctx.prefix, "-checkbox-group"))
    }, [!(_ctx.options && _ctx.options.length) ? vue.renderSlot(_ctx.$slots, "default", {
      key: 0
    }) : (vue.openBlock(), vue.createElementBlock("span", _hoisted_1$n, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.optionList, function (item, idx) {
      return vue.openBlock(), vue.createBlock(_component_checkbox, {
        key: idx,
        name: item.name,
        label: item.label,
        value: item.value,
        "check-all": item.checkAll
      }, null, 8, ["name", "label", "value", "check-all"]);
    }), 128))]))], 2);
  }

  script$10.render = render$$;

  var CheckBox = withInstall(script$11);
  var CheckboxGroup = withInstall(script$10);

  var InputProps = {
    align: {
      type: String,
      default: "left",
      validator: function validator(val) {
        return ["left", "center", "right"].includes(val);
      }
    },
    autocomplete: Boolean,
    autofocus: Boolean,
    clearable: Boolean,
    disabled: Boolean,
    errorMessage: {
      type: String,
      default: ""
    },
    label: {
      type: [String, Function]
    },
    maxcharacter: {
      type: Number
    },
    maxlength: {
      type: Number
    },
    name: {
      type: String,
      default: ""
    },
    placeholder: {
      type: String,
      default: void 0
    },
    prefixIcon: {
      type: Function
    },
    readonly: Boolean,
    required: Boolean,
    size: {
      type: String,
      default: "small",
      validator: function validator(val) {
        return ["small", "medium"].includes(val);
      }
    },
    suffix: {
      type: [String, Function]
    },
    suffixIcon: {
      type: Function
    },
    type: {
      type: String,
      default: "text",
      validator: function validator(val) {
        return ["text", "number", "url", "tel", "password", "search", "submit", "hidden"].includes(val);
      }
    },
    value: {
      type: [String, Number]
    },
    modelValue: {
      type: [String, Number]
    },
    defaultValue: {
      type: [String, Number]
    },
    onBlur: Function,
    onChange: Function,
    onClear: Function,
    onFocus: Function
  };

  function ownKeys$E(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$E(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$E(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$E(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$Y = config.prefix;
  var componentName$5 = "".concat(prefix$Y, "-input");
  var script$$ = vue.defineComponent({
    name: componentName$5,
    components: {
      TNode: TNodeComponent,
      TCell: _Cell,
      CloseCircleFilledIcon: closeCircleFilled
    },
    props: InputProps,
    emits: ["update:value", "update:modelValue", "click-icon", "focus", "blur", "change", "clear"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var inputRef = vue.ref();
      var _toRefs = vue.toRefs(props),
        autofocus = _toRefs.autofocus;
      var internalInstance = vue.getCurrentInstance();
      var _useDefault = useDefault(props, context.emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 1),
        innerValue = _useDefault2[0];
      var styleLabel = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(componentName$5, "--label"), true), _defineProperty$2(_ref, ClASSNAMES.STATUS.disabled, props.disabled), _ref;
      });
      var _useFocus = useFocus(inputRef, {
          initialValue: props.autofocus
        }),
        focused = _useFocus.focused;
      var labelContent = vue.computed(function () {
        return renderTNode(internalInstance, "label");
      });
      var suffixIconContent = vue.computed(function () {
        return renderTNode(internalInstance, "suffixIcon");
      });
      var prefixIconContent = vue.computed(function () {
        return renderTNode(internalInstance, "prefixIcon");
      });
      var suffixContent = vue.computed(function () {
        return renderTNode(internalInstance, "suffix");
      });
      var styleControl = vue.computed(function () {
        return ["".concat(componentName$5, "__control"), _defineProperty$2({}, "".concat(componentName$5, "__control--").concat(props.align), props.align !== "left")];
      });
      var styleWrapper = vue.computed(function () {
        var _ref3;
        return _ref3 = {}, _defineProperty$2(_ref3, componentName$5, true), _defineProperty$2(_ref3, "".concat(componentName$5, "--size-").concat(props.size), props.size), _defineProperty$2(_ref3, "".concat(componentName$5, "__error"), !!props.errorMessage), _ref3;
      });
      var setInputValue = function setInputValue() {
        var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        var input = inputRef.value;
        var sV = String(v);
        if (!input) {
          return;
        }
        if (input.value !== sV) {
          input.value = sV;
        }
      };
      var handleInput = function handleInput(e) {
        var checkInputType = e.inputType && e.inputType === "insertCompositionText";
        if (e.isComposing || checkInputType) return;
        inputValueChangeHandle(e);
      };
      var inputValueChangeHandle = function inputValueChangeHandle(e) {
        var value = e.target.value;
        var maxcharacter = props.maxcharacter;
        if (maxcharacter && maxcharacter > 0 && !Number.isNaN(maxcharacter)) {
          var _getCharacterLength = getCharacterLength(value, maxcharacter);
            _getCharacterLength.length;
            var _getCharacterLength$c = _getCharacterLength.characters,
            characters = _getCharacterLength$c === void 0 ? "" : _getCharacterLength$c;
          innerValue.value = characters;
        } else {
          innerValue.value = value;
        }
        vue.nextTick(function () {
          return setInputValue(innerValue.value);
        });
      };
      var focus = function focus() {
        focused.value = true;
      };
      var blur = function blur() {
        focused.value = false;
      };
      extendAPI({
        focus: focus,
        blur: blur
      });
      var handleClear = function handleClear(e) {
        innerValue.value = "";
        focused.value = true;
        emitEvent("clear", {
          e: e
        });
      };
      var handleFocus = function handleFocus(e) {
        emitEvent("focus", innerValue.value, {
          e: e
        });
      };
      var handleBlur = function handleBlur(e) {
        emitEvent("blur", innerValue.value, {
          e: e
        });
      };
      var handleCompositionend = function handleCompositionend(e) {
        inputValueChangeHandle(e);
      };
      vue.watch(autofocus, function (autofocus2, prevAutofocus) {
        if (autofocus2 === true) {
          vue.nextTick(function () {
            focused.value = true;
          });
        }
      });
      return _objectSpread$E(_objectSpread$E({
        componentName: componentName$5
      }, vue.toRefs(props)), {}, {
        styleLabel: styleLabel,
        styleWrapper: styleWrapper,
        styleControl: styleControl,
        suffixContent: suffixContent,
        suffixIconContent: suffixIconContent,
        prefixIconContent: prefixIconContent,
        labelContent: labelContent,
        innerValue: innerValue,
        inputRef: inputRef,
        handleClear: handleClear,
        handleFocus: handleFocus,
        handleBlur: handleBlur,
        handleInput: handleInput,
        handleCompositionend: handleCompositionend
      });
    }
  });

  var _hoisted_1$m = ["value", "name", "type", "disabled", "autocomplete", "placeholder", "readonly", "maxlength"];
  function render$_(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_close_circle_filled_icon = vue.resolveComponent("close-circle-filled-icon");
    var _component_t_cell = vue.resolveComponent("t-cell");
    return vue.openBlock(), vue.createBlock(_component_t_cell, {
      required: _ctx.required,
      class: vue.normalizeClass(_ctx.styleWrapper)
    }, vue.createSlots({
      note: vue.withCtx(function () {
        return [vue.createElementVNode("div", {
          class: vue.normalizeClass("".concat(_ctx.componentName, "__wrap"))
        }, [vue.createElementVNode("input", {
          ref: "inputRef",
          value: _ctx.innerValue,
          name: _ctx.name,
          class: vue.normalizeClass(_ctx.styleControl),
          type: _ctx.type,
          disabled: _ctx.disabled,
          autocomplete: _ctx.autocomplete ? "On" : "Off",
          placeholder: _ctx.placeholder,
          readonly: _ctx.readonly,
          maxlength: _ctx.maxlength || -1,
          onFocus: _cache[0] || (_cache[0] = function () {
            return _ctx.handleFocus && _ctx.handleFocus.apply(_ctx, arguments);
          }),
          onBlur: _cache[1] || (_cache[1] = function () {
            return _ctx.handleBlur && _ctx.handleBlur.apply(_ctx, arguments);
          }),
          onInput: _cache[2] || (_cache[2] = function () {
            return _ctx.handleInput && _ctx.handleInput.apply(_ctx, arguments);
          }),
          onCompositionend: _cache[3] || (_cache[3] = function () {
            return _ctx.handleCompositionend && _ctx.handleCompositionend.apply(_ctx, arguments);
          })
        }, null, 42, _hoisted_1$m), _ctx.clearable && _ctx.innerValue && _ctx.innerValue.length > 0 ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass("".concat(_ctx.componentName, "__wrap--icon")),
          onClick: _cache[4] || (_cache[4] = function () {
            return _ctx.handleClear && _ctx.handleClear.apply(_ctx, arguments);
          })
        }, [vue.createVNode(_component_close_circle_filled_icon)], 2)) : vue.createCommentVNode("", true), _ctx.suffixContent ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 1,
          class: vue.normalizeClass("".concat(_ctx.componentName, "__wrap--suffix"))
        }, [vue.createVNode(_component_t_node, {
          content: _ctx.suffixContent
        }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2), _ctx.errorMessage ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass("".concat(_ctx.componentName, "__error-msg"))
        }, vue.toDisplayString(_ctx.errorMessage), 3)) : vue.createCommentVNode("", true)];
      }),
      _: 2
    }, [_ctx.labelContent ? {
      name: "title",
      fn: vue.withCtx(function () {
        return [vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.styleLabel)
        }, [vue.createVNode(_component_t_node, {
          content: _ctx.labelContent
        }, null, 8, ["content"])], 2)];
      }),
      key: "0"
    } : void 0, _ctx.prefixIconContent ? {
      name: "leftIcon",
      fn: vue.withCtx(function () {
        return [vue.createVNode(_component_t_node, {
          content: _ctx.prefixIconContent
        }, null, 8, ["content"])];
      }),
      key: "1"
    } : void 0, _ctx.suffixIconContent ? {
      name: "rightIcon",
      fn: vue.withCtx(function () {
        return [vue.createVNode(_component_t_node, {
          content: _ctx.suffixIconContent
        }, null, 8, ["content"])];
      }),
      key: "2"
    } : void 0]), 1032, ["required", "class"]);
  }

  script$$.render = render$_;

  var _Input = withInstall(script$$);

  var TextareaProps = {
    autofocus: Boolean,
    autosize: Boolean,
    disabled: Boolean,
    label: {
      type: [String, Function]
    },
    maxcharacter: {
      type: Number
    },
    maxlength: {
      type: Number
    },
    name: {
      type: String,
      default: ""
    },
    placeholder: {
      type: String,
      default: void 0
    },
    value: {
      type: [String, Number],
      default: void 0
    },
    modelValue: {
      type: [String, Number],
      default: void 0
    },
    defaultValue: {
      type: [String, Number],
      default: void 0
    },
    onBlur: Function,
    onChange: Function,
    onFocus: Function
  };

  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null) return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      target[key] = source[key];
    }
    return target;
  }

  function _objectWithoutProperties(source, excluded) {
    if (source == null) return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
        target[key] = source[key];
      }
    }
    return target;
  }

  function getIEVersion() {
    var _navigator = navigator,
      userAgent = _navigator.userAgent;
    var isIE = userAgent.indexOf("compatible") > -1 && userAgent.indexOf("MSIE") > -1;
    var isIE11 = userAgent.indexOf("Trident") > -1 && userAgent.indexOf("rv:11.0") > -1;
    if (isIE) {
      var reIE = new RegExp("MSIE (\\d+\\.\\d+);");
      var match = userAgent.match(reIE);
      if (!match) return -1;
      var fIEVersion = parseFloat(match[1]);
      return fIEVersion < 7 ? 6 : fIEVersion;
    }
    if (isIE11) {
      return 11;
    }
    return Number.MAX_SAFE_INTEGER;
  }
  var DOM_STYLE_PROPS = ["padding-top", "padding-bottom", "padding-left", "padding-right", "font-family", "font-weight", "font-size", "font-variant", "text-rendering", "text-transform", "width", "text-indent", "border-width", "box-sizing", "line-height", "letter-spacing"];
  function calculateNodeSize(targetElement) {
    var style = window.getComputedStyle(targetElement);
    var boxSizing = style.getPropertyValue("box-sizing") || style.getPropertyValue("-moz-box-sizing") || style.getPropertyValue("-webkit-box-sizing");
    var paddingSize = parseFloat(style.getPropertyValue("padding-bottom")) + parseFloat(style.getPropertyValue("padding-top"));
    var borderSize = parseFloat(style.getPropertyValue("border-bottom-width")) + parseFloat(style.getPropertyValue("border-top-width"));
    var sizingStyle = DOM_STYLE_PROPS.map(function (name) {
      return "".concat(name, ":").concat(style.getPropertyValue(name));
    }).join(";");
    return {
      paddingSize: paddingSize,
      borderSize: borderSize,
      boxSizing: boxSizing,
      sizingStyle: sizingStyle
    };
  }

  var TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important\n";
  var hiddenTextarea;
  function calcTextareaHeight(targetElement) {
    var _hiddenTextarea, _hiddenTextarea$paren;
    var minRows = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var maxRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    if (!hiddenTextarea) {
      hiddenTextarea = document.createElement("textarea");
      document.body.appendChild(hiddenTextarea);
    }
    var _calculateNodeSize = calculateNodeSize(targetElement),
      paddingSize = _calculateNodeSize.paddingSize,
      borderSize = _calculateNodeSize.borderSize,
      boxSizing = _calculateNodeSize.boxSizing,
      sizingStyle = _calculateNodeSize.sizingStyle;
    hiddenTextarea.setAttribute("style", "".concat(sizingStyle, ";").concat(TEXTAREA_STYLE));
    hiddenTextarea.value = targetElement.value || targetElement.placeholder || "";
    var height = hiddenTextarea.scrollHeight;
    var result = {};
    var isBorderbox = boxSizing === "border-box";
    var isContentbox = boxSizing === "content-box";
    if (isBorderbox) {
      height += borderSize;
    } else if (isContentbox) {
      height -= paddingSize;
    }
    hiddenTextarea.value = "";
    var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
    (_hiddenTextarea = hiddenTextarea) === null || _hiddenTextarea === void 0 ? void 0 : (_hiddenTextarea$paren = _hiddenTextarea.parentNode) === null || _hiddenTextarea$paren === void 0 ? void 0 : _hiddenTextarea$paren.removeChild(hiddenTextarea);
    hiddenTextarea = null;
    var calcHeight = function calcHeight(rows) {
      var rowsHeight = singleRowHeight * rows;
      if (isBorderbox) {
        rowsHeight = rowsHeight + paddingSize + borderSize;
      }
      return rowsHeight;
    };
    if (minRows !== null) {
      var minHeight = calcHeight(minRows);
      height = Math.max(minHeight, height);
      result.minHeight = "".concat(minHeight, "px");
    }
    if (maxRows !== null) {
      height = Math.min(calcHeight(maxRows), height);
    }
    result.height = "".concat(height, "px");
    return result;
  }

  function ownKeys$D(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$D(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$D(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$D(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$X = config.prefix;
  var componentName$4 = "".concat(prefix$X, "-textarea");
  var script$_ = vue.defineComponent({
    name: componentName$4,
    components: {
      TNode: TNodeComponent
    },
    props: TextareaProps,
    emits: ["update:value", "update:modelValue", "focus", "blur", "change"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var textareaRef = vue.ref(null);
      var textareaStyle = vue.ref();
      var textareaLength = vue.ref(0);
      var _toRefs = vue.toRefs(props),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        innerValue = _useVModel2[0],
        setInnerValue = _useVModel2[1];
      var textareaClassNames = vue.computed(function () {
        return ["".concat(componentName$4, "__wrapper"), _defineProperty$2({}, "".concat(componentName$4, "-is-disabled"), props.disabled)];
      });
      var internalInstance = vue.getCurrentInstance();
      var labelContent = vue.computed(function () {
        return renderTNode(internalInstance, "label");
      });
      var setInputValue = function setInputValue() {
        var v = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : "";
        var input = textareaRef.value;
        var sV = String(v);
        if (!input) {
          return;
        }
        if (input.value !== sV) {
          input.value = sV;
        }
      };
      var adjustTextareaHeight = function adjustTextareaHeight() {
        if (props.autosize === true) {
          textareaStyle.value = calcTextareaHeight(textareaRef.value);
        } else if (_typeof$1(props.autosize) === "object") {
          var _props$autosize = props.autosize,
            minRows = _props$autosize.minRows,
            maxRows = _props$autosize.maxRows;
          textareaStyle.value = calcTextareaHeight(textareaRef.value, minRows, maxRows);
        } else if (context.attrs.rows) {
          textareaStyle.value = {
            height: "auto",
            minHeight: "auto"
          };
        }
      };
      var handleInput = function handleInput(e) {
        if (e.isComposing || e.inputType === "insertCompositionText") return;
        textareaValueChangeHandle(e);
      };
      var textareaValueChangeHandle = function textareaValueChangeHandle(e) {
        var target = e.target;
        var value2 = target.value;
        if (props.maxcharacter && props.maxcharacter > 0 && !Number.isNaN(props.maxcharacter)) {
          var _getCharacterLength = getCharacterLength(value2, props.maxcharacter),
            _getCharacterLength$l = _getCharacterLength.length,
            length = _getCharacterLength$l === void 0 ? 0 : _getCharacterLength$l,
            _getCharacterLength$c = _getCharacterLength.characters,
            characters = _getCharacterLength$c === void 0 ? "" : _getCharacterLength$c;
          setInnerValue(characters);
          textareaLength.value = length;
        } else {
          setInnerValue(value2);
          textareaLength.value = String(innerValue.value).length;
        }
        vue.nextTick(function () {
          return setInputValue(innerValue.value);
        });
        adjustTextareaHeight();
      };
      var handleCompositionend = function handleCompositionend(e) {
        textareaValueChangeHandle(e);
      };
      var handleFocus = function handleFocus(e) {
        emitEvent("focus", innerValue.value, {
          e: e
        });
      };
      var handleBlur = function handleBlur(e) {
        emitEvent("blur", innerValue.value, {
          e: e
        });
      };
      vue.onMounted(function () {
        if (props.autofocus) {
          var _textareaRef$value;
          (_textareaRef$value = textareaRef.value) === null || _textareaRef$value === void 0 ? void 0 : _textareaRef$value.focus();
        }
        adjustTextareaHeight();
      });
      return _objectSpread$D(_objectSpread$D({
        componentName: componentName$4
      }, vue.toRefs(props)), {}, {
        labelContent: labelContent,
        innerValue: innerValue,
        textareaRef: textareaRef,
        textareaStyle: textareaStyle,
        textareaClassNames: textareaClassNames,
        textareaLength: textareaLength,
        handleFocus: handleFocus,
        handleBlur: handleBlur,
        handleInput: handleInput,
        handleCompositionend: handleCompositionend
      });
    }
  });

  var _hoisted_1$l = ["value", "name", "maxlength", "disabled", "placeholder"];
  function render$Z(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.componentName)
    }, [_ctx.labelContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.componentName, "__name"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.labelContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), vue.createElementVNode("div", {
      class: vue.normalizeClass(_ctx.textareaClassNames)
    }, [vue.createElementVNode("textarea", {
      ref: "textareaRef",
      value: _ctx.innerValue,
      style: vue.normalizeStyle(_ctx.textareaStyle),
      name: _ctx.name,
      maxlength: _ctx.maxlength || -1,
      disabled: _ctx.disabled,
      placeholder: _ctx.placeholder,
      onFocus: _cache[0] || (_cache[0] = function () {
        return _ctx.handleFocus && _ctx.handleFocus.apply(_ctx, arguments);
      }),
      onBlur: _cache[1] || (_cache[1] = function () {
        return _ctx.handleBlur && _ctx.handleBlur.apply(_ctx, arguments);
      }),
      onInput: _cache[2] || (_cache[2] = function () {
        return _ctx.handleInput && _ctx.handleInput.apply(_ctx, arguments);
      }),
      onCompositionend: _cache[3] || (_cache[3] = function () {
        return _ctx.handleCompositionend && _ctx.handleCompositionend.apply(_ctx, arguments);
      })
    }, null, 44, _hoisted_1$l), _ctx.maxcharacter || _ctx.maxlength ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.componentName, "__count"))
    }, vue.toDisplayString("".concat(_ctx.textareaLength, "/").concat(_ctx.maxcharacter || _ctx.maxlength)), 3)) : vue.createCommentVNode("", true)], 2)], 2);
  }

  script$_.render = render$Z;

  var _Textarea = withInstall(script$_);

  var _excluded = ["from", "to", "direction"];
  function getBackgroundColor(color) {
    if (typeof color === "string") {
      return color;
    }
    if (Array.isArray(color)) {
      if (color[0] && color[0][0] === "#") {
        color.unshift("90deg");
      }
      return "linear-gradient( ".concat(color.join(","), " )");
    }
    var from = color.from,
      to = color.to,
      _color$direction = color.direction,
      direction = _color$direction === void 0 ? "to right" : _color$direction,
      rest = _objectWithoutProperties(color, _excluded);
    var keys = Object.keys(rest);
    if (keys.length) {
      keys = keys.sort(function (a, b) {
        return parseFloat(a.substr(0, a.length - 1)) - parseFloat(b.substr(0, b.length - 1));
      });
      var tempArr = keys.map(function (key) {
        return "".concat(rest[key], " ").concat(key);
      });
      return "linear-gradient(".concat(direction, ", ").concat(tempArr.join(","), ")");
    }
    return "linear-gradient(".concat(direction, ", ").concat(from, ", ").concat(to, ")");
  }

  var progressProps = {
    color: {
      type: [String, Object, Array],
      default: ""
    },
    label: {
      type: [String, Boolean, Function],
      default: true
    },
    percentage: {
      type: Number,
      default: 0
    },
    status: {
      type: String,
      validator: function validator(val) {
        if (!val) return true;
        return ["success", "error", "warning", "active"].includes(val);
      }
    },
    strokeWidth: {
      type: [String, Number]
    },
    trackColor: {
      type: String,
      default: ""
    }
  };

  var prefix$W = config.prefix;
  var name$T = "".concat(prefix$W, "-progress");
  var script$Z = vue.defineComponent({
    name: name$T,
    components: {
      TNode: TNodeComponent
    },
    props: progressProps,
    setup: function setup(props) {
      var progressPercent = vue.computed(function () {
        return Math.max(0, Math.min(props.percentage, 100));
      });
      var progressStatusStyle = vue.computed(function () {
        if (props.percentage >= 100) {
          return "success";
        }
        return props.status;
      });
      var progressBarStyle = vue.computed(function () {
        var height = typeof props.strokeWidth === "string" ? props.strokeWidth : "".concat(props.strokeWidth, "px");
        return {
          height: height,
          backgroundColor: props.trackColor
        };
      });
      var progressBarPercenStyle = vue.computed(function () {
        return {
          width: "".concat(progressPercent.value, "%"),
          background: props.color && getBackgroundColor(props.color)
        };
      });
      var rootClasses = vue.computed(function () {
        return ["".concat(name$T), "".concat(name$T, "--status--").concat(progressStatusStyle.value)];
      });
      var internalInstance = vue.getCurrentInstance();
      var progressLabelContent = vue.computed(function () {
        return props.label && (_typeof$1(renderTNode(internalInstance, "label")) === "object" ? renderTNode(internalInstance, "label") : "".concat(progressPercent.value, "%"));
      });
      return {
        name: name$T,
        rootClasses: rootClasses,
        progressBarPercenStyle: progressBarPercenStyle,
        progressBarStyle: progressBarStyle,
        progressLabelContent: progressLabelContent
      };
    }
  });

  function render$Y(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.rootClasses)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__inner"))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__bar")),
      style: vue.normalizeStyle(_ctx.progressBarStyle)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__bar-percent")),
      style: vue.normalizeStyle(_ctx.progressBarPercenStyle)
    }, null, 6)], 6), _ctx.progressLabelContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__label"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.progressLabelContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2)], 2);
  }

  script$Z.render = render$Y;

  var _Progress = withInstall(script$Z);

  var RadioProps = {
    align: {
      type: String,
      default: "left",
      validator: function validator(val) {
        return ["left", "right"].includes(val);
      }
    },
    checked: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultChecked: Boolean,
    content: {
      type: [String, Function]
    },
    contentDisabled: Boolean,
    default: {
      type: [String, Function]
    },
    disabled: {
      type: Boolean,
      default: void 0
    },
    icon: {
      type: [String, Array],
      default: "fill-circle"
    },
    label: {
      type: [String, Function]
    },
    name: {
      type: String,
      default: ""
    },
    value: {
      type: [String, Number, Boolean],
      default: false
    },
    onChange: Function
  };

  function ownKeys$C(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$C(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$C(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$C(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$V = config.prefix;
  var name$S = "".concat(prefix$V, "-radio");
  var iconDefault$3 = [vue.h(check), ""];
  var script$Y = vue.defineComponent({
    name: name$S,
    components: {
      TNode: TNodeComponent
    },
    props: _objectSpread$C(_objectSpread$C({}, RadioProps), {}, {
      borderless: {
        type: Boolean,
        value: false
      }
    }),
    emits: ["update:checked", "update:modelValue", "change"],
    setup: function setup(props, context) {
      var _toRefs = vue.toRefs(props),
        checked = _toRefs.checked,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(checked, modelValue, props.defaultChecked, props.onChange, "checked"),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        innerChecked = _useVModel2[0],
        setInnerChecked = _useVModel2[1];
      var rootGroupProps = vue.inject("rootGroupProps", {});
      var rootGroupValue = vue.inject("rootGroupValue");
      var rootGroupChange = vue.inject("rootGroupChange", NOOP);
      var disabled = vue.computed(function () {
        return rootGroupProps.disabled !== void 0 ? rootGroupProps.disabled : props.disabled;
      });
      var radioChecked = vue.computed(function () {
        return rootGroupValue ? props.value === rootGroupValue.value : innerChecked.value;
      });
      var inputProps = vue.computed(function () {
        return {
          name: rootGroupProps.name || props.name,
          checked: radioChecked.value,
          disabled: disabled.value,
          value: props.value
        };
      });
      var internalInstance = vue.getCurrentInstance();
      var labelContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "label");
      });
      var radioContent = vue.computed(function () {
        return renderTNode(internalInstance, "content");
      });
      var iconContent = vue.computed(function () {
        if (!props.icon) {
          return;
        }
        var iconIndex = radioChecked.value ? 0 : 1;
        var isIconArray = Array.isArray(props.icon);
        if (isIconArray) {
          return props.icon[iconIndex];
        }
        return iconDefault$3[iconIndex];
      });
      var radioClasses = vue.computed(function () {
        var _ref;
        return ["".concat(name$S), (_ref = {}, _defineProperty$2(_ref, ClASSNAMES.STATUS.checked, radioChecked.value), _defineProperty$2(_ref, ClASSNAMES.STATUS.disabled, disabled.value), _ref)];
      });
      var titleClasses = vue.computed(function () {
        var _ref2;
        return ["".concat(name$S, "__content-title"), (_ref2 = {}, _defineProperty$2(_ref2, ClASSNAMES.STATUS.disabled, disabled.value), _defineProperty$2(_ref2, "".concat(name$S, "__content-right-title"), props.align === "right"), _ref2)];
      });
      var iconClass = vue.computed(function () {
        var _ref3;
        return ["".concat(name$S, "__icon"), (_ref3 = {}, _defineProperty$2(_ref3, "".concat(name$S, "__icon--checked"), radioChecked.value), _defineProperty$2(_ref3, "".concat(name$S, "__icon--disabled"), disabled.value), _defineProperty$2(_ref3, "".concat(name$S, "__icon--strock"), props.icon === "stroke-line"), _defineProperty$2(_ref3, "".concat(name$S, "__icon--custom"), Array.isArray(props.icon)), _ref3)];
      });
      var radioContentChange = function radioContentChange(e) {
        if (props.contentDisabled) {
          return;
        }
        radioOrgChange(e);
      };
      var radioOrgChange = function radioOrgChange(e) {
        if (disabled.value) {
          return;
        }
        if (rootGroupChange !== NOOP && props.value !== void 0) {
          rootGroupChange(props.value, e);
        } else {
          setInnerChecked(!radioChecked.value, {
            e: e
          });
        }
      };
      return {
        name: name$S,
        iconClass: iconClass,
        radioContent: radioContent,
        labelContent: labelContent,
        iconContent: iconContent,
        radioContentChange: radioContentChange,
        radioOrgChange: radioOrgChange,
        radioClasses: radioClasses,
        titleClasses: titleClasses,
        inputProps: inputProps
      };
    }
  });

  function render$X(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.radioClasses)
    }, [vue.createElementVNode("span", {
      class: vue.normalizeClass(["".concat(_ctx.name, "__content-wrap")])
    }, [_ctx.align === "left" ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__icon-wrap ").concat(_ctx.name, "__icon-left-wrap"))
    }, [vue.createElementVNode("input", vue.mergeProps({
      type: "radio",
      class: "".concat(_ctx.name, "__original-left")
    }, _ctx.inputProps, {
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.radioOrgChange && _ctx.radioOrgChange.apply(_ctx, arguments);
      })
    }), null, 16), vue.createElementVNode("div", {
      class: vue.normalizeClass(_ctx.iconClass)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"])], 2)], 2)) : vue.createCommentVNode("", true), _ctx.labelContent || _ctx.radioContent ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 1,
      class: vue.normalizeClass(["".concat(_ctx.name, "__label-wrap")])
    }, [_ctx.labelContent ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass(_ctx.titleClasses),
      onClick: _cache[1] || (_cache[1] = function () {
        return _ctx.radioOrgChange && _ctx.radioOrgChange.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.labelContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), _ctx.radioContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__content-inner")),
      onClick: _cache[2] || (_cache[2] = function () {
        return _ctx.radioContentChange && _ctx.radioContentChange.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.radioContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2)) : vue.createCommentVNode("", true), _ctx.align === "right" ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 2,
      class: vue.normalizeClass("".concat(_ctx.name, "__icon-wrap ").concat(_ctx.name, "__icon-right-wrap"))
    }, [vue.createElementVNode("input", vue.mergeProps({
      type: "radio",
      class: "".concat(_ctx.name, "__original-right")
    }, _ctx.inputProps, {
      onClick: _cache[3] || (_cache[3] = function () {
        return _ctx.radioOrgChange && _ctx.radioOrgChange.apply(_ctx, arguments);
      })
    }), null, 16), vue.createElementVNode("div", {
      class: vue.normalizeClass(_ctx.iconClass)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"])], 2)], 2)) : vue.createCommentVNode("", true)], 2), !_ctx.borderless ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__border ").concat(_ctx.name, "__border--").concat(_ctx.align))
    }, null, 2)) : vue.createCommentVNode("", true)], 2);
  }

  script$Y.render = render$X;

  var _Radio = withInstall(script$Y);

  var RadioGroupProps = {
    disabled: {
      type: Boolean,
      default: void 0
    },
    name: {
      type: String,
      default: ""
    },
    options: {
      type: Array
    },
    value: {
      type: [String, Number, Boolean],
      default: void 0
    },
    modelValue: {
      type: [String, Number, Boolean],
      default: void 0
    },
    defaultValue: {
      type: [String, Number, Boolean],
      default: false
    },
    onChange: Function
  };

  function ownKeys$B(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$B(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$B(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$B(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$U = config.prefix;
  var componentName$3 = "".concat(prefix$U, "-radio-group");
  var script$X = vue.defineComponent({
    name: componentName$3,
    components: {
      Radio: script$Y
    },
    props: RadioGroupProps,
    emits: ["update:value", "update:modelValue", "change"],
    setup: function setup(props, context) {
      var _useDefault = useDefault(props, context.emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 2),
        groupValue = _useDefault2[0],
        setGroupValue = _useDefault2[1];
      var groupOptions = vue.computed(function () {
        var _props$options;
        return (_props$options = props.options) === null || _props$options === void 0 ? void 0 : _props$options.map(function (option) {
          var opt = option;
          if (typeof option === "string" || typeof option === "number") {
            opt = {
              value: option,
              label: option.toString()
            };
          }
          return opt;
        });
      });
      var handleRadioChange = function handleRadioChange(val, e) {
        setGroupValue(val, {
          e: e
        });
      };
      vue.provide("rootGroupProps", props);
      vue.provide("rootGroupValue", groupValue);
      vue.provide("rootGroupChange", handleRadioChange);
      return _objectSpread$B(_objectSpread$B({}, vue.toRefs(props)), {}, {
        componentName: componentName$3,
        groupOptions: groupOptions
      });
    }
  });

  function render$W(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_radio = vue.resolveComponent("radio");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.componentName),
      role: "radiogroup"
    }, [_ctx.options ? (vue.openBlock(true), vue.createElementBlock(vue.Fragment, {
      key: 0
    }, vue.renderList(_ctx.groupOptions, function (opt, idx) {
      return vue.openBlock(), vue.createBlock(_component_radio, {
        key: "radio-group-options-".concat(idx, "-").concat(Math.random()),
        name: _ctx.name,
        checked: _ctx.value === opt.value,
        disabled: "disabled" in opt ? opt.disabled : _ctx.disabled,
        value: opt.value,
        label: opt.label
      }, null, 8, ["name", "checked", "disabled", "value", "label"]);
    }), 128)) : vue.createCommentVNode("", true), !_ctx.options ? vue.renderSlot(_ctx.$slots, "default", {
      key: 1
    }) : vue.createCommentVNode("", true)], 2);
  }

  script$X.render = render$W;

  var _RadioGroup = withInstall(script$X);

  var rateProps = {
    allowHalf: Boolean,
    clearable: Boolean,
    color: {
      type: [String, Array]
    },
    count: {
      type: Number,
      default: 5
    },
    disabled: Boolean,
    gap: {
      type: Number,
      default: 6
    },
    showText: Boolean,
    size: {
      type: String,
      default: ""
    },
    texts: {
      type: Array
    },
    value: {
      type: Number,
      default: void 0
    },
    modelValue: {
      type: Number,
      default: void 0
    },
    defaultValue: {
      type: Number,
      default: void 0
    },
    variant: {
      type: String,
      default: "filled",
      validator: function validator(val) {
        return ["outline", "filled"].includes(val);
      }
    },
    onChange: Function
  };

  var prefix$T = config.prefix;
  var name$R = "".concat(prefix$T, "-rate");
  var script$W = vue.defineComponent({
    name: name$R,
    components: {
      StarFilledIcon: starFilled,
      StarIcon: star
    },
    props: rateProps,
    emits: ["change", "update:value", "update:modelValue"],
    setup: function setup(props, context) {
      var rateWrapper = vue.ref(null);
      var _useDefault = useDefault(props, context.emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 1),
        actualVal = _useDefault2[0];
      var rateText = vue.computed(function () {
        if (Array.isArray(props.texts) && props.texts.length > 0) {
          return props.texts[actualVal.value - 1];
        }
        return actualVal.value > 0 ? "".concat(actualVal.value, " \u5206") : "";
      });
      var colors = vue.computed(function () {
        if (Array.isArray(props.color)) return props.color;
        return [props.color, void 0];
      });
      var iconHalfStyle = function iconHalfStyle(n) {
        return {
          color: actualVal.value + 0.5 === n || actualVal.value >= n ? colors.value[0] : "transparent"
        };
      };
      var iconFullStyle = function iconFullStyle(n) {
        return {
          color: actualVal.value >= n ? colors.value[0] : "transparent"
        };
      };
      var startComponent = props.variant === "filled" ? starFilled : star;
      var classes = function classes(n) {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$R, "--item"), true), _defineProperty$2(_ref, "".concat(name$R, "-full"), actualVal.value >= n), _defineProperty$2(_ref, "".concat(name$R, "-half"), actualVal.value + 0.5 === n), _ref;
      };
      function onClick(current) {
        if (props.disabled) return;
        actualVal.value = props.clearable && actualVal.value === current ? 0 : current;
      }
      var ranges = [];
      function onTouchstart() {
        ranges = [];
        if (rateWrapper.value) {
          var items = rateWrapper.value.children;
          Array.from(items).forEach(function (node, index) {
            var _node$getBoundingClie = node.getBoundingClientRect(),
              left = _node$getBoundingClie.left,
              width = _node$getBoundingClie.width;
            if (props.allowHalf) {
              ranges.push({
                score: index + 0.5,
                left: left
              }, {
                score: index + 1,
                left: left + width / 2
              });
            } else {
              ranges.push({
                score: index + 1,
                left: left
              });
            }
          });
        }
      }
      function onTouchmove(e) {
        if (props.disabled) return;
        var clientX = e.touches[0].clientX;
        var score = props.allowHalf ? 0.5 : 1;
        for (var i = ranges.length - 1; i >= 0; i--) {
          if (clientX > ranges[i].left) {
            score = ranges[i].score;
            break;
          } else {
            score = 0;
          }
        }
        actualVal.value = score;
      }
      return {
        name: vue.ref(name$R),
        classes: classes,
        rateWrapper: rateWrapper,
        actualVal: actualVal,
        iconHalfStyle: iconHalfStyle,
        iconFullStyle: iconFullStyle,
        colors: colors,
        startComponent: startComponent,
        rateText: rateText,
        onClick: onClick,
        onTouchstart: onTouchstart,
        onTouchmove: onTouchmove
      };
    }
  });

  var _hoisted_1$k = ["onClick"];
  var _hoisted_2$7 = ["onClick"];
  var _hoisted_3$1 = ["onClick"];
  function render$V(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_star_filled_icon = vue.resolveComponent("star-filled-icon");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass("".concat(_ctx.name))
    }, [vue.createElementVNode("ul", {
      ref: "rateWrapper",
      class: vue.normalizeClass("".concat(_ctx.name, "--list")),
      onTouchstart: _cache[0] || (_cache[0] = function () {
        return _ctx.onTouchstart && _ctx.onTouchstart.apply(_ctx, arguments);
      }),
      onTouchmove: _cache[1] || (_cache[1] = function () {
        return _ctx.onTouchmove && _ctx.onTouchmove.apply(_ctx, arguments);
      })
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.count, function (n) {
      return vue.openBlock(), vue.createElementBlock("li", {
        key: n,
        class: vue.normalizeClass(_ctx.classes(n)),
        style: vue.normalizeStyle({
          marginRight: "".concat(_ctx.count > n ? _ctx.gap : 0, "px")
        })
      }, [vue.createElementVNode("span", {
        class: vue.normalizeClass("".concat(_ctx.name, "--placeholder"))
      }, [vue.renderSlot(_ctx.$slots, "icon", {}, function () {
        return [(vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.startComponent), {
          size: _ctx.size,
          style: vue.normalizeStyle({
            color: _ctx.colors[1]
          })
        }, null, 8, ["size", "style"]))];
      })], 2), _ctx.allowHalf ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
        key: 0
      }, [vue.createElementVNode("span", {
        class: vue.normalizeClass("".concat(_ctx.name, "--icon-left")),
        onClick: function onClick($event) {
          return _ctx.onClick(n - 0.5);
        }
      }, [vue.renderSlot(_ctx.$slots, "icon", {}, function () {
        return [vue.createVNode(_component_star_filled_icon, {
          size: _ctx.size,
          style: vue.normalizeStyle(_ctx.iconHalfStyle(n))
        }, null, 8, ["size", "style"])];
      })], 10, _hoisted_1$k), vue.createElementVNode("span", {
        class: vue.normalizeClass("".concat(_ctx.name, "--icon-right")),
        onClick: function onClick($event) {
          return _ctx.onClick(n);
        }
      }, [vue.renderSlot(_ctx.$slots, "icon", {}, function () {
        return [vue.createVNode(_component_star_filled_icon, {
          size: _ctx.size,
          style: vue.normalizeStyle(_ctx.iconFullStyle(n))
        }, null, 8, ["size", "style"])];
      })], 10, _hoisted_2$7)], 64)) : (vue.openBlock(), vue.createElementBlock("span", {
        key: 1,
        class: vue.normalizeClass("".concat(_ctx.name, "--icon")),
        onClick: function onClick($event) {
          return _ctx.onClick(n);
        }
      }, [vue.renderSlot(_ctx.$slots, "icon", {}, function () {
        return [vue.createVNode(_component_star_filled_icon, {
          size: _ctx.size,
          style: vue.normalizeStyle(_ctx.iconFullStyle(n))
        }, null, 8, ["size", "style"])];
      })], 10, _hoisted_3$1))], 6);
    }), 128))], 34), _ctx.showText ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "--text"))
    }, vue.toDisplayString(_ctx.rateText), 3)) : vue.createCommentVNode("", true)], 2);
  }

  script$W.render = render$V;

  var _Rate = withInstall(script$W);

  var SwitchProps = {
    colors: {
      type: Array
    },
    customValue: {
      type: Array
    },
    disabled: Boolean,
    label: {
      type: String,
      default: ""
    },
    value: {
      type: [String, Number, Boolean],
      default: void 0
    },
    modelValue: {
      type: [String, Number, Boolean],
      default: void 0
    },
    defaultValue: {
      type: [String, Number, Boolean],
      default: void 0
    },
    onChange: Function
  };

  function ownKeys$A(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$A(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$A(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$A(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$S = config.prefix;
  var name$Q = "".concat(prefix$S, "-switch");
  var script$V = vue.defineComponent({
    name: name$Q,
    props: SwitchProps,
    emits: ["change", "update:value", "update:modelValue"],
    setup: function setup(props, context) {
      var switchValues = props.customValue || [true, false];
      var _useDefault = useDefault(props, context.emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 1),
        innerValue = _useDefault2[0];
      var _useToggle = useToggle(switchValues, innerValue.value),
        state = _useToggle.state,
        toggle = _useToggle.toggle;
      var classes = vue.computed(function () {
        var _ref;
        return ["".concat(name$Q), (_ref = {}, _defineProperty$2(_ref, ClASSNAMES.STATUS.checked, innerValue.value === switchValues[0]), _defineProperty$2(_ref, ClASSNAMES.STATUS.disabled, props.disabled), _ref)];
      });
      var backgroundColor = vue.computed(function () {
        if (!props.disabled && props.colors) {
          return "background-color: ".concat(innerValue.value === switchValues[0] ? props.colors[0] : props.colors[1]);
        }
        return "";
      });
      function handleToggle(event) {
        event.preventDefault();
        if (props.disabled) {
          return;
        }
        toggle();
        innerValue.value = state.value;
      }
      return _objectSpread$A(_objectSpread$A({
        name: name$Q,
        classes: classes,
        backgroundColor: backgroundColor
      }, vue.toRefs(props)), {}, {
        handleToggle: handleToggle
      });
    }
  });

  function render$U(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("span", {
      class: vue.normalizeClass(_ctx.classes)
    }, [_ctx.label ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__text"))
    }, vue.toDisplayString(_ctx.label), 3)) : vue.createCommentVNode("", true), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, "__node")),
      style: vue.normalizeStyle(_ctx.backgroundColor),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.handleToggle && _ctx.handleToggle.apply(_ctx, arguments);
      })
    }, null, 6)], 2);
  }

  script$V.render = render$U;

  var _Switch = withInstall(script$V);

  var StepperProps = {
    disabled: Boolean,
    disableInput: Boolean,
    inputWidth: {
      type: Number
    },
    max: {
      type: Number,
      default: 100
    },
    min: {
      type: Number,
      default: 0
    },
    step: {
      type: Number,
      default: 1
    },
    theme: {
      type: String,
      default: "normal",
      validator: function validator(val) {
        return ["normal", "grey"].includes(val);
      }
    },
    value: {
      type: [String, Number],
      default: void 0
    },
    modelValue: {
      type: [String, Number],
      default: void 0
    },
    defaultValue: {
      type: [String, Number],
      default: 0
    },
    onBlur: Function,
    onChange: Function,
    onOverlimit: Function
  };

  function ownKeys$z(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$z(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$z(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$z(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$R = config.prefix;
  var name$P = "".concat(prefix$R, "-stepper");
  var disabledClass = ClASSNAMES.STATUS.disabled;
  var script$U = vue.defineComponent({
    name: name$P,
    components: {
      AddIcon: add,
      RemoveIcon: remove
    },
    props: StepperProps,
    emits: ["update:value", "update:modelValue", "blur", "change", "overlimit"],
    setup: function setup(props, context) {
      var _useDefault = useDefault(props, context.emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 1),
        stepperValue = _useDefault2[0];
      var emitEvent = useEmitEvent(props, context.emit);
      var _toRefs = vue.toRefs(props),
        min = _toRefs.min,
        max = _toRefs.max,
        step = _toRefs.step,
        inputWidth = _toRefs.inputWidth,
        theme = _toRefs.theme,
        disabled = _toRefs.disabled;
      var isPureMode = vue.computed(function () {
        return theme.value === "grey";
      });
      var inputStyle = vue.computed(function () {
        return inputWidth ? {
          width: "".concat(inputWidth.value, "px")
        } : "";
      });
      var isDisabled = function isDisabled(type) {
        if (disabled.value) return true;
        if (type === "minus" && stepperValue.value <= min.value) {
          return true;
        }
        if (type === "plus" && stepperValue.value >= max.value) {
          return true;
        }
        return false;
      };
      var formatValue = function formatValue(value) {
        return Math.max(Math.min(max.value, value, Number.MAX_SAFE_INTEGER), min.value, Number.MIN_SAFE_INTEGER);
      };
      var updateValue = function updateValue(value) {
        stepperValue.value = formatValue(value);
      };
      var plusValue = function plusValue() {
        if (isDisabled("plus")) {
          emitEvent("overlimit", "plus");
          return;
        }
        updateValue(Number(stepperValue.value) + step.value);
      };
      var minusValue = function minusValue() {
        if (isDisabled("minus")) {
          emitEvent("overlimit", "minus");
          return;
        }
        updateValue(Number(stepperValue.value) - step.value);
      };
      var handleInput = function handleInput(e) {
        handleChange(e);
      };
      var handleChange = function handleChange(e) {
        var value = e.target.value.match(/^\d+\.\d+|^\d+/g);
        if (isNaN(Number(value))) return;
        var formattedValue = formatValue(Number(value));
        updateValue(Number(formattedValue));
      };
      var handleBlur = function handleBlur(e) {
        handleChange(e);
        emitEvent("blur", stepperValue.value);
      };
      return _objectSpread$z({
        name: name$P,
        disabledClass: disabledClass,
        minusValue: minusValue,
        stepperValue: stepperValue,
        plusValue: plusValue,
        handleInput: handleInput,
        handleChange: handleChange,
        inputStyle: inputStyle,
        handleBlur: handleBlur,
        isPureMode: isPureMode
      }, vue.toRefs(props));
    }
  });

  var _hoisted_1$j = ["disabled", "readonly"];
  function render$T(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_remove_icon = vue.resolveComponent("remove-icon");
    var _component_add_icon = vue.resolveComponent("add-icon");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(["".concat(_ctx.name), "".concat(_ctx.disabled ? _ctx.disabledClass : ""), "".concat(_ctx.isPureMode ? "".concat(_ctx.name, "__pure") : "")])
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass(["".concat(_ctx.name, "__minus"), "".concat(_ctx.disabled || _ctx.stepperValue <= _ctx.min ? "t-is-disabled" : "")]),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.minusValue && _ctx.minusValue.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_remove_icon, {
      class: vue.normalizeClass("".concat(_ctx.name, "__icon"))
    }, null, 8, ["class"])], 2), vue.withDirectives(vue.createElementVNode("input", {
      "onUpdate:modelValue": _cache[1] || (_cache[1] = function ($event) {
        return _ctx.stepperValue = $event;
      }),
      class: vue.normalizeClass("".concat(_ctx.name, "__input")),
      type: "tel",
      style: vue.normalizeStyle(_ctx.inputStyle),
      disabled: _ctx.disableInput || _ctx.disabled,
      readonly: _ctx.disableInput,
      onBlur: _cache[2] || (_cache[2] = function () {
        return _ctx.handleBlur && _ctx.handleBlur.apply(_ctx, arguments);
      }),
      onInput: _cache[3] || (_cache[3] = function () {
        return _ctx.handleInput && _ctx.handleInput.apply(_ctx, arguments);
      })
    }, null, 46, _hoisted_1$j), [[vue.vModelText, _ctx.stepperValue]]), vue.createElementVNode("div", {
      class: vue.normalizeClass(["".concat(_ctx.name, "__plus"), "".concat(_ctx.disabled || _ctx.stepperValue >= _ctx.max ? "t-is-disabled" : "")]),
      onClick: _cache[4] || (_cache[4] = function () {
        return _ctx.plusValue && _ctx.plusValue.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_add_icon, {
      class: vue.normalizeClass("".concat(_ctx.name, "__icon"))
    }, null, 8, ["class"])], 2)], 2);
  }

  script$U.render = render$T;

  var Stepper = withInstall(script$U);

  var props$5 = {
    disabled: Boolean,
    label: {
      type: [String, Boolean, Function],
      default: true
    },
    marks: {
      type: [Object, Array]
    },
    max: {
      type: Number,
      default: 100
    },
    min: {
      type: Number,
      default: 0
    },
    range: Boolean,
    showExtremeValue: Boolean,
    step: {
      type: Number,
      default: 1
    },
    value: {
      type: [Number, Array]
    },
    modelValue: {
      type: [Number, Array]
    },
    defaultValue: {
      type: [Number, Array]
    },
    onChange: Function,
    onDragend: Function,
    onDragstart: Function
  };

  var prefix$Q = config.prefix;
  var name$O = "".concat(prefix$Q, "-slider");
  var isArray$8 = Array.isArray;
  var script$T = vue.defineComponent({
    name: name$O,
    components: {
      TNode: TNodeComponent
    },
    props: props$5,
    emits: ["drag-start", "drag-end", "update:modelValue", "change"],
    setup: function setup(props2, context) {
      var rootRef = vue.ref(null);
      var barRef = vue.ref(null);
      var defaultValue = props2.defaultValue || props2.min;
      var _toRefs = vue.toRefs(props2),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue,
        max = _toRefs.max,
        min = _toRefs.min;
      var _useVModel = useVModel(value, modelValue, defaultValue, props2.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        innerValue = _useVModel2[0],
        setInnerValue = _useVModel2[1];
      var internalInstance = vue.getCurrentInstance();
      var labelContent = vue.computed(function () {
        return !props2.range && props2.label && (_typeof$1(renderTNode(internalInstance, "label")) === "object" ? renderTNode(internalInstance, "label") : "".concat(innerValue.value));
      });
      var isRange = vue.computed(function () {
        return props2.range && isArray$8(innerValue.value) && innerValue.value.length === 2;
      });
      var dots = vue.computed(function () {
        if (isRange.value) return innerValue.value;
        if (typeof innerValue.value === "number") return [innerValue.value];
        return [];
      });
      var classes = vue.computed(function () {
        var _ref;
        return ["".concat(name$O, "-wrap"), (_ref = {}, _defineProperty$2(_ref, "".concat(prefix$Q, "-is-disabled"), props2.disabled), _defineProperty$2(_ref, "".concat(prefix$Q, "-is-mark"), props2.marks), _defineProperty$2(_ref, "".concat(prefix$Q, "-is-value"), props2.showExtremeValue), _ref)];
      });
      var handleClass = vue.computed(function () {
        return ["".concat(name$O, "__handle")];
      });
      var marksData = vue.computed(function () {
        var sorter = function sorter(a, b) {
          return a[0] - b[0];
        };
        if (!props2.range && props2.marks) {
          if (isArray$8(props2.marks)) {
            return props2.marks.map(function (val) {
              return [val, val];
            }).sort(sorter);
          }
          return Object.entries(props2.marks).map(function (_ref2) {
            var _ref3 = _slicedToArray(_ref2, 2),
              key = _ref3[0],
              value2 = _ref3[1];
            return [parseInt(key, 10), value2];
          }).sort(sorter);
        }
        return [];
      });
      var dragStatus = vue.ref("");
      var touchData = vue.reactive({
        startValue: 0,
        newValue: 0,
        startX: 0,
        deltaX: 0,
        offsetX: 0
      });
      function onTouchStart(event, value2) {
        if (props2.disabled) {
          return;
        }
        event.stopPropagation();
        event.preventDefault();
        touchData.deltaX = 0;
        touchData.offsetX = 0;
        touchData.startX = event.touches[0].clientX;
        touchData.startValue = format(value2);
        dragStatus.value = "start";
      }
      function onTouchMove(event, index) {
        if (props2.disabled) return;
        if (!barRef.value) return;
        event.stopPropagation();
        event.preventDefault();
        if (dragStatus.value === "start") {
          context.emit("drag-start");
        }
        var touch = event.touches[0];
        touchData.deltaX = touch.clientX - touchData.startX;
        touchData.offsetX = Math.abs(touchData.deltaX);
        dragStatus.value = "dragging";
        var rect = barRef.value.getBoundingClientRect();
        var delta = touchData.deltaX;
        var total = rect.width;
        var diff = delta / total * (props2.max - props2.min);
        touchData.newValue = touchData.startValue + diff;
        updateValue(touchData.newValue, index);
      }
      function onTouchEnd(event, index) {
        if (props2.disabled) {
          return;
        }
        event.stopPropagation();
        event.preventDefault();
        if (dragStatus.value === "dragging") {
          updateValue(touchData.newValue, index, true);
          context.emit("drag-end");
        }
        dragStatus.value = "";
      }
      function onClick(event) {
        var _innerValue$value;
        event.stopPropagation();
        if (props2.disabled) return;
        if (!barRef.value) return;
        var rect = barRef.value.getBoundingClientRect();
        var delta = event.clientX - rect.left;
        var total = rect.width;
        var current = +props2.min + delta / total * (props2.max - props2.min);
        var index = 0;
        if (props2.range && innerValue.value) {
          if (Math.abs(current - innerValue.value[0]) > Math.abs(current - innerValue.value[1])) {
            index = 1;
          }
        }
        touchData.startValue = (_innerValue$value = innerValue.value) === null || _innerValue$value === void 0 ? void 0 : _innerValue$value[index];
        updateValue(current, index, true);
      }
      function format(value2) {
        var current = value2;
        if (!props2.range && props2.marks) {
          var _marksData$value;
          if (marksData !== null && marksData !== void 0 && (_marksData$value = marksData.value) !== null && _marksData$value !== void 0 && _marksData$value.length) {
            var _marksData$value$ = _slicedToArray(marksData.value[0], 1),
              min2 = _marksData$value$[0];
            marksData.value.forEach(function (_ref4) {
              var _ref5 = _slicedToArray(_ref4, 1),
                marksDataItemValue = _ref5[0];
              if (Math.abs(marksDataItemValue - value2) < Math.abs(min2 - value2)) {
                min2 = marksDataItemValue;
              }
            });
            current = min2;
          }
        }
        return Math.round(Math.max(props2.min, Math.min(current, props2.max)) / props2.step) * props2.step;
      }
      function updateValue(newValue, index) {
        var end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
        var formatValue = format(newValue);
        if (props2.range && Array.isArray(innerValue.value)) {
          var tmpValue = _toConsumableArray(innerValue.value);
          tmpValue[index] = formatValue;
          if (end && formatValue !== touchData.startValue) {
            tmpValue.sort(function (a, b) {
              return a - b;
            });
            setInnerValue(tmpValue);
          } else if (formatValue !== touchData.startValue) {
            setInnerValue(tmpValue);
          }
        } else if (formatValue !== touchData.startValue) {
          setInnerValue(formatValue);
        }
      }
      var getPercentage = function getPercentage(value2) {
        return (value2 ? value2 - props2.min : 0) / (props2.max - props2.min) * 100;
      };
      var trackStyle = vue.computed(function () {
        if (props2.range && isArray$8(innerValue.value)) {
          return {
            left: "".concat(getPercentage(Math.min(innerValue.value[0], innerValue.value[1])), "%"),
            width: "".concat(getPercentage(Math.abs(innerValue.value[1] - innerValue.value[0])), "%")
          };
        }
        if (!isArray$8(innerValue.value)) {
          return {
            width: "".concat(getPercentage(innerValue.value), "%")
          };
        }
        return {};
      });
      return {
        max: max,
        min: min,
        name: vue.ref(name$O),
        marksData: marksData,
        rootRef: rootRef,
        barRef: barRef,
        dots: dots,
        value: innerValue,
        labelContent: labelContent,
        classes: classes,
        handleClass: handleClass,
        trackStyle: trackStyle,
        getPercentage: getPercentage,
        onTouchStart: onTouchStart,
        onTouchMove: onTouchMove,
        onTouchEnd: onTouchEnd,
        onClick: onClick
      };
    }
  });

  var _hoisted_1$i = ["onTouchstart", "onTouchmove", "onTouchend"];
  function render$S(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "rootRef",
      class: vue.normalizeClass(_ctx.classes)
    }, [_ctx.showExtremeValue ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "-wrap__value--left"))
    }, vue.toDisplayString(_ctx.min), 3)) : vue.createCommentVNode("", true), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name)),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.onClick && _ctx.onClick.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("div", {
      ref: "barRef",
      class: vue.normalizeClass("".concat(_ctx.name, "__bar"))
    }, null, 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__track")),
      style: vue.normalizeStyle(_ctx.trackStyle)
    }, null, 6), (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.dots, function (item, index) {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: index + 1,
        class: vue.normalizeClass(_ctx.handleClass),
        style: vue.normalizeStyle("left:".concat(_ctx.getPercentage(item), "%")),
        onTouchstart: function onTouchstart($event) {
          return _ctx.onTouchStart($event, item);
        },
        onTouchmove: function onTouchmove($event) {
          return _ctx.onTouchMove($event, index);
        },
        onTouchend: function onTouchend($event) {
          return _ctx.onTouchEnd($event, index);
        }
      }, null, 46, _hoisted_1$i);
    }), 128)), _ctx.marksData ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__mark"))
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.marksData, function (v, k) {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: k,
        class: vue.normalizeClass("".concat(_ctx.name, "__mark-text t-is-").concat(_ctx.value && _ctx.value > v[0] ? "active" : "")),
        style: vue.normalizeStyle("left: ".concat(_ctx.getPercentage(v[0]), "%"))
      }, vue.toDisplayString(typeof v[1] === "function" ? v[1](v[0]) : v[1]), 7);
    }), 128))], 2)) : vue.createCommentVNode("", true)], 2), _ctx.labelContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "-wrap__value"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.labelContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), _ctx.showExtremeValue ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 2,
      class: vue.normalizeClass("".concat(_ctx.name, "-wrap__value"))
    }, vue.toDisplayString(_ctx.max), 3)) : vue.createCommentVNode("", true)], 2);
  }

  script$T.render = render$S;

  var _Slider = withInstall(script$T);

  var DialogProps = {
    actions: {
      type: [Array, Function]
    },
    buttonLayout: {
      type: String,
      default: "horizontal",
      validator: function validator(val) {
        if (!val) return true;
        return ["horizontal", "vertical"].includes(val);
      }
    },
    cancelBtn: {
      type: [String, Object, Function],
      default: ""
    },
    closeOnOverlayClick: {
      type: Boolean,
      default: true
    },
    confirmBtn: {
      type: [String, Object, Function],
      default: ""
    },
    content: {
      type: [String, Function]
    },
    destroyOnClose: Boolean,
    preventScrollThrough: {
      type: Boolean,
      default: true
    },
    showInAttachedElement: Boolean,
    showOverlay: {
      type: Boolean,
      default: true
    },
    title: {
      type: [String, Function]
    },
    visible: Boolean,
    width: {
      type: [String, Number]
    },
    zIndex: {
      type: Number
    },
    onCancel: Function,
    onClose: Function,
    onConfirm: Function,
    onOverlayClick: Function
  };

  function ownKeys$y(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$y(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$y(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$y(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$P = config.prefix;
  var name$N = "".concat(prefix$P, "-dialog");
  var script$S = vue.defineComponent({
    name: name$N,
    components: {
      TPopup: _Popup,
      TNode: TNodeComponent,
      TButton: _Button
    },
    props: DialogProps,
    emits: ["update:visible", "confirm", "overlay-click", "cancel", "change", "close"],
    setup: function setup(props, context) {
      var internalInstance = vue.getCurrentInstance();
      var dialogContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var innerValue = vue.ref("");
      var dClassName = vue.computed(function () {
        return "".concat(name$N);
      });
      var dBoxClassName = vue.computed(function () {
        return "".concat(name$N, "__box");
      });
      var dHeaderClassName = vue.computed(function () {
        return ["".concat(name$N, "__header"), _defineProperty$2({}, "".concat(name$N, "__header--has-content"), dialogContent)];
      });
      var dTitleClassName = vue.computed(function () {
        return "".concat(name$N, "__title");
      });
      var dBodyClassName = vue.computed(function () {
        return "".concat(name$N, "__body");
      });
      var dTextClassName = vue.computed(function () {
        return "".concat(name$N, "__text");
      });
      var dInputClassName = vue.computed(function () {
        return "".concat(name$N, "__input");
      });
      var dFooterClassName = vue.computed(function () {
        return [_defineProperty$2({}, "".concat(name$N, "__vertical-footer"), props.buttonLayout === "vertical"), "".concat(name$N, "__footer")];
      });
      var dDefaultBtnClassName = vue.computed(function () {
        return ["".concat(name$N, "__btn"), "".concat(name$N, "__btn--default"), "".concat(name$N, "__").concat(props.buttonLayout, "-btn")];
      });
      var dConfirmBtnClassName = vue.computed(function () {
        return ["".concat(name$N, "__btn"), "".concat(name$N, "__btn--primary"), "".concat(name$N, "__").concat(props.buttonLayout, "-btn")];
      });
      var rootStyles = vue.computed(function () {
        return {
          zIndex: props.zIndex,
          width: typeof props.width === "string" ? props.width : "".concat(props.width, "px")
        };
      });
      var handleConfirm = function handleConfirm() {
        context.emit("update:visible", false);
        context.emit("confirm");
      };
      var handleCancel = function handleCancel() {
        context.emit("update:visible", false);
        context.emit("close", "cancel");
        context.emit("cancel");
      };
      var handleOverlayClick = function handleOverlayClick() {
        if (!props.closeOnOverlayClick) {
          return;
        }
        context.emit("update:visible", false);
        context.emit("close", "overlay");
        context.emit("overlay-click");
      };
      vue.watch(function () {
        return props.visible;
      }, function (val) {
        context.emit("change", val);
      });
      var calcBtn = function calcBtn(btn) {
        return typeof btn === "string" ? {
          content: btn
        } : btn;
      };
      var confirmBtnProps = vue.computed(function () {
        return calcBtn(props.confirmBtn);
      });
      var cancelBtnProps = vue.computed(function () {
        return calcBtn(props.cancelBtn);
      });
      var actionsBtnProps = vue.computed(function () {
        var _props$actions;
        return (_props$actions = props.actions) === null || _props$actions === void 0 ? void 0 : _props$actions.map(function (item) {
          return calcBtn(item);
        });
      });
      return _objectSpread$y({
        innerValue: innerValue,
        dClassName: dClassName,
        dBoxClassName: dBoxClassName,
        dHeaderClassName: dHeaderClassName,
        dTitleClassName: dTitleClassName,
        dBodyClassName: dBodyClassName,
        dTextClassName: dTextClassName,
        dInputClassName: dInputClassName,
        dFooterClassName: dFooterClassName,
        dDefaultBtnClassName: dDefaultBtnClassName,
        dConfirmBtnClassName: dConfirmBtnClassName,
        dialogContent: dialogContent,
        confirmBtnProps: confirmBtnProps,
        cancelBtnProps: cancelBtnProps,
        actionsBtnProps: actionsBtnProps,
        handleConfirm: handleConfirm,
        handleCancel: handleCancel,
        handleOverlayClick: handleOverlayClick,
        rootStyles: rootStyles
      }, vue.toRefs(props));
    }
  });

  function render$R(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_button = vue.resolveComponent("t-button");
    var _component_t_popup = vue.resolveComponent("t-popup");
    return vue.openBlock(), vue.createBlock(_component_t_popup, {
      visible: _ctx.visible,
      placement: "center",
      "mask-transparent": !_ctx.showOverlay,
      "teleport-disabled": true,
      "lock-scroll": _ctx.preventScrollThrough,
      onClose: _ctx.handleOverlayClick
    }, {
      default: vue.withCtx(function () {
        return [vue.createElementVNode("div", {
          id: "root",
          class: vue.normalizeClass(_ctx.dClassName),
          style: vue.normalizeStyle(_ctx.rootStyles)
        }, [vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.dHeaderClassName)
        }, [vue.renderSlot(_ctx.$slots, "header", {}, function () {
          return [_ctx.title ? (vue.openBlock(), vue.createElementBlock("div", {
            key: 0,
            class: vue.normalizeClass(_ctx.dTitleClassName)
          }, vue.toDisplayString(_ctx.title), 3)) : vue.createCommentVNode("", true)];
        })], 2), _ctx.content ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass(_ctx.dBodyClassName)
        }, [vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.dTextClassName)
        }, [vue.createVNode(_component_t_node, {
          content: _ctx.dialogContent
        }, null, 8, ["content"])], 2)], 2)) : vue.createCommentVNode("", true), vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.dFooterClassName)
        }, [vue.renderSlot(_ctx.$slots, "actions", {}, function () {
          return [_ctx.actionsBtnProps ? (vue.openBlock(true), vue.createElementBlock(vue.Fragment, {
            key: 0
          }, vue.renderList(_ctx.actionsBtnProps, function (item, index) {
            return vue.openBlock(), vue.createBlock(_component_t_button, vue.mergeProps({
              key: index
            }, item, {
              variant: "text",
              class: _ctx.dDefaultBtnClassName,
              onClick: _ctx.handleCancel
            }), null, 16, ["class", "onClick"]);
          }), 128)) : vue.createCommentVNode("", true)];
        }), vue.renderSlot(_ctx.$slots, "cancelBtn", {}, function () {
          return [_ctx.cancelBtn ? (vue.openBlock(), vue.createBlock(_component_t_button, vue.mergeProps({
            key: 0
          }, _ctx.cancelBtnProps, {
            variant: "text",
            class: _ctx.dDefaultBtnClassName,
            onClick: _ctx.handleCancel
          }), null, 16, ["class", "onClick"])) : vue.createCommentVNode("", true)];
        }), vue.renderSlot(_ctx.$slots, "confirmBtn", {}, function () {
          return [_ctx.confirmBtn ? (vue.openBlock(), vue.createBlock(_component_t_button, vue.mergeProps({
            key: 0
          }, _ctx.confirmBtnProps, {
            variant: "text",
            class: _ctx.dConfirmBtnClassName,
            onClick: _ctx.handleConfirm
          }), null, 16, ["class", "onClick"])) : vue.createCommentVNode("", true)];
        })], 2)], 6)];
      }),
      _: 3
    }, 8, ["visible", "mask-transparent", "lock-scroll", "onClose"]);
  }

  script$S.render = render$R;

  function ownKeys$x(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$x(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$x(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$x(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var DialogPropsDefault = {
    title: "\u6E29\u99A8\u63D0\u9192",
    content: "",
    type: "",
    confirmBtn: "\u786E\u8BA4",
    cancelBtn: "\u53D6\u6D88",
    visible: false,
    zIndex: 2500,
    showOverlay: true,
    width: "320px",
    closeOnOverlayClick: false
  };
  var instance$1;
  function create$1(props) {
    var visible = vue.ref(false);
    var root = document.createElement("div");
    document.body.appendChild(root);
    var propsObject = _objectSpread$x(_objectSpread$x({}, DialogPropsDefault), typeof props === "string" ? {
      content: props
    } : props);
    if (instance$1) {
      instance$1.clear();
    }
    instance$1 = vue.defineComponent({
      render: function render() {
        return vue.h(script$S, _objectSpread$x(_objectSpread$x({}, propsObject), {}, {
          visible: visible.value,
          onConfirm: function onConfirm(context) {
            if (typeof propsObject.onConfirm === "function") {
              propsObject.onConfirm(context);
            }
            visible.value = false;
          },
          onCancel: function onCancel(context) {
            if (typeof propsObject.onCancel === "function") {
              propsObject.onCancel(context);
            }
            visible.value = false;
          },
          onOverlayClick: function onOverlayClick(context) {
            if (typeof propsObject.onOverlayClick === "function") {
              propsObject.onOverlayClick(context);
            }
            visible.value = false;
          },
          onClose: function onClose(context) {
            root.remove();
            if (typeof propsObject.onClose === "function") {
              propsObject.onClose(context);
            }
          }
        }));
      }
    });
    instance$1.clear = function () {
      root.remove();
    };
    vue.createApp(instance$1).mount(root);
    vue.nextTick(function () {
      visible.value = true;
    });
    return instance$1;
  }
  ["show", "alert", "confirm"].forEach(function (type) {
    script$S[type] = function (options) {
      var props = {
        content: "",
        type: type
      };
      if (typeof options === "string") {
        props.content = options;
      } else {
        props = _objectSpread$x(_objectSpread$x({}, props), options);
      }
      return create$1(props);
    };
  });
  script$S.install = function (app) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    app.component(name || script$S.name, script$S);
    app.config.globalProperties.$dialog = script$S;
    app.provide("$dialog", script$S);
  };
  var DialogPlugin = script$S;

  var prefix$O = config.prefix;
  var name$M = "".concat(prefix$O, "-action-sheet");
  var script$R = vue.defineComponent({
    props: {
      items: {
        type: Array,
        required: true
      }
    },
    emits: ["selected"],
    setup: function setup(props, context) {
      var handleSelected = function handleSelected(index) {
        context.emit("selected", index);
      };
      return {
        name: vue.ref(name$M),
        handleSelected: handleSelected
      };
    }
  });

  var _hoisted_1$h = ["disabled", "onClick"];
  function render$Q(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__menu"))
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.items, function (item, index) {
      return vue.openBlock(), vue.createElementBlock("button", {
        key: index,
        class: vue.normalizeClass("".concat(_ctx.name, "__cell")),
        disabled: item.disabled,
        onClick: function onClick($event) {
          return _ctx.handleSelected(index);
        }
      }, [vue.renderSlot(_ctx.$slots, "cell", {
        item: item
      }, function () {
        return [vue.createElementVNode("div", {
          class: vue.normalizeClass("".concat(_ctx.name, "__cell-text")),
          style: vue.normalizeStyle({
            color: item.color
          })
        }, vue.toDisplayString(item.label), 7)];
      })], 10, _hoisted_1$h);
    }), 128))], 2);
  }

  script$R.render = render$Q;

  var gridProps = {
    align: {
      type: String,
      default: "center",
      validator: function validator(val) {
        if (!val) return true;
        return ["left", "center"].includes(val);
      }
    },
    border: {
      type: [Boolean, Object],
      default: false
    },
    column: {
      type: Number,
      default: 4
    },
    gutter: {
      type: Number
    }
  };

  var prefix$N = config.prefix;
  var name$L = "".concat(prefix$N, "-grid");
  var script$Q = vue.defineComponent({
    name: name$L,
    props: gridProps,
    setup: function setup(props) {
      var _toRefs = vue.toRefs(props),
        column = _toRefs.column,
        gutter = _toRefs.gutter,
        border = _toRefs.border,
        align = _toRefs.align;
      vue.provide("grid", {
        column: column,
        gutter: gutter,
        border: border,
        align: align
      });
      return {
        name: name$L
      };
    }
  });

  function render$P(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass("".concat(_ctx.name))
    }, [vue.renderSlot(_ctx.$slots, "default")], 2);
  }

  script$Q.render = render$P;

  var BadgeProps = {
    color: {
      type: String,
      default: ""
    },
    content: {
      type: [String, Function]
    },
    count: {
      type: [String, Number, Function],
      default: 0
    },
    dot: Boolean,
    maxCount: {
      type: Number,
      default: 99
    },
    offset: {
      type: Array
    },
    shape: {
      type: String,
      default: "circle",
      validator: function validator(val) {
        if (!val) return true;
        return ["circle", "round", "ribbon"].includes(val);
      }
    },
    showZero: Boolean,
    size: {
      type: String,
      default: "medium",
      validator: function validator(val) {
        if (!val) return true;
        return ["small", "medium"].includes(val);
      }
    }
  };

  function ownKeys$w(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$w(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$w(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$w(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var name$K = "".concat(config.prefix, "-badge");
  var script$P = vue.defineComponent({
    name: name$K,
    components: {
      TNode: TNodeComponent
    },
    props: BadgeProps,
    setup: function setup(props) {
      var internalInstance = vue.getCurrentInstance();
      var badgeContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var countContent = vue.computed(function () {
        if (props.dot) {
          return "";
        }
        if (typeof props.count === "function") {
          return renderTNode(internalInstance, "count");
        }
        var count = Number(props.count);
        if (isNaN(count)) {
          return props.count;
        }
        return count > props.maxCount ? "".concat(props.maxCount, "+") : count;
      });
      var isIndependent = vue.computed(function () {
        return badgeContent.value === void 0;
      });
      var showDot = vue.computed(function () {
        return props.dot || props.count !== 0 || props.showZero;
      });
      var badgeClasses = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$K), true), _defineProperty$2(_ref, "".concat(name$K, "__ribbon--outer"), props.shape === "ribbon"), _ref;
      });
      var badgeInnerClasses = vue.computed(function () {
        var _ref2;
        return _ref2 = {}, _defineProperty$2(_ref2, "".concat(name$K, "__inner"), true), _defineProperty$2(_ref2, "".concat(name$K, "--has-children"), !isIndependent.value), _defineProperty$2(_ref2, "".concat(name$K, "--").concat(props.size), props.size), _defineProperty$2(_ref2, "".concat(name$K, "--").concat(props.shape), props.shape && !props.dot), _defineProperty$2(_ref2, "".concat(name$K, "--dot"), props.dot), _ref2;
      });
      var badgeStyles = vue.computed(function () {
        if (!props.offset) {
          return {
            background: props.color
          };
        }
        var _props$offset = _slicedToArray(props.offset, 2),
          xOffset = _props$offset[0],
          yOffset = _props$offset[1];
        xOffset = isNaN(Number(xOffset)) ? xOffset : "".concat(xOffset, "px");
        yOffset = isNaN(Number(yOffset)) ? yOffset : "".concat(yOffset, "px");
        return {
          background: props.color,
          right: xOffset,
          top: yOffset
        };
      });
      return _objectSpread$w(_objectSpread$w({
        badgeContent: badgeContent,
        showDot: showDot,
        badgeStyles: badgeStyles,
        badgeClasses: badgeClasses,
        badgeInnerClasses: badgeInnerClasses
      }, vue.toRefs(props)), {}, {
        countContent: countContent
      });
    }
  });

  function render$O(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.badgeClasses)
    }, [_ctx.showDot ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass(_ctx.badgeInnerClasses),
      style: vue.normalizeStyle(_ctx.badgeStyles)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.countContent
    }, null, 8, ["content"])], 6)) : vue.createCommentVNode("", true), vue.createVNode(_component_t_node, {
      content: _ctx.badgeContent
    }, null, 8, ["content"])], 2);
  }

  script$P.render = render$O;

  var _Badge = withInstall(script$P);

  var gridItemProps = {
    badgeProps: {
      type: Object
    },
    description: {
      type: [String, Function]
    },
    image: {
      type: [String, Function]
    },
    layout: {
      type: String,
      default: "vertical",
      validator: function validator(val) {
        if (!val) return true;
        return ["vertical", "horizontal"].includes(val);
      }
    },
    text: {
      type: [String, Function]
    }
  };

  function ownKeys$v(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$v(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$v(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$v(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$M = config.prefix;
  var name$J = "".concat(prefix$M, "-grid-item");
  var script$O = vue.defineComponent({
    name: name$J,
    components: {
      TNode: TNodeComponent,
      TBadge: _Badge
    },
    props: gridItemProps,
    setup: function setup(props) {
      var internalInstance = vue.getCurrentInstance();
      var isHorz = props.layout === "horizontal";
      var _inject = vue.inject("grid"),
        column = _inject.column,
        gutter = _inject.gutter,
        border = _inject.border,
        align = _inject.align;
      var imageContent = vue.computed(function () {
        return renderTNode(internalInstance, "image");
      });
      var textContent = vue.computed(function () {
        return renderTNode(internalInstance, "text");
      });
      var descContent = vue.computed(function () {
        return renderTNode(internalInstance, "description");
      });
      var rootClass = vue.computed(function () {
        return ["".concat(name$J), _defineProperty$2({}, "".concat(name$J, "--bordered"), border.value)];
      });
      var rootStyle = vue.computed(function () {
        var percent = "".concat(100 / +column.value, "%");
        var borderStyle = {};
        if (border.value) {
          if (typeof border.value !== "boolean") {
            var _border$value = border.value,
              color = _border$value.color,
              width = _border$value.width,
              style2 = _border$value.style;
            return {
              borderColor: color,
              borderWidth: width,
              borderStyle: style2
            };
          }
        }
        var style = _objectSpread$v({
          flexBasis: percent,
          flexDirection: isHorz ? "row" : "column",
          paddingLeft: gutter.value ? "".concat(gutter.value, "px") : 0,
          paddingRight: gutter.value ? "".concat(gutter.value, "px") : 0,
          alignItems: "center",
          justifyContent: "center",
          textAlign: ["center", "left"].includes(align.value) ? align.value : "center"
        }, borderStyle);
        return style;
      });
      var imgStyle = vue.computed(function () {
        var imgSize = 32;
        if (column.value >= 5) {
          imgSize = 28;
        } else if (column.value <= 3) {
          imgSize = 48;
        }
        return {
          width: "".concat(imgSize, "px"),
          height: "".concat(imgSize, "px")
        };
      });
      var textStyle = vue.computed(function () {
        return {
          paddingLeft: isHorz ? "12px" : 0
        };
      });
      var titleStyle = vue.computed(function () {
        return {
          paddingTop: isHorz ? 0 : "8px",
          marginBottom: "4px"
        };
      });
      return {
        name: name$J,
        rootStyle: rootStyle,
        rootClass: rootClass,
        imgStyle: imgStyle,
        textStyle: textStyle,
        titleStyle: titleStyle,
        imageContent: imageContent,
        textContent: textContent,
        descContent: descContent
      };
    }
  });

  var _hoisted_1$g = ["src"];
  var _hoisted_2$6 = ["src"];
  function render$N(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_badge = vue.resolveComponent("t-badge");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.rootClass),
      style: vue.normalizeStyle(_ctx.rootStyle)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__image-box"))
    }, [_ctx.badgeProps ? (vue.openBlock(), vue.createBlock(_component_t_badge, {
      key: 0,
      count: _ctx.badgeProps.count,
      "max-count": _ctx.badgeProps.maxCount,
      dot: _ctx.badgeProps.dot,
      content: _ctx.badgeProps.content,
      size: _ctx.badgeProps.size,
      offset: _ctx.badgeProps.offset
    }, {
      default: vue.withCtx(function () {
        return [_ctx.image && typeof _ctx.image === "string" ? (vue.openBlock(), vue.createElementBlock("img", {
          key: 0,
          src: _ctx.image,
          class: vue.normalizeClass("".concat(_ctx.name, "__image")),
          style: vue.normalizeStyle(_ctx.imgStyle)
        }, null, 14, _hoisted_1$g)) : (vue.openBlock(), vue.createBlock(_component_t_node, {
          key: 1,
          content: _ctx.imageContent
        }, null, 8, ["content"]))];
      }),
      _: 1
    }, 8, ["count", "max-count", "dot", "content", "size", "offset"])) : vue.createCommentVNode("", true), _ctx.image && typeof _ctx.image === "string" ? (vue.openBlock(), vue.createElementBlock("img", {
      key: 1,
      src: _ctx.image,
      class: vue.normalizeClass("".concat(_ctx.name, "__image")),
      style: vue.normalizeStyle(_ctx.imgStyle)
    }, null, 14, _hoisted_2$6)) : (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 2,
      content: _ctx.imageContent
    }, null, 8, ["content"]))], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__text")),
      style: vue.normalizeStyle(_ctx.textStyle)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__title")),
      style: vue.normalizeStyle(_ctx.titleStyle)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.textContent
    }, null, 8, ["content"])], 6), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__description"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.descContent
    }, null, 8, ["content"])], 2)], 6)], 6);
  }

  script$O.render = render$N;

  var Grid = withInstall(script$Q);
  var GridItem = withInstall(script$O);

  var prefix$L = config.prefix;
  var name$I = "".concat(prefix$L, "-action-sheet");
  var script$N = vue.defineComponent({
    components: {
      TGrid: Grid,
      TGridItem: GridItem
    },
    props: {
      items: {
        type: Array,
        required: true
      },
      count: {
        type: Number,
        default: 8
      }
    },
    emits: ["selected"],
    setup: function setup(props, context) {
      var containerWrapper = vue.ref(null);
      var moveOffset = vue.ref(0);
      var currentIndex = vue.ref(0);
      var useTransition = vue.ref(true);
      var startX = 0;
      var startOffset = 0;
      var canMove = true;
      var wrapperStyle = vue.computed(function () {
        return {
          transform: "translate3d(".concat(moveOffset.value, "px, 0, 0)"),
          transition: useTransition.value ? "transform 300ms" : "all"
        };
      });
      var gridColumn = vue.computed(function () {
        return Math.ceil(props.count / 2);
      });
      var pageNum = vue.computed(function () {
        return Math.ceil(props.items.length / props.count);
      });
      var actionItems = vue.computed(function () {
        var res = [];
        for (var i = 0; i < pageNum.value; i++) {
          var temp = props.items.slice(i * props.count, (i + 1) * props.count);
          res.push(temp);
        }
        return res;
      });
      var handleSelected = function handleSelected(index) {
        context.emit("selected", index);
      };
      var moveByIndex = function moveByIndex(index) {
        useTransition.value = true;
        if (containerWrapper.value) {
          moveOffset.value = pageNum.value > 1 ? index * containerWrapper.value.offsetWidth * -1 : 0;
        }
      };
      var getMaxOffset = function getMaxOffset() {
        if (!containerWrapper.value) return 0;
        return (pageNum.value - 1) * containerWrapper.value.offsetWidth;
      };
      var handleTouchstart = function handleTouchstart(e) {
        canMove = true;
        useTransition.value = false;
        startX = e.touches[0].clientX;
        startOffset = startX - moveOffset.value;
      };
      var handleTouchmove = function handleTouchmove(e) {
        var clientX = e.touches[0].clientX;
        var minOffset = 0;
        var maxOffset = getMaxOffset();
        if (Math.abs(clientX - startX) < 15) return;
        moveOffset.value = clientX - startOffset;
        if (moveOffset.value > minOffset) {
          moveOffset.value = minOffset;
          canMove = false;
        }
        if (Math.abs(moveOffset.value) >= maxOffset) {
          moveOffset.value = maxOffset * -1;
          canMove = false;
        }
      };
      var handleTouchend = function handleTouchend(e) {
        if (!canMove) return;
        var distance = e.changedTouches[0].clientX - startX;
        var targetIndex = Math.abs(distance) > 50 ? currentIndex.value + (distance < 0 ? 1 : -1) : currentIndex.value;
        currentIndex.value = targetIndex;
        moveByIndex(targetIndex);
      };
      return {
        name: vue.ref(name$I),
        gridColumn: gridColumn,
        pageNum: pageNum,
        actionItems: actionItems,
        currentIndex: currentIndex,
        containerWrapper: containerWrapper,
        wrapperStyle: wrapperStyle,
        handleSelected: handleSelected,
        handleTouchstart: handleTouchstart,
        handleTouchmove: handleTouchmove,
        handleTouchend: handleTouchend
      };
    }
  });

  function render$M(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_grid_item = vue.resolveComponent("t-grid-item");
    var _component_t_grid = vue.resolveComponent("t-grid");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "containerWrapper",
      class: vue.normalizeClass("".concat(_ctx.name, "__menu-wrapper"))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__menu-slider")),
      style: vue.normalizeStyle(_ctx.wrapperStyle),
      onTouchstart: _cache[0] || (_cache[0] = function () {
        return _ctx.handleTouchstart && _ctx.handleTouchstart.apply(_ctx, arguments);
      }),
      onTouchmove: _cache[1] || (_cache[1] = function () {
        return _ctx.handleTouchmove && _ctx.handleTouchmove.apply(_ctx, arguments);
      }),
      onTouchend: _cache[2] || (_cache[2] = function () {
        return _ctx.handleTouchend && _ctx.handleTouchend.apply(_ctx, arguments);
      })
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.actionItems, function (Items, i) {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: i,
        class: vue.normalizeClass("".concat(_ctx.name, "__menu"))
      }, [vue.createVNode(_component_t_grid, {
        column: _ctx.gridColumn
      }, {
        default: vue.withCtx(function () {
          return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(Items, function (item, index) {
            return vue.openBlock(), vue.createBlock(_component_t_grid_item, {
              key: index,
              text: item.label,
              image: item.icon,
              onClick: function onClick($event) {
                return _ctx.handleSelected(i * _ctx.count + index);
              }
            }, null, 8, ["text", "image", "onClick"]);
          }), 128))];
        }),
        _: 2
      }, 1032, ["column"])], 2);
    }), 128))], 38), _ctx.pageNum > 1 ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__indicator"))
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.pageNum, function (index) {
      var _normalizeClass2;
      return vue.openBlock(), vue.createElementBlock("div", {
        key: index,
        class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, "".concat(_ctx.name, "__indicator-item"), true), _defineProperty$2(_normalizeClass2, "on", _ctx.currentIndex === index - 1), _normalizeClass2))
      }, null, 2);
    }), 128))], 2)) : vue.createCommentVNode("", true)], 2);
  }

  script$N.render = render$M;

  var prefix$K = config.prefix;
  var name$H = "".concat(prefix$K, "-action-sheet");
  var script$M = vue.defineComponent({
    name: name$H,
    components: {
      TPopup: _Popup,
      MenuList: script$R,
      MenuGrid: script$N
    },
    props: {
      modelValue: Boolean,
      visible: {
        type: Boolean,
        default: false
      },
      items: {
        type: Array,
        required: true
      },
      type: {
        type: String,
        default: "list"
      },
      count: {
        type: Number,
        default: 8
      },
      showCancel: {
        type: Boolean,
        default: true
      },
      cancelText: {
        type: String,
        default: "\u53D6\u6D88"
      }
    },
    emits: ["selected", "update:modelValue", "cancel", "close"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var actionItems = vue.ref([]);
      var currentVisible = vue.computed(function () {
        return props.modelValue || props.visible;
      });
      var rootClasses = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$H, "__panel"), true), _defineProperty$2(_ref, "".concat(name$H, "__panel-list"), props.type === "list"), _defineProperty$2(_ref, "".concat(name$H, "__panel-grid"), props.type === "grid"), _ref;
      });
      vue.watch(function () {
        return props.items;
      }, function (val) {
        var items = JSON.parse(JSON.stringify(val));
        items = items.map(function (item) {
          if (typeof item === "string") {
            return {
              label: item
            };
          }
          return item;
        });
        actionItems.value = items;
      }, {
        immediate: true,
        deep: true
      });
      var handleCancel = function handleCancel() {
        emitEvent("cancel");
        context.emit("update:modelValue", false);
      };
      var handleSelected = function handleSelected(index) {
        emitEvent("selected", props.items[index], index);
      };
      var handleClose = function handleClose() {
        emitEvent("close");
        context.emit("update:modelValue", false);
      };
      return {
        name: vue.ref(name$H),
        rootClasses: rootClasses,
        actionItems: actionItems,
        currentVisible: currentVisible,
        handleCancel: handleCancel,
        handleSelected: handleSelected,
        handleClose: handleClose
      };
    }
  });

  function render$L(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_menu_list = vue.resolveComponent("menu-list");
    var _component_menu_grid = vue.resolveComponent("menu-grid");
    var _component_t_popup = vue.resolveComponent("t-popup");
    return vue.openBlock(), vue.createBlock(_component_t_popup, {
      class: vue.normalizeClass(_ctx.name),
      visible: _ctx.currentVisible,
      placement: "bottom",
      onClose: _ctx.handleClose
    }, {
      default: vue.withCtx(function () {
        return [vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.rootClasses)
        }, [_ctx.type === "list" ? (vue.openBlock(), vue.createBlock(_component_menu_list, {
          key: 0,
          items: _ctx.actionItems,
          onSelected: _ctx.handleSelected
        }, {
          cell: vue.withCtx(function (slotProps) {
            return [vue.renderSlot(_ctx.$slots, "cell", {
              item: slotProps.item
            })];
          }),
          _: 3
        }, 8, ["items", "onSelected"])) : (vue.openBlock(), vue.createBlock(_component_menu_grid, {
          key: 1,
          items: _ctx.actionItems,
          count: _ctx.count,
          onSelected: _ctx.handleSelected
        }, {
          cell: vue.withCtx(function (slotProps) {
            return [vue.renderSlot(_ctx.$slots, "cell", {
              item: slotProps.item
            })];
          }),
          _: 3
        }, 8, ["items", "count", "onSelected"])), _ctx.showCancel ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
          key: 2
        }, [_ctx.type === "list" ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          class: vue.normalizeClass("".concat(_ctx.name, "__separation"))
        }, null, 2)) : vue.createCommentVNode("", true), vue.createElementVNode("button", {
          class: vue.normalizeClass("".concat(_ctx.name, "__action")),
          onClick: _cache[0] || (_cache[0] = function () {
            return _ctx.handleCancel && _ctx.handleCancel.apply(_ctx, arguments);
          })
        }, vue.toDisplayString(_ctx.cancelText), 3)], 64)) : vue.createCommentVNode("", true)], 2)];
      }),
      _: 3
    }, 8, ["class", "visible", "onClose"]);
  }

  script$M.render = render$L;

  var _ActionSheet = withInstall(script$M);

  var props$4 = {
    buttonProps: {
      type: Object
    },
    icon: {
      type: Function
    },
    style: {
      type: String,
      default: "right: 16px; bottom: 32px;"
    },
    text: {
      type: String,
      default: ""
    },
    onClick: Function
  };

  function ownKeys$u(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$u(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$u(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$u(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$J = config.prefix;
  var name$G = "".concat(prefix$J, "-fab");
  var script$L = vue.defineComponent({
    name: name$G,
    components: {
      TNode: TNodeComponent,
      TButton: _Button
    },
    props: props$4,
    emits: ["click"],
    setup: function setup(props2, context) {
      var emitEvent = useEmitEvent(props2, context.emit);
      var classes = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$G), true), _defineProperty$2(_ref, "".concat(name$G, "--icononly"), props2.icon && !props2.text), _ref;
      });
      var onClick = function onClick(e) {
        return emitEvent("click", {
          e: e
        });
      };
      var baseButtonProps = {
        size: "middle",
        shape: "round",
        theme: "primary"
      };
      var customButtonProps = vue.computed(function () {
        return _objectSpread$u(_objectSpread$u({}, baseButtonProps), props2.buttonProps);
      });
      var internalInstance = vue.getCurrentInstance();
      var iconTNode = vue.computed(function () {
        return renderTNode(internalInstance, "icon");
      });
      return {
        name: name$G,
        classes: classes,
        iconTNode: iconTNode,
        customButtonProps: customButtonProps,
        onClick: onClick
      };
    }
  });

  function render$K(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_button = vue.resolveComponent("t-button");
    return vue.openBlock(), vue.createBlock(_component_t_button, vue.mergeProps(_ctx.customButtonProps, {
      class: _ctx.classes,
      style: _ctx.style,
      onClick: _ctx.onClick
    }), {
      default: vue.withCtx(function () {
        return [_ctx.iconTNode ? (vue.openBlock(), vue.createBlock(_component_t_node, {
          key: 0,
          content: _ctx.iconTNode
        }, null, 8, ["content"])) : vue.createCommentVNode("", true), _ctx.text ? (vue.openBlock(), vue.createElementBlock("span", {
          key: 1,
          class: vue.normalizeClass("".concat(_ctx.name, "__text"))
        }, vue.toDisplayString(_ctx.text), 3)) : vue.createCommentVNode("", true)];
      }),
      _: 1
    }, 16, ["class", "style", "onClick"]);
  }

  script$L.render = render$K;

  var _Fab = withInstall(script$L);

  var ImageViewerProps = {
    closeBtn: {
      type: [Boolean, Function],
      default: true
    },
    images: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    initialIndex: {
      type: Number,
      default: 0
    },
    maxZoom: {
      type: Number,
      default: 3
    },
    showIndex: Boolean,
    visible: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: Boolean,
    onClose: Function,
    onIndexChange: Function
  };

  var SwiperProps = {
    animation: {
      type: String,
      default: "slide",
      validator: function validator(val) {
        if (!val) return true;
        return ["slide"].includes(val);
      }
    },
    autoplay: {
      type: Boolean,
      default: true
    },
    current: {
      type: Number,
      default: void 0
    },
    modelValue: {
      type: Number,
      default: void 0
    },
    defaultCurrent: {
      type: Number,
      default: 0
    },
    direction: {
      type: String,
      default: "horizontal",
      validator: function validator(val) {
        if (!val) return true;
        return ["horizontal", "vertical"].includes(val);
      }
    },
    duration: {
      type: Number,
      default: 300
    },
    height: {
      type: Number
    },
    interval: {
      type: Number,
      default: 5e3
    },
    loop: {
      type: Boolean,
      default: true
    },
    navigation: {
      type: [Object, Function]
    },
    paginationPosition: {
      type: String,
      default: "bottom",
      validator: function validator(val) {
        if (!val) return true;
        return ["top-left", "top", "top-right", "bottom-left", "bottom", "bottom-right"].includes(val);
      }
    },
    onChange: Function
  };

  var prefix$I = config.prefix;
  var name$F = "".concat(prefix$I, "-swiper");
  var setOffset = function setOffset(element, offset) {
    var direction = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "X";
    element.style.transform = "translate".concat(direction, "(").concat(offset, "px)");
  };
  var script$K = vue.defineComponent({
    name: name$F,
    components: {
      ChevronLeftIcon: chevronLeft,
      ChevronRightIcon: chevronRight,
      TNode: TNodeComponent
    },
    props: SwiperProps,
    emits: ["change", "update:current", "update:modelValue"],
    setup: function setup(props, context) {
      var _useDefault = useDefault(props, context.emit, "current", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 2);
        _useDefault2[0];
        var setSwiperValue = _useDefault2[1];
      var self = vue.getCurrentInstance();
      var swiperContainer = vue.ref(null);
      var computedNavigation = vue.computed(function () {
        return renderTNode(self, "navigation");
      });
      var height = props.height || 180;
      var state = vue.reactive({
        showNavigation: true,
        activeIndex: 0,
        itemLength: 0,
        itemWidth: 0,
        isControl: false,
        btnDisabled: false,
        children: []
      });
      var paginationList = vue.computed(function () {
        return new Array(state.itemLength).fill(1);
      });
      var showPageNum = vue.computed(function () {
        var activeIndex = state.activeIndex,
          itemLength = state.itemLength;
        if (activeIndex > itemLength - 1) return itemLength;
        if (activeIndex < 0) return 1;
        return activeIndex + 1;
      });
      vue.computed(function () {
        return state.children.length;
      });
      var getContainer = function getContainer() {
        var _self$proxy;
        return self === null || self === void 0 ? void 0 : (_self$proxy = self.proxy) === null || _self$proxy === void 0 ? void 0 : _self$proxy.$el.querySelector(".".concat(name$F, "__container"));
      };
      var initSwiper = function initSwiper() {
        var _swiperContainer$chil, _swiperContainer$quer;
        var _swiperContainer = getContainer();
        _swiperContainer.querySelectorAll(".copy-item").forEach(function (ele) {
          _swiperContainer.removeChild(ele);
        });
        var items = _swiperContainer.querySelectorAll(".".concat(name$F, "-item"));
        state.itemLength = ((_swiperContainer$chil = _swiperContainer.children) === null || _swiperContainer$chil === void 0 ? void 0 : _swiperContainer$chil.length) || 0;
        var itemWidth = ((_swiperContainer$quer = _swiperContainer.querySelector(".".concat(name$F, "-item"))) === null || _swiperContainer$quer === void 0 ? void 0 : _swiperContainer$quer.getBoundingClientRect().width) || 0;
        state.itemWidth = itemWidth;
        if (items.length <= 0) return false;
        if (computedNavigation.value && "minShowNum" in computedNavigation.value && items.length < computedNavigation.value.minShowNum) {
          state.showNavigation = false;
        }
        if (props !== null && props !== void 0 && props.loop) {
          var first = items[0].cloneNode(true);
          first.classList.add("copy-item");
          var last = items[items.length - 1].cloneNode(true);
          last.classList.add("copy-item");
          _swiperContainer.appendChild(first);
          _swiperContainer.insertBefore(last, items[0]);
        }
        move(0);
        startAutoplay();
        if (typeof props.current === "number") {
          state.isControl = true;
          next(props.current);
        }
      };
      vue.onMounted(function () {
        vue.nextTick(function () {
          console.info("swiper mounted");
          initSwiper();
        });
      });
      vue.watch(function () {
        return state.children.length;
      }, function () {
        vue.nextTick(function () {
          console.info("swiper mounted");
          initSwiper();
        });
      });
      var autoplayTimer = null;
      var actionIsTrust = true;
      var move = function move(targetIndex) {
        var isTrust = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var _swiperContainer = getContainer();
        var moveDirection = (props === null || props === void 0 ? void 0 : props.direction) === "horizontal" ? "X" : "Y";
        var moveLength = (props === null || props === void 0 ? void 0 : props.direction) === "vertical" ? height : state.itemWidth;
        actionIsTrust = isTrust;
        _swiperContainer.dataset.isTrust = "".concat(isTrust);
        var toIndex = props !== null && props !== void 0 && props.loop ? targetIndex + 1 : targetIndex;
        _swiperContainer.style.transform = "translate".concat(moveDirection, "(-").concat(moveLength * toIndex, "px)");
      };
      var addAnimation = function addAnimation() {
        var _swiperContainer = getContainer();
        _swiperContainer.style.transition = "transform ".concat(props === null || props === void 0 ? void 0 : props.duration, "ms");
      };
      var removeAnimation = function removeAnimation() {
        var _swiperContainer = getContainer();
        _swiperContainer.style.transition = "none";
      };
      var handleAnimationEnd = function handleAnimationEnd() {
        state.btnDisabled = false;
        removeAnimation();
        if (state.activeIndex >= state.itemLength) {
          state.activeIndex = 0;
          move(0);
        }
        if (state.activeIndex <= -1) {
          state.activeIndex = state.itemLength - 1;
          move(state.itemLength - 1);
        }
        setTimeout(function () {
          actionIsTrust && emitCurrentChange(state.activeIndex);
        }, 0);
      };
      var stopAutoplay = function stopAutoplay() {
        if (!autoplayTimer) return;
        clearInterval(autoplayTimer);
        autoplayTimer = null;
      };
      var startAutoplay = function startAutoplay() {
        if (typeof props.current === "number") return false;
        if (!(props !== null && props !== void 0 && props.autoplay) || autoplayTimer !== null) return false;
        autoplayTimer = setInterval(function () {
          state.activeIndex += 1;
          if (!(props !== null && props !== void 0 && props.loop) && state.activeIndex >= state.children.length - 1) {
            state.activeIndex = 0;
          }
          if (!(props !== null && props !== void 0 && props.loop) && state.activeIndex <= 0) {
            state.activeIndex = state.children.length - 1;
          }
          addAnimation();
          move(state.activeIndex);
        }, props === null || props === void 0 ? void 0 : props.interval);
      };
      var emitCurrentChange = function emitCurrentChange(index) {
        var resultIndex = index;
        if (index >= state.itemLength) resultIndex = 0;
        if (index < 0) resultIndex = state.itemLength - 1;
        setSwiperValue(resultIndex);
      };
      var prev = function prev() {
        var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var cannotMovePrev = !(props !== null && props !== void 0 && props.loop) && state.activeIndex === 0;
        if (state.btnDisabled || cannotMovePrev) {
          move(state.activeIndex);
          return false;
        }
        stopAutoplay();
        state.activeIndex -= step;
        addAnimation();
        move(state.activeIndex);
        startAutoplay();
        state.btnDisabled = true;
      };
      var next = function next() {
        var step = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        var cannotMoveLast = !(props !== null && props !== void 0 && props.loop) && state.activeIndex === state.itemLength - 1;
        if (state.btnDisabled || cannotMoveLast) {
          move(state.activeIndex);
          return false;
        }
        stopAutoplay();
        state.activeIndex += step;
        addAnimation();
        move(state.activeIndex);
        startAutoplay();
        state.btnDisabled = true;
      };
      var _useSwipe = useSwipe(swiperContainer, {
          passive: false,
          onSwipeStart: function onSwipeStart(e) {
            if (state.btnDisabled) return false;
            stopAutoplay();
          },
          onSwipe: function onSwipe(e) {
            if (state.btnDisabled) return false;
            onTouchMove(e);
          },
          onSwipeEnd: function onSwipeEnd() {
            onTouchEnd();
          }
        }),
        lengthX = _useSwipe.lengthX,
        lengthY = _useSwipe.lengthY;
      var onTouchMove = function onTouchMove(event) {
        event.preventDefault();
        var activeIndex = state.activeIndex,
          itemWidth = state.itemWidth;
        var distanceX = lengthX.value;
        var distanceY = lengthY.value;
        var _container = getContainer();
        removeAnimation();
        var toIndex = props !== null && props !== void 0 && props.loop ? activeIndex + 1 : activeIndex;
        if ((props === null || props === void 0 ? void 0 : props.direction) === "horizontal") {
          setOffset(_container, -(toIndex * itemWidth + distanceX));
        } else {
          var _props$height = props.height,
            height2 = _props$height === void 0 ? 180 : _props$height;
          setOffset(_container, -(toIndex * height2 + distanceY), "Y");
        }
      };
      var onTouchEnd = function onTouchEnd() {
        var distanceX = lengthX.value;
        var distanceY = lengthY.value;
        addAnimation();
        if ((props === null || props === void 0 ? void 0 : props.direction) === "horizontal" && distanceX < -100 || (props === null || props === void 0 ? void 0 : props.direction) === "vertical" && distanceY < -100) {
          prev(1);
        } else if ((props === null || props === void 0 ? void 0 : props.direction) === "horizontal" && distanceX > 100 || (props === null || props === void 0 ? void 0 : props.direction) === "vertical" && distanceY > 100) {
          next(1);
        } else {
          move(state.activeIndex);
        }
        startAutoplay();
      };
      var relation = function relation(child) {
        if (child.proxy) {
          state.children.push(child.proxy);
        }
      };
      vue.provide("parent", {
        props: props,
        relation: relation
      });
      vue.watch(function () {
        return props.current;
      }, function (newPage, oldPage) {
        if (state.isControl) {
          state.activeIndex = newPage || 0;
          addAnimation();
          move(state.activeIndex, false);
        }
      });
      return {
        swiperContainer: swiperContainer,
        name: name$F,
        computedNavigation: computedNavigation,
        onTouchMove: onTouchMove,
        onTouchEnd: onTouchEnd,
        handleAnimationEnd: handleAnimationEnd,
        state: state,
        paginationList: paginationList,
        showPageNum: showPageNum,
        prev: prev,
        next: next
      };
    }
  });

  var _hoisted_1$f = {
    key: 0
  };
  var _hoisted_2$5 = {
    key: 1
  };
  function render$J(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_chevron_left_icon = vue.resolveComponent("chevron-left-icon");
    var _component_chevron_right_icon = vue.resolveComponent("chevron-right-icon");
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      style: vue.normalizeStyle({
        height: "".concat(_ctx.height, "px"),
        overflow: "hidden"
      }),
      class: vue.normalizeClass("".concat(_ctx.name))
    }, [vue.createElementVNode("div", {
      ref: "swiperContainer",
      class: vue.normalizeClass("".concat(_ctx.name, "__container")),
      style: vue.normalizeStyle({
        height: "".concat(_ctx.height, "px"),
        flexDirection: _ctx.direction === "horizontal" ? "row" : "column"
      }),
      onTransitionend: _cache[0] || (_cache[0] = function () {
        return _ctx.handleAnimationEnd && _ctx.handleAnimationEnd.apply(_ctx, arguments);
      })
    }, [vue.renderSlot(_ctx.$slots, "default")], 38), _ctx.navigation && _ctx.state.showNavigation ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 0
    }, [_ctx.direction === "horizontal" && "showSlideBtn" in _ctx.navigation && _ctx.navigation.showSlideBtn ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_1$f, [vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, "__btn btn-prev")),
      onClick: _cache[1] || (_cache[1] = function ($event) {
        return _ctx.prev(1);
      })
    }, [vue.createVNode(_component_chevron_left_icon, {
      size: "20px"
    })], 2), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, "__btn btn-next")),
      onClick: _cache[2] || (_cache[2] = function ($event) {
        return _ctx.next(1);
      })
    }, [vue.createVNode(_component_chevron_right_icon, {
      size: "20px"
    })], 2)])) : vue.createCommentVNode("", true), "type" in _ctx.navigation ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__pagination ").concat(_ctx.name, "__pagination-").concat(_ctx.navigation.type || "", " ").concat(_ctx.name, "__pagination-").concat(_ctx.paginationPosition))
    }, [["dots", "dots-bar"].includes(_ctx.navigation.type || "") ? (vue.openBlock(true), vue.createElementBlock(vue.Fragment, {
      key: 0
    }, vue.renderList(_ctx.state.children.length, function (item, index) {
      var _normalizeClass2;
      return vue.openBlock(), vue.createElementBlock("span", {
        key: "page" + index,
        class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, "".concat(_ctx.name, "-dot"), true), _defineProperty$2(_normalizeClass2, "".concat(_ctx.name, "-dot--active"), index === _ctx.state.activeIndex), _normalizeClass2))
      }, null, 2);
    }), 128)) : vue.createCommentVNode("", true), _ctx.navigation.type && _ctx.navigation.type === "fraction" ? (vue.openBlock(), vue.createElementBlock("span", _hoisted_2$5, vue.toDisplayString(_ctx.showPageNum + "/" + _ctx.state.children.length), 1)) : vue.createCommentVNode("", true)], 2)) : vue.createCommentVNode("", true)], 64)) : _ctx.computedNavigation !== void 0 ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 1,
      content: _ctx.computedNavigation,
      style: {}
    }, null, 8, ["content"])) : vue.createCommentVNode("", true)], 6);
  }

  script$K.render = render$J;

  var prefix$H = config.prefix;
  var name$E = "".concat(prefix$H, "-swiper-item");
  var script$J = vue.defineComponent({
    name: name$E,
    setup: function setup() {
      var parent = vue.inject("parent");
      parent.relation(vue.getCurrentInstance());
      return {
        name: name$E
      };
    }
  });

  function render$I(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.name)
    }, [vue.renderSlot(_ctx.$slots, "default")], 2);
  }

  script$J.render = render$I;

  var Swiper = withInstall(script$K);
  var SwiperItem = withInstall(script$J);

  function ownKeys$t(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$t(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$t(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$t(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$G = config.prefix;
  var name$D = "".concat(prefix$G, "-image-viewer");
  var getDistance = function getDistance(touches) {
    return Math.sqrt(Math.pow(touches[0].clientX - touches[1].clientX, 2) + Math.pow(touches[0].clientY - touches[1].clientY, 2));
  };
  var script$I = vue.defineComponent({
    name: name$D,
    components: {
      CloseCircleFilledIcon: closeCircleFilled,
      TSwiper: Swiper,
      TSwiperItem: SwiperItem,
      TOverlay: Overlay,
      TNode: TNodeComponent
    },
    props: ImageViewerProps,
    emits: ["close", "index-change", "update:visible", "update:modelValue", "change"],
    setup: function setup(props, context) {
      var state = vue.reactive({
        zooming: false,
        scale: 1
      });
      var emitEvent = useEmitEvent(props, context.emit);
      var _useDefault = useDefault(props, context.emit, "visible", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 2),
        visible = _useDefault2[0],
        setVisible = _useDefault2[1];
      var lazyVisible = vue.ref(visible.value);
      var touch = useTouch$1();
      var internalInstance = vue.getCurrentInstance();
      var closeBtnTNode = vue.computed(function () {
        return renderTNode(internalInstance, "closeBtn");
      });
      var navigation = vue.computed(function () {
        if (props.showIndex) {
          return {
            type: "fraction"
          };
        }
        return {
          type: "dots",
          showSlideBtn: false
        };
      });
      var imageStyle = vue.computed(function () {
        var scale = state.scale,
          zooming = state.zooming;
        var style = {
          transitionDuration: zooming ? "0s" : ".3s"
        };
        if (scale !== 1) {
          style.transform = "scale(".concat(scale, ", ").concat(scale, ")");
        }
        return style;
      });
      var handleClose = function handleClose(e, trigger) {
        setVisible(false);
        emitEvent("close", {
          trigger: trigger,
          e: e
        });
      };
      var onSwiperChange = function onSwiperChange(index, context2) {
        emitEvent("index-change", index);
      };
      var fingerNum;
      var startScale;
      var startDistance;
      var doubleTapTimer;
      var touchStartTime;
      var onTouchStart = function onTouchStart(event) {
        event.preventDefault();
        event.stopPropagation();
        var touches = event.touches;
        touch.start(event);
        fingerNum = touches.length;
        touchStartTime = Date.now();
        state.zooming = fingerNum === 2;
        if (state.zooming) {
          startScale = state.scale;
          startDistance = getDistance(event.touches);
        }
      };
      var onTouchMove = function onTouchMove(event) {
        var touches = event.touches;
        touch.move(event);
        event.preventDefault();
        event.stopPropagation();
        if (state.zooming) {
          event.preventDefault();
          event.stopPropagation();
        }
        if (state.zooming && touches.length === 2) {
          var distance = getDistance(touches);
          var scale = startScale * distance / startDistance;
          setScale(scale);
        }
      };
      var setScale = function setScale(scale) {
        scale = Math.min(scale, +props.maxZoom + 1);
        if (scale !== state.scale) {
          state.scale = scale;
        }
      };
      var resetScale = function resetScale() {
        setScale(1);
      };
      var toggleScale = function toggleScale() {
        var scale = state.scale > 1 ? 1 : 2;
        setScale(scale);
      };
      var checkTap = function checkTap(event) {
        if (fingerNum > 1) {
          return;
        }
        var offsetX = touch.offsetX,
          offsetY = touch.offsetY;
        var deltaTime = Date.now() - touchStartTime;
        var TAP_TIME = 250;
        var TAP_OFFSET = 5;
        if (offsetX.value < TAP_OFFSET && offsetY.value < TAP_OFFSET && deltaTime < TAP_TIME) {
          if (doubleTapTimer) {
            clearTimeout(doubleTapTimer);
            doubleTapTimer = null;
            toggleScale();
          } else {
            doubleTapTimer = window.setTimeout(function () {
              handleClose(event, "overlay");
              doubleTapTimer = null;
            }, TAP_TIME);
          }
        }
      };
      var onTouchEnd = function onTouchEnd(event) {
        event.preventDefault();
        if (state.zooming) {
          event.stopPropagation();
          if (!event.touches.length) {
            if (state.zooming) {
              state.zooming = false;
            }
            startScale = 1;
            if (state.scale < 1) {
              resetScale();
            }
            if (state.scale > props.maxZoom) {
              state.scale = +props.maxZoom;
            }
          }
        }
        checkTap(event);
        touch.reset();
      };
      vue.watch(function () {
        return visible.value;
      }, function (value) {
        if (!value) {
          resetScale();
        }
        setTimeout(function () {
          lazyVisible.value = value;
        }, 300);
      });
      return _objectSpread$t(_objectSpread$t({
        name: name$D,
        prefix: prefix$G,
        closeBtnTNode: closeBtnTNode,
        navigation: navigation,
        imageStyle: imageStyle,
        lazyVisible: lazyVisible
      }, vue.toRefs(props)), {}, {
        visible: visible,
        handleClose: handleClose,
        onSwiperChange: onSwiperChange,
        onTouchStart: onTouchStart,
        onTouchMove: onTouchMove,
        onTouchEnd: onTouchEnd
      });
    }
  });

  var _hoisted_1$e = ["src"];
  function render$H(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_close_circle_filled_icon = vue.resolveComponent("close-circle-filled-icon");
    var _component_t_swiper_item = vue.resolveComponent("t-swiper-item");
    var _component_t_swiper = vue.resolveComponent("t-swiper");
    var _component_t_overlay = vue.resolveComponent("t-overlay");
    return vue.openBlock(), vue.createBlock(_component_t_overlay, {
      class: vue.normalizeClass("".concat(_ctx.prefix, "-image-viewer")),
      visible: _ctx.visible
    }, {
      default: vue.withCtx(function () {
        return [_ctx.lazyVisible ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
          key: 0
        }, [vue.createElementVNode("div", {
          class: vue.normalizeClass("".concat(_ctx.name, "__close-icon")),
          onClick: _cache[0] || (_cache[0] = function ($event) {
            return _ctx.handleClose($event, "close-btn");
          })
        }, [!(typeof _ctx.closeBtnTNode === "boolean") ? (vue.openBlock(), vue.createBlock(_component_t_node, {
          key: 0,
          content: _ctx.closeBtnTNode
        }, null, 8, ["content"])) : typeof _ctx.closeBtn === "boolean" && _ctx.closeBtn ? (vue.openBlock(), vue.createBlock(_component_close_circle_filled_icon, {
          key: 1
        })) : vue.createCommentVNode("", true)], 2), vue.createVNode(_component_t_swiper, {
          autoplay: false,
          class: vue.normalizeClass("".concat(_ctx.name, "__swipe")),
          "default-current": _ctx.initialIndex,
          navigation: _ctx.navigation,
          "on-change": _ctx.onSwiperChange
        }, {
          default: vue.withCtx(function () {
            return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.images, function (image, index) {
              return vue.openBlock(), vue.createBlock(_component_t_swiper_item, {
                key: image + index,
                class: vue.normalizeClass("".concat(_ctx.name, "__swipe-item")),
                onTouchstart: _ctx.onTouchStart,
                onTouchmove: _ctx.onTouchMove,
                onTouchend: _ctx.onTouchEnd
              }, {
                default: vue.withCtx(function () {
                  return [vue.createElementVNode("img", {
                    src: image,
                    style: vue.normalizeStyle(_ctx.imageStyle),
                    class: vue.normalizeClass("".concat(_ctx.name, "__image"))
                  }, null, 14, _hoisted_1$e)];
                }),
                _: 2
              }, 1032, ["class", "onTouchstart", "onTouchmove", "onTouchend"]);
            }), 128))];
          }),
          _: 1
        }, 8, ["class", "default-current", "navigation", "on-change"])], 64)) : vue.createCommentVNode("", true)];
      }),
      _: 1
    }, 8, ["class", "visible"]);
  }

  script$I.render = render$H;

  var _ImageViewer = withInstall(script$I);

  var DrawerProps = {
    items: {
      type: Array
    },
    placement: {
      type: String,
      default: "right",
      validator: function validator(val) {
        if (!val) return true;
        return ["left", "right", "top", "bottom"].includes(val);
      }
    },
    showOverlay: {
      type: Boolean,
      default: true
    },
    visible: Boolean,
    zIndex: {
      type: Number
    },
    closeOnOverlayClick: {
      type: Boolean,
      default: true
    },
    onClose: Function,
    onItemClick: Function,
    onOverlayClick: Function
  };

  var prefix$F = config.prefix;
  var name$C = "".concat(prefix$F, "-drawer");
  var script$H = vue.defineComponent({
    name: name$C,
    components: {
      TPopup: _Popup
    },
    props: DrawerProps,
    emits: ["update:visible", "itemClick", "overlayClick"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var _toRefs = vue.toRefs(props),
        visible = _toRefs.visible,
        items = _toRefs.items,
        placement = _toRefs.placement,
        showOverlay = _toRefs.showOverlay,
        zIndex = _toRefs.zIndex,
        closeOnOverlayClick = _toRefs.closeOnOverlayClick;
      var open = vue.ref(visible.value || false);
      var dSideBarClassName = vue.computed(function () {
        return "".concat(name$C, "__sidebar");
      });
      var dSideBarItemClassName = vue.computed(function () {
        return "".concat(name$C, "__sidebar-item");
      });
      var dSideBarItemIconClassName = vue.computed(function () {
        return "".concat(name$C, "__sidebar-item-icon");
      });
      var dSideBarItemTitleClassName = vue.computed(function () {
        return "".concat(name$C, "__sidebar-item-title");
      });
      vue.watch(open, function () {
        emitEvent("update:visible", open.value);
      });
      vue.watch(visible, function () {
        open.value = visible.value;
      });
      var onItemClick = function onItemClick(index, item, context2) {
        emitEvent("itemClick", index, item, context2);
      };
      var onVisibleChange = function onVisibleChange(visible2) {
        if (showOverlay.value) {
          emitEvent("overlayClick", {
            visible: visible2
          });
        }
      };
      var onClose = function onClose() {
        emitEvent("close", {
          trigger: "overlay"
        });
      };
      return {
        items: items,
        placement: placement,
        showOverlay: showOverlay,
        zIndex: zIndex,
        closeOnOverlayClick: closeOnOverlayClick,
        open: open,
        dSideBarClassName: dSideBarClassName,
        dSideBarItemClassName: dSideBarItemClassName,
        dSideBarItemIconClassName: dSideBarItemIconClassName,
        dSideBarItemTitleClassName: dSideBarItemTitleClassName,
        onItemClick: onItemClick,
        onVisibleChange: onVisibleChange,
        onClose: onClose
      };
    }
  });

  var _hoisted_1$d = ["onClick"];
  function render$G(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_popup = vue.resolveComponent("t-popup");
    return vue.openBlock(), vue.createBlock(_component_t_popup, {
      modelValue: _ctx.open,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
        return _ctx.open = $event;
      }),
      placement: _ctx.placement,
      "show-overlay": _ctx.showOverlay,
      "z-index": _ctx.zIndex,
      "close-on-overlay-click": _ctx.closeOnOverlayClick,
      onVisibleChange: _ctx.onVisibleChange,
      onClose: _ctx.onClose
    }, {
      default: vue.withCtx(function () {
        return [vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.dSideBarClassName)
        }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.items, function (item, index) {
          return vue.openBlock(), vue.createElementBlock("div", {
            key: item.title,
            class: vue.normalizeClass(_ctx.dSideBarItemClassName),
            onClick: function onClick($event) {
              return _ctx.onItemClick(index, item, {
                e: $event
              });
            }
          }, [!!item.icon ? (vue.openBlock(), vue.createElementBlock("span", {
            key: 0,
            class: vue.normalizeClass(_ctx.dSideBarItemIconClassName)
          }, [(vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(item.icon)))], 2)) : vue.createCommentVNode("", true), vue.createElementVNode("div", {
            class: vue.normalizeClass(_ctx.dSideBarItemTitleClassName)
          }, vue.toDisplayString(item.title), 3)], 10, _hoisted_1$d);
        }), 128))], 2)];
      }),
      _: 1
    }, 8, ["modelValue", "placement", "show-overlay", "z-index", "close-on-overlay-click", "onVisibleChange", "onClose"]);
  }

  script$H.render = render$G;

  var _Drawer = withInstall(script$H);

  var NavbarProps = {
    animation: {
      type: Boolean,
      default: true
    },
    background: {
      type: String,
      default: ""
    },
    fixed: {
      type: Boolean,
      default: true
    },
    homeIcon: {
      type: [Boolean, Function]
    },
    leftIcon: {
      type: [Boolean, Function],
      default: false
    },
    rightIcon: {
      type: Function
    },
    title: {
      type: [String, Function]
    },
    titleMaxLength: {
      type: Number
    },
    visible: {
      type: Boolean,
      default: true
    },
    onLeftClick: Function,
    onRightClick: Function
  };

  var prefix$E = config.prefix;
  var name$B = "".concat(prefix$E, "-navbar");
  var script$G = vue.defineComponent({
    name: name$B,
    components: {
      TChevronLeftIcon: chevronLeft,
      TNode: TNodeComponent,
      THomeIcon: home
    },
    props: NavbarProps,
    emits: ["left-click", "right-click"],
    setup: function setup(props, context) {
      var internalInstance = vue.getCurrentInstance();
      var _toRefs = vue.toRefs(props),
        title = _toRefs.title,
        titleMaxLength = _toRefs.titleMaxLength,
        fixed = _toRefs.fixed,
        background = _toRefs.background;
      var navStyle = vue.computed(function () {
        return "position: ".concat(fixed.value ? "fixed" : "relative", "; background: ").concat(background.value || "", ";");
      });
      var titleContent = vue.computed(function () {
        if (titleMaxLength.value != null && title.value) {
          if (titleMaxLength.value <= 0) {
            console.warn("titleMaxLength must be greater than 0");
          } else {
            return title.value.length <= titleMaxLength.value ? props.title : "".concat(title.value.slice(0, titleMaxLength.value), "...");
          }
        }
        return renderTNode(internalInstance, "title");
      });
      var leftContent = vue.computed(function () {
        return renderTNode(internalInstance, "left-icon");
      });
      var rightContent = vue.computed(function () {
        return renderTNode(internalInstance, "right-icon");
      });
      var homeContent = vue.computed(function () {
        return renderTNode(internalInstance, "home-icon");
      });
      var emitEvent = useEmitEvent(props, context.emit);
      var handleLeftClick = function handleLeftClick() {
        emitEvent("left-click");
      };
      var handleRightClick = function handleRightClick() {
        emitEvent("right-click");
      };
      return {
        name: name$B,
        titleContent: titleContent,
        leftContent: leftContent,
        rightContent: rightContent,
        navStyle: navStyle,
        homeContent: homeContent,
        handleLeftClick: handleLeftClick,
        handleRightClick: handleRightClick
      };
    }
  });

  function render$F(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_chevron_left_icon = vue.resolveComponent("t-chevron-left-icon");
    var _component_t_home_icon = vue.resolveComponent("t-home-icon");
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.name),
      style: vue.normalizeStyle("".concat(_ctx.navStyle))
    }, [_ctx.homeContent || _ctx.leftContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__back"))
    }, [_ctx.leftIcon === true ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__back--arrow")),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.handleLeftClick && _ctx.handleLeftClick.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_t_chevron_left_icon)], 2)) : vue.createCommentVNode("", true), _ctx.homeIcon === true ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__back--arrow"))
    }, [vue.createVNode(_component_t_home_icon)], 2)) : vue.createCommentVNode("", true), vue.createVNode(_component_t_node, {
      content: _ctx.homeContent
    }, null, 8, ["content"]), vue.createVNode(_component_t_node, {
      content: _ctx.leftContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__text"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.titleContent
    }, null, 8, ["content"])], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__right")),
      onClick: _cache[1] || (_cache[1] = function () {
        return _ctx.handleRightClick && _ctx.handleRightClick.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.rightContent
    }, null, 8, ["content"])], 2)], 6)), [[vue.vShow, _ctx.visible]]);
  }

  script$G.render = render$F;

  var _Navbar = withInstall(script$G);

  var lodash = {exports: {}};

  (function(module,exports){(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined$1;/** Used as the semantic version number. */var VERSION='4.17.21';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function',INVALID_TEMPL_VAR_ERROR_TEXT='Invalid `variable` option passed into `_.template`';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
     * Used to match `RegExp`
     * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
     */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading whitespace. */var reTrimStart=/^\s+/;/** Used to match a single whitespace character. */var reWhitespace=/\s/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/**
     * Used to validate the `validate` option in `_.template` variable.
     *
     * Forbids characters which could potentially change the meaning of the function argument definition:
     * - "()," (modification of function parameters)
     * - "=" (default value)
     * - "[]{}" (destructuring of function parameters)
     * - "/" (beginning of a comment)
     * - whitespace
     */var reForbiddenIdentifierChars=/[()=,{}\[\]\/\s]/;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
     * Used to match
     * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
     */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange="\\ud800-\\udfff",rsComboMarksRange="\\u0300-\\u036f",reComboHalfMarksRange="\\ufe20-\\ufe2f",rsComboSymbolsRange="\\u20d0-\\u20ff",rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange="\\u2700-\\u27bf",rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange="\\u2000-\\u206f",rsSpaceRange=" \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange="\\ufe0e\\ufe0f",rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz="\\ud83c[\\udffb-\\udfff]",rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional="(?:\\ud83c[\\udde6-\\uddff]){2}",rsSurrPair="[\\ud800-\\udbff][\\udc00-\\udfff]",rsUpper='['+rsUpperRange+']',rsZWJ="\\u200d";/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
     * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
     * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
     */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
  '\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
  "\u0100":'A',"\u0102":'A',"\u0104":'A',"\u0101":'a',"\u0103":'a',"\u0105":'a',"\u0106":'C',"\u0108":'C',"\u010A":'C',"\u010C":'C',"\u0107":'c',"\u0109":'c',"\u010B":'c',"\u010D":'c',"\u010E":'D',"\u0110":'D',"\u010F":'d',"\u0111":'d',"\u0112":'E',"\u0114":'E',"\u0116":'E',"\u0118":'E',"\u011A":'E',"\u0113":'e',"\u0115":'e',"\u0117":'e',"\u0119":'e',"\u011B":'e',"\u011C":'G',"\u011E":'G',"\u0120":'G',"\u0122":'G',"\u011D":'g',"\u011F":'g',"\u0121":'g',"\u0123":'g',"\u0124":'H',"\u0126":'H',"\u0125":'h',"\u0127":'h',"\u0128":'I',"\u012A":'I',"\u012C":'I',"\u012E":'I',"\u0130":'I',"\u0129":'i',"\u012B":'i',"\u012D":'i',"\u012F":'i',"\u0131":'i',"\u0134":'J',"\u0135":'j',"\u0136":'K',"\u0137":'k',"\u0138":'k',"\u0139":'L',"\u013B":'L',"\u013D":'L',"\u013F":'L',"\u0141":'L',"\u013A":'l',"\u013C":'l',"\u013E":'l',"\u0140":'l',"\u0142":'l',"\u0143":'N',"\u0145":'N',"\u0147":'N',"\u014A":'N',"\u0144":'n',"\u0146":'n',"\u0148":'n',"\u014B":'n',"\u014C":'O',"\u014E":'O',"\u0150":'O',"\u014D":'o',"\u014F":'o',"\u0151":'o',"\u0154":'R',"\u0156":'R',"\u0158":'R',"\u0155":'r',"\u0157":'r',"\u0159":'r',"\u015A":'S',"\u015C":'S',"\u015E":'S',"\u0160":'S',"\u015B":'s',"\u015D":'s',"\u015F":'s',"\u0161":'s',"\u0162":'T',"\u0164":'T',"\u0166":'T',"\u0163":'t',"\u0165":'t',"\u0167":'t',"\u0168":'U',"\u016A":'U',"\u016C":'U',"\u016E":'U',"\u0170":'U',"\u0172":'U',"\u0169":'u',"\u016B":'u',"\u016D":'u',"\u016F":'u',"\u0171":'u',"\u0173":'u',"\u0174":'W',"\u0175":'w',"\u0176":'Y',"\u0177":'y',"\u0178":'Y',"\u0179":'Z',"\u017B":'Z',"\u017D":'Z',"\u017A":'z',"\u017C":'z',"\u017E":'z',"\u0132":'IJ',"\u0133":'ij',"\u0152":'Oe',"\u0153":'oe',"\u0149":"'n","\u017F":'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r',"\u2028":'u2028',"\u2029":'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=_typeof$1(commonjsGlobal)=='object'&&commonjsGlobal&&commonjsGlobal.Object===Object&&commonjsGlobal;/** Detect free variable `self`. */var freeSelf=(typeof self==="undefined"?"undefined":_typeof$1(self))=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&'object'=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
  var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
  return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
     * A faster alternative to `Function#apply`, this function invokes `func`
     * with the `this` binding of `thisArg` and the arguments of `args`.
     *
     * @private
     * @param {Function} func The function to invoke.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} args The arguments to invoke `func` with.
     * @returns {*} Returns the result of `func`.
     */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
     * A specialized version of `baseAggregator` for arrays.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
     * A specialized version of `_.forEach` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
     * A specialized version of `_.forEachRight` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns `array`.
     */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
     * A specialized version of `_.every` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
     * A specialized version of `_.filter` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
     * A specialized version of `_.includes` for arrays without support for
     * specifying an index to search from.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */function arrayIncludes(array,value){var length=array==null?0:array.length;return !!length&&baseIndexOf(array,value,0)>-1;}/**
     * This function is like `arrayIncludes` except that it accepts a comparator.
     *
     * @private
     * @param {Array} [array] The array to inspect.
     * @param {*} target The value to search for.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {boolean} Returns `true` if `target` is found, else `false`.
     */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
     * A specialized version of `_.map` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
     * Appends the elements of `values` to `array`.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to append.
     * @returns {Array} Returns `array`.
     */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
     * A specialized version of `_.reduce` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the first element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
     * A specialized version of `_.reduceRight` for arrays without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @param {boolean} [initAccum] Specify using the last element of `array` as
     *  the initial value.
     * @returns {*} Returns the accumulated value.
     */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
     * A specialized version of `_.some` for arrays without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} [array] The array to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
     * Gets the size of an ASCII `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */var asciiSize=baseProperty('length');/**
     * Converts an ASCII `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */function asciiToArray(string){return string.split('');}/**
     * Splits an ASCII `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
     * The base implementation of methods like `_.findKey` and `_.findLastKey`,
     * without support for iteratee shorthands, which iterates over `collection`
     * using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the found element or its key, else `undefined`.
     */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
     * The base implementation of `_.findIndex` and `_.findLastIndex` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} predicate The function invoked per iteration.
     * @param {number} fromIndex The index to search from.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return -1;}/**
     * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
     * This function is like `baseIndexOf` except that it accepts a comparator.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @param {Function} comparator The comparator invoked per element.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return -1;}/**
     * The base implementation of `_.isNaN` without support for number objects.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     */function baseIsNaN(value){return value!==value;}/**
     * The base implementation of `_.mean` and `_.meanBy` without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the mean.
     */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
     * The base implementation of `_.property` without support for deep paths.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function baseProperty(key){return function(object){return object==null?undefined$1:object[key];};}/**
     * The base implementation of `_.propertyOf` without support for deep paths.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyOf(object){return function(key){return object==null?undefined$1:object[key];};}/**
     * The base implementation of `_.reduce` and `_.reduceRight`, without support
     * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {*} accumulator The initial value.
     * @param {boolean} initAccum Specify using the first or last element of
     *  `collection` as the initial value.
     * @param {Function} eachFunc The function to iterate over `collection`.
     * @returns {*} Returns the accumulated value.
     */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
     * The base implementation of `_.sortBy` which uses `comparer` to define the
     * sort order of `array` and replaces criteria objects with their corresponding
     * values.
     *
     * @private
     * @param {Array} array The array to sort.
     * @param {Function} comparer The function to define sort order.
     * @returns {Array} Returns `array`.
     */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
     * The base implementation of `_.sum` and `_.sumBy` without support for
     * iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {number} Returns the sum.
     */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined$1){result=result===undefined$1?current:result+current;}}return result;}/**
     * The base implementation of `_.times` without support for iteratee shorthands
     * or max array length checks.
     *
     * @private
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
     * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
     * of key-value pairs for `object` corresponding to the property names of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the key-value pairs.
     */function baseToPairs(object,props){return arrayMap(props,function(key){return [key,object[key]];});}/**
     * The base implementation of `_.trim`.
     *
     * @private
     * @param {string} string The string to trim.
     * @returns {string} Returns the trimmed string.
     */function baseTrim(string){return string?string.slice(0,trimmedEndIndex(string)+1).replace(reTrimStart,''):string;}/**
     * The base implementation of `_.unary` without support for storing metadata.
     *
     * @private
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     */function baseUnary(func){return function(value){return func(value);};}/**
     * The base implementation of `_.values` and `_.valuesIn` which creates an
     * array of `object` property values corresponding to the property names
     * of `props`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} props The property names to get values for.
     * @returns {Object} Returns the array of property values.
     */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
     * Checks if a `cache` value for `key` exists.
     *
     * @private
     * @param {Object} cache The cache to query.
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function cacheHas(cache,key){return cache.has(key);}/**
     * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
     * that is not found in the character symbols.
     *
     * @private
     * @param {Array} strSymbols The string symbols to inspect.
     * @param {Array} chrSymbols The character symbols to find.
     * @returns {number} Returns the index of the first unmatched string symbol.
     */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
     * that is not found in the character symbols.
     *
     * @private
     * @param {Array} strSymbols The string symbols to inspect.
     * @param {Array} chrSymbols The character symbols to find.
     * @returns {number} Returns the index of the last unmatched string symbol.
     */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
     * Gets the number of `placeholder` occurrences in `array`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} placeholder The placeholder to search for.
     * @returns {number} Returns the placeholder count.
     */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
     * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
     * letters to basic Latin letters.
     *
     * @private
     * @param {string} letter The matched letter to deburr.
     * @returns {string} Returns the deburred letter.
     */var deburrLetter=basePropertyOf(deburredLetters);/**
     * Used by `_.escape` to convert characters to HTML entities.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
     * Used by `_.template` to escape characters for inclusion in compiled string literals.
     *
     * @private
     * @param {string} chr The matched character to escape.
     * @returns {string} Returns the escaped character.
     */function escapeStringChar(chr){return '\\'+stringEscapes[chr];}/**
     * Gets the value at `key` of `object`.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function getValue(object,key){return object==null?undefined$1:object[key];}/**
     * Checks if `string` contains Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a symbol is found, else `false`.
     */function hasUnicode(string){return reHasUnicode.test(string);}/**
     * Checks if `string` contains a word composed of Unicode symbols.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {boolean} Returns `true` if a word is found, else `false`.
     */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
     * Converts `iterator` to an array.
     *
     * @private
     * @param {Object} iterator The iterator to convert.
     * @returns {Array} Returns the converted array.
     */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
     * Converts `map` to its key-value pairs.
     *
     * @private
     * @param {Object} map The map to convert.
     * @returns {Array} Returns the key-value pairs.
     */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
     * Creates a unary function that invokes `func` with its argument transformed.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {Function} transform The argument transform.
     * @returns {Function} Returns the new function.
     */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
     * Replaces all `placeholder` elements in `array` with an internal placeholder
     * and returns an array of their indexes.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {*} placeholder The placeholder to replace.
     * @returns {Array} Returns the new array of placeholder indexes.
     */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
     * Converts `set` to an array of its values.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the values.
     */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
     * Converts `set` to its value-value pairs.
     *
     * @private
     * @param {Object} set The set to convert.
     * @returns {Array} Returns the value-value pairs.
     */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
     * A specialized version of `_.indexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return -1;}/**
     * A specialized version of `_.lastIndexOf` which performs strict equality
     * comparisons of values, i.e. `===`.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} fromIndex The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
     * Gets the number of symbols in `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the string size.
     */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
     * Converts `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
     * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
     * character of `string`.
     *
     * @private
     * @param {string} string The string to inspect.
     * @returns {number} Returns the index of the last non-whitespace character.
     */function trimmedEndIndex(string){var index=string.length;while(index--&&reWhitespace.test(string.charAt(index))){}return index;}/**
     * Used by `_.unescape` to convert HTML entities to characters.
     *
     * @private
     * @param {string} chr The matched character to unescape.
     * @returns {string} Returns the unescaped character.
     */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
     * Gets the size of a Unicode `string`.
     *
     * @private
     * @param {string} string The string inspect.
     * @returns {number} Returns the string size.
     */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
     * Converts a Unicode `string` to an array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the converted array.
     */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
     * Splits a Unicode `string` into an array of its words.
     *
     * @private
     * @param {string} The string to inspect.
     * @returns {Array} Returns the words of `string`.
     */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
     * Create a new pristine `lodash` function using the `context` object.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Util
     * @param {Object} [context=root] The context object.
     * @returns {Function} Returns a new `lodash` function.
     * @example
     *
     * _.mixin({ 'foo': _.constant('foo') });
     *
     * var lodash = _.runInContext();
     * lodash.mixin({ 'bar': lodash.constant('bar') });
     *
     * _.isFunction(_.foo);
     * // => true
     * _.isFunction(_.bar);
     * // => false
     *
     * lodash.isFunction(lodash.foo);
     * // => false
     * lodash.isFunction(lodash.bar);
     * // => true
     *
     * // Create a suped-up `defer` in Node.js.
     * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
     */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
       * Used to resolve the
       * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
       * of values.
       */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined$1,_Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined$1,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=_Symbol?_Symbol.isConcatSpreadable:undefined$1,symIterator=_Symbol?_Symbol.iterator:undefined$1,symToStringTag=_Symbol?_Symbol.toStringTag:undefined$1;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined$1,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=_Symbol?_Symbol.prototype:undefined$1,symbolValueOf=symbolProto?symbolProto.valueOf:undefined$1,symbolToString=symbolProto?symbolProto.toString:undefined$1;/*------------------------------------------------------------------------*/ /**
       * Creates a `lodash` object which wraps `value` to enable implicit method
       * chain sequences. Methods that operate on and return arrays, collections,
       * and functions can be chained together. Methods that retrieve a single value
       * or may return a primitive value will automatically end the chain sequence
       * and return the unwrapped value. Otherwise, the value must be unwrapped
       * with `_#value`.
       *
       * Explicit chain sequences, which must be unwrapped with `_#value`, may be
       * enabled using `_.chain`.
       *
       * The execution of chained methods is lazy, that is, it's deferred until
       * `_#value` is implicitly or explicitly called.
       *
       * Lazy evaluation allows several methods to support shortcut fusion.
       * Shortcut fusion is an optimization to merge iteratee calls; this avoids
       * the creation of intermediate arrays and can greatly reduce the number of
       * iteratee executions. Sections of a chain sequence qualify for shortcut
       * fusion if the section is applied to an array and iteratees accept only
       * one argument. The heuristic for whether a section qualifies for shortcut
       * fusion is subject to change.
       *
       * Chaining is supported in custom builds as long as the `_#value` method is
       * directly or indirectly included in the build.
       *
       * In addition to lodash methods, wrappers have `Array` and `String` methods.
       *
       * The wrapper `Array` methods are:
       * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
       *
       * The wrapper `String` methods are:
       * `replace` and `split`
       *
       * The wrapper methods that support shortcut fusion are:
       * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
       * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
       * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
       *
       * The chainable wrapper methods are:
       * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
       * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
       * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
       * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
       * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
       * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
       * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
       * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
       * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
       * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
       * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
       * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
       * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
       * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
       * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
       * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
       * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
       * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
       * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
       * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
       * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
       * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
       * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
       * `zipObject`, `zipObjectDeep`, and `zipWith`
       *
       * The wrapper methods that are **not** chainable by default are:
       * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
       * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
       * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
       * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
       * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
       * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
       * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
       * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
       * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
       * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
       * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
       * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
       * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
       * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
       * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
       * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
       * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
       * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
       * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
       * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
       * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
       * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
       * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
       * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
       * `upperFirst`, `value`, and `words`
       *
       * @name _
       * @constructor
       * @category Seq
       * @param {*} value The value to wrap in a `lodash` instance.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var wrapped = _([1, 2, 3]);
       *
       * // Returns an unwrapped value.
       * wrapped.reduce(_.add);
       * // => 6
       *
       * // Returns a wrapped value.
       * var squares = wrapped.map(square);
       *
       * _.isArray(squares);
       * // => false
       *
       * _.isArray(squares.value());
       * // => true
       */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
       * The base implementation of `_.create` without support for assigning
       * properties to the created object.
       *
       * @private
       * @param {Object} proto The object to inherit from.
       * @returns {Object} Returns the new object.
       */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return {};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined$1;return result;};}();/**
       * The function whose prototype chain sequence wrappers inherit from.
       *
       * @private
       */function baseLodash(){// No operation performed.
  }/**
       * The base constructor for creating `lodash` wrapper objects.
       *
       * @private
       * @param {*} value The value to wrap.
       * @param {boolean} [chainAll] Enable explicit method chain sequences.
       */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined$1;}/**
       * By default, the template delimiters used by lodash are like those in
       * embedded Ruby (ERB) as well as ES2015 template strings. Change the
       * following template settings to use alternative delimiters.
       *
       * @static
       * @memberOf _
       * @type {Object}
       */lodash.templateSettings={/**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */'escape':reEscape,/**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */'evaluate':reEvaluate,/**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */'interpolate':reInterpolate,/**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */'variable':'',/**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */'imports':{/**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
  lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
       * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
       *
       * @private
       * @constructor
       * @param {*} value The value to wrap.
       */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
       * Creates a clone of the lazy wrapper object.
       *
       * @private
       * @name clone
       * @memberOf LazyWrapper
       * @returns {Object} Returns the cloned `LazyWrapper` object.
       */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
       * Reverses the direction of lazy iteration.
       *
       * @private
       * @name reverse
       * @memberOf LazyWrapper
       * @returns {Object} Returns the new reversed `LazyWrapper` object.
       */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else {result=this.clone();result.__dir__*=-1;}return result;}/**
       * Extracts the unwrapped value from its lazy wrapper.
       *
       * @private
       * @name value
       * @memberOf LazyWrapper
       * @returns {*} Returns the unwrapped value.
       */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else {break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
  LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
       * Creates a hash object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
       * Removes all key-value entries from the hash.
       *
       * @private
       * @name clear
       * @memberOf Hash
       */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
       * Removes `key` and its value from the hash.
       *
       * @private
       * @name delete
       * @memberOf Hash
       * @param {Object} hash The hash to modify.
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
       * Gets the hash value for `key`.
       *
       * @private
       * @name get
       * @memberOf Hash
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined$1:result;}return hasOwnProperty.call(data,key)?data[key]:undefined$1;}/**
       * Checks if a hash value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Hash
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined$1:hasOwnProperty.call(data,key);}/**
       * Sets the hash `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Hash
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the hash instance.
       */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined$1?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
  Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
       * Creates an list cache object.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
       * Removes all key-value entries from the list cache.
       *
       * @private
       * @name clear
       * @memberOf ListCache
       */function listCacheClear(){this.__data__=[];this.size=0;}/**
       * Removes `key` and its value from the list cache.
       *
       * @private
       * @name delete
       * @memberOf ListCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else {splice.call(data,index,1);}--this.size;return true;}/**
       * Gets the list cache value for `key`.
       *
       * @private
       * @name get
       * @memberOf ListCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined$1:data[index][1];}/**
       * Checks if a list cache value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf ListCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
       * Sets the list cache `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf ListCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the list cache instance.
       */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else {data[index][1]=value;}return this;}// Add methods to `ListCache`.
  ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
       * Creates a map cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
       * Removes all key-value entries from the map.
       *
       * @private
       * @name clear
       * @memberOf MapCache
       */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
       * Removes `key` and its value from the map.
       *
       * @private
       * @name delete
       * @memberOf MapCache
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
       * Gets the map value for `key`.
       *
       * @private
       * @name get
       * @memberOf MapCache
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
       * Checks if a map value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf MapCache
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
       * Sets the map `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf MapCache
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the map cache instance.
       */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
  MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
       *
       * Creates an array cache object to store unique values.
       *
       * @private
       * @constructor
       * @param {Array} [values] The values to cache.
       */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
       * Adds `value` to the array cache.
       *
       * @private
       * @name add
       * @memberOf SetCache
       * @alias push
       * @param {*} value The value to cache.
       * @returns {Object} Returns the cache instance.
       */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
       * Checks if `value` is in the array cache.
       *
       * @private
       * @name has
       * @memberOf SetCache
       * @param {*} value The value to search for.
       * @returns {number} Returns `true` if `value` is found, else `false`.
       */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
  SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
       * Creates a stack cache object to store key-value pairs.
       *
       * @private
       * @constructor
       * @param {Array} [entries] The key-value pairs to cache.
       */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
       * Removes all key-value entries from the stack.
       *
       * @private
       * @name clear
       * @memberOf Stack
       */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
       * Removes `key` and its value from the stack.
       *
       * @private
       * @name delete
       * @memberOf Stack
       * @param {string} key The key of the value to remove.
       * @returns {boolean} Returns `true` if the entry was removed, else `false`.
       */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
       * Gets the stack value for `key`.
       *
       * @private
       * @name get
       * @memberOf Stack
       * @param {string} key The key of the value to get.
       * @returns {*} Returns the entry value.
       */function stackGet(key){return this.__data__.get(key);}/**
       * Checks if a stack value for `key` exists.
       *
       * @private
       * @name has
       * @memberOf Stack
       * @param {string} key The key of the entry to check.
       * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
       */function stackHas(key){return this.__data__.has(key);}/**
       * Sets the stack `key` to `value`.
       *
       * @private
       * @name set
       * @memberOf Stack
       * @param {string} key The key of the value to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns the stack cache instance.
       */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
  Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
       * Creates an array of the enumerable property names of the array-like `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @param {boolean} inherited Specify returning inherited property names.
       * @returns {Array} Returns the array of property names.
       */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
  key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
  isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
  isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
  isIndex(key,length)))){result.push(key);}}return result;}/**
       * A specialized version of `_.sample` for arrays.
       *
       * @private
       * @param {Array} array The array to sample.
       * @returns {*} Returns the random element.
       */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined$1;}/**
       * A specialized version of `_.sampleSize` for arrays.
       *
       * @private
       * @param {Array} array The array to sample.
       * @param {number} n The number of elements to sample.
       * @returns {Array} Returns the random elements.
       */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
       * A specialized version of `_.shuffle` for arrays.
       *
       * @private
       * @param {Array} array The array to shuffle.
       * @returns {Array} Returns the new shuffled array.
       */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
       * This function is like `assignValue` except that it doesn't assign
       * `undefined` values.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */function assignMergeValue(object,key,value){if(value!==undefined$1&&!eq(object[key],value)||value===undefined$1&&!(key in object)){baseAssignValue(object,key,value);}}/**
       * Assigns `value` to `key` of `object` if the existing value is not equivalent
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined$1&&!(key in object)){baseAssignValue(object,key,value);}}/**
       * Gets the index at which the `key` is found in `array` of key-value pairs.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {*} key The key to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return -1;}/**
       * Aggregates elements of `collection` on `accumulator` with keys transformed
       * by `iteratee` and values set by `setter`.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform keys.
       * @param {Object} accumulator The initial aggregated object.
       * @returns {Function} Returns `accumulator`.
       */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
       * The base implementation of `_.assign` without support for multiple sources
       * or `customizer` functions.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @returns {Object} Returns `object`.
       */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
       * The base implementation of `_.assignIn` without support for multiple sources
       * or `customizer` functions.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @returns {Object} Returns `object`.
       */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
       * The base implementation of `assignValue` and `assignMergeValue` without
       * value checks.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {string} key The key of the property to assign.
       * @param {*} value The value to assign.
       */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else {object[key]=value;}}/**
       * The base implementation of `_.at` without support for individual paths.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {string[]} paths The property paths to pick.
       * @returns {Array} Returns the picked elements.
       */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined$1:get(object,paths[index]);}return result;}/**
       * The base implementation of `_.clamp` which doesn't coerce arguments.
       *
       * @private
       * @param {number} number The number to clamp.
       * @param {number} [lower] The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the clamped number.
       */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined$1){number=number<=upper?number:upper;}if(lower!==undefined$1){number=number>=lower?number:lower;}}return number;}/**
       * The base implementation of `_.clone` and `_.cloneDeep` which tracks
       * traversed objects.
       *
       * @private
       * @param {*} value The value to clone.
       * @param {boolean} bitmask The bitmask flags.
       *  1 - Deep clone
       *  2 - Flatten inherited properties
       *  4 - Clone symbols
       * @param {Function} [customizer] The function to customize cloning.
       * @param {string} [key] The key of `value`.
       * @param {Object} [object] The parent object of `value`.
       * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
       * @returns {*} Returns the cloned value.
       */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined$1){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else {var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else {if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
  stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined$1:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
  assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
       * The base implementation of `_.conforms` which doesn't clone `source`.
       *
       * @private
       * @param {Object} source The object of property predicates to conform to.
       * @returns {Function} Returns the new spec function.
       */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
       * The base implementation of `_.conformsTo` which accepts `props` to check.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property predicates to conform to.
       * @returns {boolean} Returns `true` if `object` conforms, else `false`.
       */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return !length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined$1&&!(key in object)||!predicate(value)){return false;}}return true;}/**
       * The base implementation of `_.delay` and `_.defer` which accepts `args`
       * to provide to `func`.
       *
       * @private
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @param {Array} args The arguments to provide to `func`.
       * @returns {number|Object} Returns the timer id or timeout object.
       */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined$1,args);},wait);}/**
       * The base implementation of methods like `_.difference` without support
       * for excluding multiple arrays or iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Array} values The values to exclude.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
       * The base implementation of `_.forEach` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       */var baseEach=createBaseEach(baseForOwn);/**
       * The base implementation of `_.forEachRight` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
       * The base implementation of `_.every` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`
       */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
       * The base implementation of methods like `_.max` and `_.min` which accepts a
       * `comparator` to determine the extremum value.
       *
       * @private
       * @param {Array} array The array to iterate over.
       * @param {Function} iteratee The iteratee invoked per iteration.
       * @param {Function} comparator The comparator used to compare values.
       * @returns {*} Returns the extremum value.
       */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined$1?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
       * The base implementation of `_.fill` without an iteratee call guard.
       *
       * @private
       * @param {Array} array The array to fill.
       * @param {*} value The value to fill `array` with.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns `array`.
       */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined$1||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
       * The base implementation of `_.filter` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
       * The base implementation of `_.flatten` with support for restricting flattening.
       *
       * @private
       * @param {Array} array The array to flatten.
       * @param {number} depth The maximum recursion depth.
       * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
       * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
       * @param {Array} [result=[]] The initial result value.
       * @returns {Array} Returns the new flattened array.
       */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
  baseFlatten(value,depth-1,predicate,isStrict,result);}else {arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
       * The base implementation of `baseForOwn` which iterates over `object`
       * properties returned by `keysFunc` and invokes `iteratee` for each property.
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @returns {Object} Returns `object`.
       */var baseFor=createBaseFor();/**
       * This function is like `baseFor` except that it iterates over properties
       * in the opposite order.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @returns {Object} Returns `object`.
       */var baseForRight=createBaseFor(true);/**
       * The base implementation of `_.forOwn` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Object} Returns `object`.
       */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
       * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Object} Returns `object`.
       */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
       * The base implementation of `_.functions` which creates an array of
       * `object` function property names filtered from `props`.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Array} props The property names to filter.
       * @returns {Array} Returns the function names.
       */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
       * The base implementation of `_.get` without support for default values.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @returns {*} Returns the resolved value.
       */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined$1;}/**
       * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
       * `keysFunc` and `symbolsFunc` to get the enumerable property names and
       * symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Function} keysFunc The function to get the keys of `object`.
       * @param {Function} symbolsFunc The function to get the symbols of `object`.
       * @returns {Array} Returns the array of property names and symbols.
       */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
       * The base implementation of `getTag` without fallbacks for buggy environments.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */function baseGetTag(value){if(value==null){return value===undefined$1?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
       * The base implementation of `_.gt` which doesn't coerce arguments.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than `other`,
       *  else `false`.
       */function baseGt(value,other){return value>other;}/**
       * The base implementation of `_.has` without support for deep paths.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {Array|string} key The key to check.
       * @returns {boolean} Returns `true` if `key` exists, else `false`.
       */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
       * The base implementation of `_.hasIn` without support for deep paths.
       *
       * @private
       * @param {Object} [object] The object to query.
       * @param {Array|string} key The key to check.
       * @returns {boolean} Returns `true` if `key` exists, else `false`.
       */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
       * The base implementation of `_.inRange` which doesn't coerce arguments.
       *
       * @private
       * @param {number} number The number to check.
       * @param {number} start The start of the range.
       * @param {number} end The end of the range.
       * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
       */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
       * The base implementation of methods like `_.intersection`, without support
       * for iteratee shorthands, that accepts an array of arrays to inspect.
       *
       * @private
       * @param {Array} arrays The arrays to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of shared values.
       */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined$1;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
       * The base implementation of `_.invert` and `_.invertBy` which inverts
       * `object` with values transformed by `iteratee` and set by `setter`.
       *
       * @private
       * @param {Object} object The object to iterate over.
       * @param {Function} setter The function to set `accumulator` values.
       * @param {Function} iteratee The iteratee to transform values.
       * @param {Object} accumulator The initial inverted object.
       * @returns {Function} Returns `accumulator`.
       */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
       * The base implementation of `_.invoke` without support for individual
       * method arguments.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the method to invoke.
       * @param {Array} args The arguments to invoke the method with.
       * @returns {*} Returns the result of the invoked method.
       */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined$1:apply(func,object,args);}/**
       * The base implementation of `_.isArguments`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
       * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
       */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
       * The base implementation of `_.isDate` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
       */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
       * The base implementation of `_.isEqual` which supports partial comparisons
       * and tracks traversed objects.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {boolean} bitmask The bitmask flags.
       *  1 - Unordered comparison
       *  2 - Partial comparison
       * @param {Function} [customizer] The function to customize comparisons.
       * @param {Object} [stack] Tracks traversed `value` and `other` objects.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
       * A specialized version of `baseIsEqual` for arrays and objects which performs
       * deep comparisons and tracks traversed objects enabling objects with circular
       * references to be compared.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} [stack] Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
       * The base implementation of `_.isMap` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a map, else `false`.
       */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
       * The base implementation of `_.isMatch` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @param {Array} matchData The property names, values, and compare flags to match.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return !length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined$1&&!(key in object)){return false;}}else {var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined$1?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
       * The base implementation of `_.isNative` without bad shim checks.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
       * The base implementation of `_.isRegExp` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
       */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
       * The base implementation of `_.isSet` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a set, else `false`.
       */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
       * The base implementation of `_.isTypedArray` without Node.js optimizations.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
       * The base implementation of `_.iteratee`.
       *
       * @private
       * @param {*} [value=_.identity] The value to convert to an iteratee.
       * @returns {Function} Returns the iteratee.
       */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  if(typeof value=='function'){return value;}if(value==null){return identity;}if(_typeof$1(value)=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
       * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
       * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
       * The base implementation of `_.lt` which doesn't coerce arguments.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than `other`,
       *  else `false`.
       */function baseLt(value,other){return value<other;}/**
       * The base implementation of `_.map` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} iteratee The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
       * The base implementation of `_.matches` which doesn't clone `source`.
       *
       * @private
       * @param {Object} source The object of property values to match.
       * @returns {Function} Returns the new spec function.
       */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
       * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
       *
       * @private
       * @param {string} path The path of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined$1&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
       * The base implementation of `_.merge` without support for multiple sources.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {number} srcIndex The index of `source`.
       * @param {Function} [customizer] The function to customize merged values.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else {var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined$1;if(newValue===undefined$1){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
       * A specialized version of `baseMerge` for arrays and objects which performs
       * deep merges and tracks traversed objects enabling objects with circular
       * references to be merged.
       *
       * @private
       * @param {Object} object The destination object.
       * @param {Object} source The source object.
       * @param {string} key The key of the value to merge.
       * @param {number} srcIndex The index of `source`.
       * @param {Function} mergeFunc The function to merge values.
       * @param {Function} [customizer] The function to customize assigned values.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined$1;var isCommon=newValue===undefined$1;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else {newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else {isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
  stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
       * The base implementation of `_.nth` which doesn't coerce arguments.
       *
       * @private
       * @param {Array} array The array to query.
       * @param {number} n The index of the element to return.
       * @returns {*} Returns the nth element of `array`.
       */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined$1;}/**
       * The base implementation of `_.orderBy` without param guards.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
       * @param {string[]} orders The sort orders of `iteratees`.
       * @returns {Array} Returns the new sorted array.
       */function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=arrayMap(iteratees,function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else {iteratees=[identity];}var index=-1;iteratees=arrayMap(iteratees,baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return {'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
       * The base implementation of `_.pick` without support for individual
       * property identifiers.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} paths The property paths to pick.
       * @returns {Object} Returns the new object.
       */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
       * The base implementation of  `_.pickBy` without support for iteratee shorthands.
       *
       * @private
       * @param {Object} object The source object.
       * @param {string[]} paths The property paths to pick.
       * @param {Function} predicate The function invoked per property.
       * @returns {Object} Returns the new object.
       */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
       * A specialized version of `baseProperty` which supports deep paths.
       *
       * @private
       * @param {Array|string} path The path of the property to get.
       * @returns {Function} Returns the new accessor function.
       */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
       * The base implementation of `_.pullAllBy` without support for iteratee
       * shorthands.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns `array`.
       */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
       * The base implementation of `_.pullAt` without support for individual
       * indexes or capturing the removed elements.
       *
       * @private
       * @param {Array} array The array to modify.
       * @param {number[]} indexes The indexes of elements to remove.
       * @returns {Array} Returns `array`.
       */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else {baseUnset(array,index);}}}return array;}/**
       * The base implementation of `_.random` without support for returning
       * floating-point numbers.
       *
       * @private
       * @param {number} lower The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the random number.
       */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
       * The base implementation of `_.range` and `_.rangeRight` which doesn't
       * coerce arguments.
       *
       * @private
       * @param {number} start The start of the range.
       * @param {number} end The end of the range.
       * @param {number} step The value to increment or decrement by.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Array} Returns the range of numbers.
       */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
       * The base implementation of `_.repeat` which doesn't coerce arguments.
       *
       * @private
       * @param {string} string The string to repeat.
       * @param {number} n The number of times to repeat the string.
       * @returns {string} Returns the repeated string.
       */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
       * The base implementation of `_.rest` which doesn't validate or coerce arguments.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
       * The base implementation of `_.sample`.
       *
       * @private
       * @param {Array|Object} collection The collection to sample.
       * @returns {*} Returns the random element.
       */function baseSample(collection){return arraySample(values(collection));}/**
       * The base implementation of `_.sampleSize` without param guards.
       *
       * @private
       * @param {Array|Object} collection The collection to sample.
       * @param {number} n The number of elements to sample.
       * @returns {Array} Returns the random elements.
       */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
       * The base implementation of `_.set`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @param {Function} [customizer] The function to customize path creation.
       * @returns {Object} Returns `object`.
       */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined$1;if(newValue===undefined$1){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
       * The base implementation of `setData` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to associate metadata with.
       * @param {*} data The metadata.
       * @returns {Function} Returns `func`.
       */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
       * The base implementation of `setToString` without support for hot loop shorting.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
       * The base implementation of `_.shuffle`.
       *
       * @private
       * @param {Array|Object} collection The collection to shuffle.
       * @returns {Array} Returns the new shuffled array.
       */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
       * The base implementation of `_.slice` without an iteratee call guard.
       *
       * @private
       * @param {Array} array The array to slice.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the slice of `array`.
       */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
       * The base implementation of `_.some` without support for iteratee shorthands.
       *
       * @private
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} predicate The function invoked per iteration.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return !result;});return !!result;}/**
       * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
       * performs a binary search of `array` to determine the index at which `value`
       * should be inserted into `array` in order to maintain its sort order.
       *
       * @private
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {boolean} [retHighest] Specify returning the highest qualified index.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else {high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
       * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
       * which invokes `iteratee` for `value` and each element of `array` to compute
       * their sort ranking. The iteratee is invoked with one argument; (value).
       *
       * @private
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} iteratee The iteratee invoked per element.
       * @param {boolean} [retHighest] Specify returning the highest qualified index.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       */function baseSortedIndexBy(array,value,iteratee,retHighest){var low=0,high=array==null?0:array.length;if(high===0){return 0;}value=iteratee(value);var valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined$1;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined$1,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else {setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else {high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
       * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
       * support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
       * The base implementation of `_.toNumber` which doesn't ensure correct
       * conversions of binary, hexadecimal, or octal string values.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return +value;}/**
       * The base implementation of `_.toString` which doesn't convert nullish
       * values to empty strings.
       *
       * @private
       * @param {*} value The value to process.
       * @returns {string} Returns the string.
       */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
  if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
  return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
       * The base implementation of `_.uniqBy` without support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else {seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
       * The base implementation of `_.unset`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The property path to unset.
       * @returns {boolean} Returns `true` if the property is deleted, else `false`.
       */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
       * The base implementation of `_.update`.
       *
       * @private
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to update.
       * @param {Function} updater The function to produce the updated value.
       * @param {Function} [customizer] The function to customize path creation.
       * @returns {Object} Returns `object`.
       */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
       * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
       * without support for iteratee shorthands.
       *
       * @private
       * @param {Array} array The array to query.
       * @param {Function} predicate The function invoked per iteration.
       * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Array} Returns the slice of `array`.
       */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
       * The base implementation of `wrapperValue` which returns the result of
       * performing a sequence of actions on the unwrapped `value`, where each
       * successive action is supplied the return value of the previous.
       *
       * @private
       * @param {*} value The unwrapped value.
       * @param {Array} actions Actions to perform to resolve the unwrapped value.
       * @returns {*} Returns the resolved value.
       */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
       * The base implementation of methods like `_.xor`, without support for
       * iteratee shorthands, that accepts an array of arrays to inspect.
       *
       * @private
       * @param {Array} arrays The arrays to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of values.
       */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
       * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
       *
       * @private
       * @param {Array} props The property identifiers.
       * @param {Array} values The property values.
       * @param {Function} assignFunc The function to assign values.
       * @returns {Object} Returns the new object.
       */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined$1;assignFunc(result,props[index],value);}return result;}/**
       * Casts `value` to an empty array if it's not an array like object.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {Array|Object} Returns the cast array-like object.
       */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
       * Casts `value` to `identity` if it's not a function.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {Function} Returns cast function.
       */function castFunction(value){return typeof value=='function'?value:identity;}/**
       * Casts `value` to a path array if it's not one.
       *
       * @private
       * @param {*} value The value to inspect.
       * @param {Object} [object] The object to query keys on.
       * @returns {Array} Returns the cast property path array.
       */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
       * A `baseRest` alias which can be replaced with `identity` by module
       * replacement plugins.
       *
       * @private
       * @type {Function}
       * @param {Function} func The function to apply a rest parameter to.
       * @returns {Function} Returns the new function.
       */var castRest=baseRest;/**
       * Casts `array` to a slice if it's needed.
       *
       * @private
       * @param {Array} array The array to inspect.
       * @param {number} start The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the cast slice.
       */function castSlice(array,start,end){var length=array.length;end=end===undefined$1?length:end;return !start&&end>=length?array:baseSlice(array,start,end);}/**
       * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
       *
       * @private
       * @param {number|Object} id The timer id or timeout object of the timer to clear.
       */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
       * Creates a clone of  `buffer`.
       *
       * @private
       * @param {Buffer} buffer The buffer to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Buffer} Returns the cloned buffer.
       */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
       * Creates a clone of `arrayBuffer`.
       *
       * @private
       * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
       * @returns {ArrayBuffer} Returns the cloned array buffer.
       */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
       * Creates a clone of `dataView`.
       *
       * @private
       * @param {Object} dataView The data view to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned data view.
       */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
       * Creates a clone of `regexp`.
       *
       * @private
       * @param {Object} regexp The regexp to clone.
       * @returns {Object} Returns the cloned regexp.
       */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
       * Creates a clone of the `symbol` object.
       *
       * @private
       * @param {Object} symbol The symbol object to clone.
       * @returns {Object} Returns the cloned symbol object.
       */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
       * Creates a clone of `typedArray`.
       *
       * @private
       * @param {Object} typedArray The typed array to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the cloned typed array.
       */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
       * Compares values to sort them in ascending order.
       *
       * @private
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {number} Returns the sort order indicator for `value`.
       */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined$1,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined$1,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return -1;}}return 0;}/**
       * Used by `_.orderBy` to compare multiple properties of a value to another
       * and stable sort them.
       *
       * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
       * specify an order of "desc" for descending or "asc" for ascending sort order
       * of corresponding values.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {boolean[]|string[]} orders The order to sort by for each property.
       * @returns {number} Returns the sort order indicator for `object`.
       */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  // that causes it, under certain circumstances, to provide the same value for
  // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  // for more details.
  //
  // This also ensures a stable sort in V8 and other engines.
  // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  return object.index-other.index;}/**
       * Creates an array that is the composition of partially applied arguments,
       * placeholders, and provided arguments into a single array of arguments.
       *
       * @private
       * @param {Array} args The provided arguments.
       * @param {Array} partials The arguments to prepend to those provided.
       * @param {Array} holders The `partials` placeholder indexes.
       * @params {boolean} [isCurried] Specify composing for a curried function.
       * @returns {Array} Returns the new array of composed arguments.
       */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
       * This function is like `composeArgs` except that the arguments composition
       * is tailored for `_.partialRight`.
       *
       * @private
       * @param {Array} args The provided arguments.
       * @param {Array} partials The arguments to append to those provided.
       * @param {Array} holders The `partials` placeholder indexes.
       * @params {boolean} [isCurried] Specify composing for a curried function.
       * @returns {Array} Returns the new array of composed arguments.
       */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
       * Copies the values of `source` to `array`.
       *
       * @private
       * @param {Array} source The array to copy values from.
       * @param {Array} [array=[]] The array to copy values to.
       * @returns {Array} Returns `array`.
       */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
       * Copies properties of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy properties from.
       * @param {Array} props The property identifiers to copy.
       * @param {Object} [object={}] The object to copy properties to.
       * @param {Function} [customizer] The function to customize copied values.
       * @returns {Object} Returns `object`.
       */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined$1;if(newValue===undefined$1){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else {assignValue(object,key,newValue);}}return object;}/**
       * Copies own symbols of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy symbols from.
       * @param {Object} [object={}] The object to copy symbols to.
       * @returns {Object} Returns `object`.
       */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
       * Copies own and inherited symbols of `source` to `object`.
       *
       * @private
       * @param {Object} source The object to copy symbols from.
       * @param {Object} [object={}] The object to copy symbols to.
       * @returns {Object} Returns `object`.
       */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
       * Creates a function like `_.groupBy`.
       *
       * @private
       * @param {Function} setter The function to set accumulator values.
       * @param {Function} [initializer] The accumulator object initializer.
       * @returns {Function} Returns the new aggregator function.
       */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
       * Creates a function like `_.assign`.
       *
       * @private
       * @param {Function} assigner The function to assign values.
       * @returns {Function} Returns the new assigner function.
       */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined$1,guard=length>2?sources[2]:undefined$1;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined$1;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined$1:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
       * Creates a `baseEach` or `baseEachRight` function.
       *
       * @private
       * @param {Function} eachFunc The function to iterate over a collection.
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new base function.
       */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
       * Creates a base function for methods like `_.forIn` and `_.forOwn`.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new base function.
       */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
       * Creates a function that wraps `func` to invoke it with the optional `this`
       * binding of `thisArg`.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
       * Creates a function like `_.lowerFirst`.
       *
       * @private
       * @param {string} methodName The name of the `String` case method to use.
       * @returns {Function} Returns the new case function.
       */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined$1;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
       * Creates a function like `_.camelCase`.
       *
       * @private
       * @param {Function} callback The function to combine each word.
       * @returns {Function} Returns the new compounder function.
       */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
       * Creates a function that produces an instance of `Ctor` regardless of
       * whether it was invoked as part of a `new` expression or by `call` or `apply`.
       *
       * @private
       * @param {Function} Ctor The constructor to wrap.
       * @returns {Function} Returns the new wrapped function.
       */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
  // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
  // for more details.
  var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
  // See https://es5.github.io/#x13.2.2 for more details.
  return isObject(result)?result:thisBinding;};}/**
       * Creates a function that wraps `func` to enable currying.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {number} arity The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined$1,args,holders,undefined$1,undefined$1,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
       * Creates a `_.find` or `_.findLast` function.
       *
       * @private
       * @param {Function} findIndexFunc The function to find the collection index.
       * @returns {Function} Returns the new find function.
       */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function predicate(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined$1;};}/**
       * Creates a `_.flow` or `_.flowRight` function.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new flow function.
       */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined$1;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else {wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
       * Creates a function that wraps `func` to invoke it with optional `this`
       * binding of `thisArg`, partial application, and currying.
       *
       * @private
       * @param {Function|string} func The function or method name to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to prepend to those provided to
       *  the new function.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [partialsRight] The arguments to append to those provided
       *  to the new function.
       * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined$1:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
       * Creates a function like `_.invertBy`.
       *
       * @private
       * @param {Function} setter The function to set accumulator values.
       * @param {Function} toIteratee The function to resolve iteratees.
       * @returns {Function} Returns the new inverter function.
       */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
       * Creates a function that performs a mathematical operation on two values.
       *
       * @private
       * @param {Function} operator The function to perform the operation.
       * @param {number} [defaultValue] The value used for `undefined` arguments.
       * @returns {Function} Returns the new mathematical operation function.
       */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined$1&&other===undefined$1){return defaultValue;}if(value!==undefined$1){result=value;}if(other!==undefined$1){if(result===undefined$1){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else {value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
       * Creates a function like `_.over`.
       *
       * @private
       * @param {Function} arrayFunc The function to iterate over iteratees.
       * @returns {Function} Returns the new over function.
       */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
       * Creates the padding for `string` based on `length`. The `chars` string
       * is truncated if the number of characters exceeds `length`.
       *
       * @private
       * @param {number} length The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padding for `string`.
       */function createPadding(length,chars){chars=chars===undefined$1?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
       * Creates a function that wraps `func` to invoke it with the `this` binding
       * of `thisArg` and `partials` prepended to the arguments it receives.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {Array} partials The arguments to prepend to those provided to
       *  the new function.
       * @returns {Function} Returns the new wrapped function.
       */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
       * Creates a `_.range` or `_.rangeRight` function.
       *
       * @private
       * @param {boolean} [fromRight] Specify iterating from right to left.
       * @returns {Function} Returns the new range function.
       */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined$1;}// Ensure the sign of `-0` is preserved.
  start=toFinite(start);if(end===undefined$1){end=start;start=0;}else {end=toFinite(end);}step=step===undefined$1?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
       * Creates a function that performs a relational operation on two values.
       *
       * @private
       * @param {Function} operator The function to perform the operation.
       * @returns {Function} Returns the new relational operation function.
       */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
       * Creates a function that wraps `func` to continue currying.
       *
       * @private
       * @param {Function} func The function to wrap.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @param {Function} wrapFunc The function to create the `func` wrapper.
       * @param {*} placeholder The placeholder value.
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to prepend to those provided to
       *  the new function.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined$1,newHoldersRight=isCurry?undefined$1:holders,newPartials=isCurry?partials:undefined$1,newPartialsRight=isCurry?undefined$1:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined$1,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
       * Creates a function like `_.round`.
       *
       * @private
       * @param {string} methodName The name of the `Math` method to use when rounding.
       * @returns {Function} Returns the new round function.
       */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
  // See [MDN](https://mdn.io/round#Examples) for more details.
  var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return +(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
       * Creates a set object of `values`.
       *
       * @private
       * @param {Array} values The values to add to the set.
       * @returns {Object} Returns the new set.
       */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
       * Creates a `_.toPairs` or `_.toPairsIn` function.
       *
       * @private
       * @param {Function} keysFunc The function to get the keys of a given object.
       * @returns {Function} Returns the new pairs function.
       */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
       * Creates a function that either curries or invokes `func` with optional
       * `this` binding and partially applied arguments.
       *
       * @private
       * @param {Function|string} func The function or method name to wrap.
       * @param {number} bitmask The bitmask flags.
       *    1 - `_.bind`
       *    2 - `_.bindKey`
       *    4 - `_.curry` or `_.curryRight` of a bound function
       *    8 - `_.curry`
       *   16 - `_.curryRight`
       *   32 - `_.partial`
       *   64 - `_.partialRight`
       *  128 - `_.rearg`
       *  256 - `_.ary`
       *  512 - `_.flip`
       * @param {*} [thisArg] The `this` binding of `func`.
       * @param {Array} [partials] The arguments to be partially applied.
       * @param {Array} [holders] The `partials` placeholder indexes.
       * @param {Array} [argPos] The argument positions of the new function.
       * @param {number} [ary] The arity cap of `func`.
       * @param {number} [arity] The arity of `func`.
       * @returns {Function} Returns the new wrapped function.
       */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined$1;}ary=ary===undefined$1?ary:nativeMax(toInteger(ary),0);arity=arity===undefined$1?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined$1;}var data=isBindKey?undefined$1:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined$1?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else {result=createHybrid.apply(undefined$1,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
       * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
       * of source objects to the destination object for all destination properties
       * that resolve to `undefined`.
       *
       * @private
       * @param {*} objValue The destination value.
       * @param {*} srcValue The source value.
       * @param {string} key The key of the property to assign.
       * @param {Object} object The parent object of `objValue`.
       * @returns {*} Returns the value to assign.
       */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined$1||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
       * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
       * objects into destination objects that are passed thru.
       *
       * @private
       * @param {*} objValue The destination value.
       * @param {*} srcValue The source value.
       * @param {string} key The key of the property to merge.
       * @param {Object} object The parent object of `objValue`.
       * @param {Object} source The parent object of `srcValue`.
       * @param {Object} [stack] Tracks traversed source values and their merged
       *  counterparts.
       * @returns {*} Returns the value to assign.
       */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
  stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined$1,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
       * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
       * objects.
       *
       * @private
       * @param {*} value The value to inspect.
       * @param {string} key The key of the property to inspect.
       * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
       */function customOmitClone(value){return isPlainObject(value)?undefined$1:value;}/**
       * A specialized version of `baseIsEqualDeep` for arrays with support for
       * partial deep comparisons.
       *
       * @private
       * @param {Array} array The array to compare.
       * @param {Array} other The other array to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `array` and `other` objects.
       * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
       */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Check that cyclic values are equal.
  var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined$1;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
  while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined$1){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
  if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
       * A specialized version of `baseIsEqualDeep` for comparing objects of
       * the same `toStringTag`.
       *
       * **Note:** This function only supports comparing values with tags of
       * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {string} tag The `toStringTag` of the objects to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
  // Invalid dates are coerced to `NaN`.
  return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
  // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
  // for more details.
  return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
  var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
  stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
       * A specialized version of `baseIsEqualDeep` for objects with support for
       * partial deep comparisons.
       *
       * @private
       * @param {Object} object The object to compare.
       * @param {Object} other The other object to compare.
       * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
       * @param {Function} customizer The function to customize comparisons.
       * @param {Function} equalFunc The function to determine equivalents of values.
       * @param {Object} stack Tracks traversed `object` and `other` objects.
       * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
       */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Check that cyclic values are equal.
  var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
  if(!(compared===undefined$1?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
  if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
       * A specialized version of `baseRest` which flattens the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @returns {Function} Returns the new function.
       */function flatRest(func){return setToString(overRest(func,undefined$1,flatten),func+'');}/**
       * Creates an array of own enumerable property names and symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names and symbols.
       */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
       * Creates an array of own and inherited enumerable property names and
       * symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names and symbols.
       */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
       * Gets metadata for `func`.
       *
       * @private
       * @param {Function} func The function to query.
       * @returns {*} Returns the metadata for `func`.
       */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
       * Gets the name of `func`.
       *
       * @private
       * @param {Function} func The function to query.
       * @returns {string} Returns the function name.
       */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
       * Gets the argument placeholder value for `func`.
       *
       * @private
       * @param {Function} func The function to inspect.
       * @returns {*} Returns the placeholder value.
       */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
       * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
       * this function returns the custom method, otherwise it returns `baseIteratee`.
       * If arguments are provided, the chosen function is invoked with them and
       * its result is returned.
       *
       * @private
       * @param {*} [value] The value to convert to an iteratee.
       * @param {number} [arity] The arity of the created iteratee.
       * @returns {Function} Returns the chosen function or its result.
       */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
       * Gets the data for `map`.
       *
       * @private
       * @param {Object} map The map to query.
       * @param {string} key The reference key.
       * @returns {*} Returns the map data.
       */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
       * Gets the property names, values, and compare flags of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the match data of `object`.
       */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
       * Gets the native function at `key` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the method to get.
       * @returns {*} Returns the function if it's native, else `undefined`.
       */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined$1;}/**
       * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the raw `toStringTag`.
       */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined$1;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else {delete value[symToStringTag];}}return result;}/**
       * Creates an array of the own enumerable symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of symbols.
       */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return [];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
       * Creates an array of the own and inherited enumerable symbols of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of symbols.
       */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
       * Gets the `toStringTag` of `value`.
       *
       * @private
       * @param {*} value The value to query.
       * @returns {string} Returns the `toStringTag`.
       */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function getTag(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined$1,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
       * Gets the view, applying any `transforms` to the `start` and `end` positions.
       *
       * @private
       * @param {number} start The start of the view.
       * @param {number} end The end of the view.
       * @param {Array} transforms The transformations to apply to the view.
       * @returns {Object} Returns an object containing the `start` and `end`
       *  positions of the view.
       */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return {'start':start,'end':end};}/**
       * Extracts wrapper details from the `source` body comment.
       *
       * @private
       * @param {string} source The source to inspect.
       * @returns {Array} Returns the wrapper details.
       */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
       * Checks if `path` exists on `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @param {Function} hasFunc The function to check properties.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return !!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
       * Initializes an array clone.
       *
       * @private
       * @param {Array} array The array to clone.
       * @returns {Array} Returns the initialized clone.
       */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
  if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
       * Initializes an object clone.
       *
       * @private
       * @param {Object} object The object to clone.
       * @returns {Object} Returns the initialized clone.
       */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
       * Initializes an object clone based on its `toStringTag`.
       *
       * **Note:** This function only supports cloning values with tags of
       * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
       *
       * @private
       * @param {Object} object The object to clone.
       * @param {string} tag The `toStringTag` of the object to clone.
       * @param {boolean} [isDeep] Specify a deep clone.
       * @returns {Object} Returns the initialized clone.
       */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
       * Inserts wrapper `details` in a comment at the top of the `source` body.
       *
       * @private
       * @param {string} source The source to modify.
       * @returns {Array} details The details to insert.
       * @returns {string} Returns the modified source.
       */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
       * Checks if `value` is a flattenable `arguments` object or array.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
       */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
       * Checks if `value` is a valid array-like index.
       *
       * @private
       * @param {*} value The value to check.
       * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
       * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
       */function isIndex(value,length){var type=_typeof$1(value);length=length==null?MAX_SAFE_INTEGER:length;return !!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
       * Checks if the given arguments are from an iteratee call.
       *
       * @private
       * @param {*} value The potential iteratee value argument.
       * @param {*} index The potential iteratee index or key argument.
       * @param {*} object The potential iteratee object argument.
       * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
       *  else `false`.
       */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=_typeof$1(index);if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
       * Checks if `value` is a property name and not a property path.
       *
       * @private
       * @param {*} value The value to check.
       * @param {Object} [object] The object to query keys on.
       * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
       */function isKey(value,object){if(isArray(value)){return false;}var type=_typeof$1(value);if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
       * Checks if `value` is suitable for use as unique object key.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
       */function isKeyable(value){var type=_typeof$1(value);return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
       * Checks if `func` has a lazy counterpart.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
       *  else `false`.
       */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return !!data&&func===data[0];}/**
       * Checks if `func` has its source masked.
       *
       * @private
       * @param {Function} func The function to check.
       * @returns {boolean} Returns `true` if `func` is masked, else `false`.
       */function isMasked(func){return !!maskSrcKey&&maskSrcKey in func;}/**
       * Checks if `func` is capable of being masked.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
       */var isMaskable=coreJsData?isFunction:stubFalse;/**
       * Checks if `value` is likely a prototype object.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
       */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
       * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
       *
       * @private
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` if suitable for strict
       *  equality comparisons, else `false`.
       */function isStrictComparable(value){return value===value&&!isObject(value);}/**
       * A specialized version of `matchesProperty` for source values suitable
       * for strict equality comparisons, i.e. `===`.
       *
       * @private
       * @param {string} key The key of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined$1||key in Object(object));};}/**
       * A specialized version of `_.memoize` which clears the memoized function's
       * cache when it exceeds `MAX_MEMOIZE_SIZE`.
       *
       * @private
       * @param {Function} func The function to have its output memoized.
       * @returns {Function} Returns the new memoized function.
       */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
       * Merges the function metadata of `source` into `data`.
       *
       * Merging metadata reduces the number of wrappers used to invoke a function.
       * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
       * may be applied regardless of execution order. Methods like `_.ary` and
       * `_.rearg` modify function arguments, making the order in which they are
       * executed important, preventing the merging of metadata. However, we make
       * an exception for a safe combined case where curried functions have `_.ary`
       * and or `_.rearg` applied.
       *
       * @private
       * @param {Array} data The destination metadata.
       * @param {Array} source The source metadata.
       * @returns {Array} Returns `data`.
       */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
  if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
  if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
  newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
  var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
  value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
  value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
  if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
  if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
  data[0]=source[0];data[1]=newBitmask;return data;}/**
       * This function is like
       * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * except that it includes inherited enumerable properties.
       *
       * @private
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
       * Converts `value` to a string using `Object.prototype.toString`.
       *
       * @private
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       */function objectToString(value){return nativeObjectToString.call(value);}/**
       * A specialized version of `baseRest` which transforms the rest array.
       *
       * @private
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @param {Function} transform The rest array transform.
       * @returns {Function} Returns the new function.
       */function overRest(func,start,transform){start=nativeMax(start===undefined$1?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
       * Gets the parent value at `path` of `object`.
       *
       * @private
       * @param {Object} object The object to query.
       * @param {Array} path The path to get the parent value of.
       * @returns {*} Returns the parent value.
       */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
       * Reorder `array` according to the specified indexes where the element at
       * the first index is assigned as the first element, the element at
       * the second index is assigned as the second element, and so on.
       *
       * @private
       * @param {Array} array The array to reorder.
       * @param {Array} indexes The arranged array indexes.
       * @returns {Array} Returns `array`.
       */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined$1;}return array;}/**
       * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
       *
       * @private
       * @param {Object} object The object to query.
       * @param {string} key The key of the property to get.
       * @returns {*} Returns the property value.
       */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
       * Sets metadata for `func`.
       *
       * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
       * period of time, it will trip its breaker and transition to an identity
       * function to avoid garbage collection pauses in V8. See
       * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
       * for more details.
       *
       * @private
       * @param {Function} func The function to associate metadata with.
       * @param {*} data The metadata.
       * @returns {Function} Returns `func`.
       */var setData=shortOut(baseSetData);/**
       * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
       *
       * @private
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @returns {number|Object} Returns the timer id or timeout object.
       */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
       * Sets the `toString` method of `func` to return `string`.
       *
       * @private
       * @param {Function} func The function to modify.
       * @param {Function} string The `toString` result.
       * @returns {Function} Returns `func`.
       */var setToString=shortOut(baseSetToString);/**
       * Sets the `toString` method of `wrapper` to mimic the source of `reference`
       * with wrapper details in a comment at the top of the source body.
       *
       * @private
       * @param {Function} wrapper The function to modify.
       * @param {Function} reference The reference function.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @returns {Function} Returns `wrapper`.
       */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
       * Creates a function that'll short out and invoke `identity` instead
       * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
       * milliseconds.
       *
       * @private
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new shortable function.
       */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else {count=0;}return func.apply(undefined$1,arguments);};}/**
       * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
       *
       * @private
       * @param {Array} array The array to shuffle.
       * @param {number} [size=array.length] The size of `array`.
       * @returns {Array} Returns `array`.
       */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined$1?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
       * Converts `string` to a property path array.
       *
       * @private
       * @param {string} string The string to convert.
       * @returns {Array} Returns the property path array.
       */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
       * Converts `value` to a string key if it's not a string or symbol.
       *
       * @private
       * @param {*} value The value to inspect.
       * @returns {string|symbol} Returns the key.
       */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
       * Converts `func` to its source code.
       *
       * @private
       * @param {Function} func The function to convert.
       * @returns {string} Returns the source code.
       */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return '';}/**
       * Updates wrapper `details` based on `bitmask` flags.
       *
       * @private
       * @returns {Array} details The details to modify.
       * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
       * @returns {Array} Returns `details`.
       */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
       * Creates a clone of `wrapper`.
       *
       * @private
       * @param {Object} wrapper The wrapper to clone.
       * @returns {Object} Returns the cloned wrapper.
       */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
       * Creates an array of elements split into groups the length of `size`.
       * If `array` can't be split evenly, the final chunk will be the remaining
       * elements.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to process.
       * @param {number} [size=1] The length of each chunk
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the new array of chunks.
       * @example
       *
       * _.chunk(['a', 'b', 'c', 'd'], 2);
       * // => [['a', 'b'], ['c', 'd']]
       *
       * _.chunk(['a', 'b', 'c', 'd'], 3);
       * // => [['a', 'b', 'c'], ['d']]
       */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined$1){size=1;}else {size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return [];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
       * Creates an array with all falsey values removed. The values `false`, `null`,
       * `0`, `""`, `undefined`, and `NaN` are falsey.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to compact.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.compact([0, 1, false, 2, '', 3]);
       * // => [1, 2, 3]
       */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
       * Creates a new array concatenating `array` with any additional arrays
       * and/or values.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to concatenate.
       * @param {...*} [values] The values to concatenate.
       * @returns {Array} Returns the new concatenated array.
       * @example
       *
       * var array = [1];
       * var other = _.concat(array, 2, [3], [[4]]);
       *
       * console.log(other);
       * // => [1, 2, 3, [4]]
       *
       * console.log(array);
       * // => [1]
       */function concat(){var length=arguments.length;if(!length){return [];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
       * Creates an array of `array` values not included in the other given arrays
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. The order and references of result values are
       * determined by the first array.
       *
       * **Note:** Unlike `_.pullAll`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.without, _.xor
       * @example
       *
       * _.difference([2, 1], [2, 3]);
       * // => [1]
       */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
       * This method is like `_.difference` except that it accepts `iteratee` which
       * is invoked for each element of `array` and `values` to generate the criterion
       * by which they're compared. The order and references of result values are
       * determined by the first array. The iteratee is invoked with one argument:
       * (value).
       *
       * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
       * // => [{ 'x': 2 }]
       */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
       * This method is like `_.difference` except that it accepts `comparator`
       * which is invoked to compare elements of `array` to `values`. The order and
       * references of result values are determined by the first array. The comparator
       * is invoked with two arguments: (arrVal, othVal).
       *
       * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...Array} [values] The values to exclude.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       *
       * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
       * // => [{ 'x': 2, 'y': 1 }]
       */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined$1;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined$1,comparator):[];});/**
       * Creates a slice of `array` with `n` elements dropped from the beginning.
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to drop.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.drop([1, 2, 3]);
       * // => [2, 3]
       *
       * _.drop([1, 2, 3], 2);
       * // => [3]
       *
       * _.drop([1, 2, 3], 5);
       * // => []
       *
       * _.drop([1, 2, 3], 0);
       * // => [1, 2, 3]
       */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
       * Creates a slice of `array` with `n` elements dropped from the end.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to drop.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.dropRight([1, 2, 3]);
       * // => [1, 2]
       *
       * _.dropRight([1, 2, 3], 2);
       * // => [1]
       *
       * _.dropRight([1, 2, 3], 5);
       * // => []
       *
       * _.dropRight([1, 2, 3], 0);
       * // => [1, 2, 3]
       */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
       * Creates a slice of `array` excluding elements dropped from the end.
       * Elements are dropped until `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.dropRightWhile(users, function(o) { return !o.active; });
       * // => objects for ['barney']
       *
       * // The `_.matches` iteratee shorthand.
       * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
       * // => objects for ['barney', 'fred']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.dropRightWhile(users, ['active', false]);
       * // => objects for ['barney']
       *
       * // The `_.property` iteratee shorthand.
       * _.dropRightWhile(users, 'active');
       * // => objects for ['barney', 'fred', 'pebbles']
       */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
       * Creates a slice of `array` excluding elements dropped from the beginning.
       * Elements are dropped until `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.dropWhile(users, function(o) { return !o.active; });
       * // => objects for ['pebbles']
       *
       * // The `_.matches` iteratee shorthand.
       * _.dropWhile(users, { 'user': 'barney', 'active': false });
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.dropWhile(users, ['active', false]);
       * // => objects for ['pebbles']
       *
       * // The `_.property` iteratee shorthand.
       * _.dropWhile(users, 'active');
       * // => objects for ['barney', 'fred', 'pebbles']
       */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
       * Fills elements of `array` with `value` from `start` up to, but not
       * including, `end`.
       *
       * **Note:** This method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Array
       * @param {Array} array The array to fill.
       * @param {*} value The value to fill `array` with.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _.fill(array, 'a');
       * console.log(array);
       * // => ['a', 'a', 'a']
       *
       * _.fill(Array(3), 2);
       * // => [2, 2, 2]
       *
       * _.fill([4, 6, 8, 10], '*', 1, 3);
       * // => [4, '*', '*', 10]
       */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return [];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
       * This method is like `_.find` except that it returns the index of the first
       * element `predicate` returns truthy for instead of the element itself.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.findIndex(users, function(o) { return o.user == 'barney'; });
       * // => 0
       *
       * // The `_.matches` iteratee shorthand.
       * _.findIndex(users, { 'user': 'fred', 'active': false });
       * // => 1
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findIndex(users, ['active', false]);
       * // => 0
       *
       * // The `_.property` iteratee shorthand.
       * _.findIndex(users, 'active');
       * // => 2
       */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
       * This method is like `_.findIndex` except that it iterates over elements
       * of `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=array.length-1] The index to search from.
       * @returns {number} Returns the index of the found element, else `-1`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
       * // => 2
       *
       * // The `_.matches` iteratee shorthand.
       * _.findLastIndex(users, { 'user': 'barney', 'active': true });
       * // => 0
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findLastIndex(users, ['active', false]);
       * // => 2
       *
       * // The `_.property` iteratee shorthand.
       * _.findLastIndex(users, 'active');
       * // => 0
       */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=length-1;if(fromIndex!==undefined$1){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
       * Flattens `array` a single level deep.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * _.flatten([1, [2, [3, [4]], 5]]);
       * // => [1, 2, [3, [4]], 5]
       */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
       * Recursively flattens `array`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * _.flattenDeep([1, [2, [3, [4]], 5]]);
       * // => [1, 2, 3, 4, 5]
       */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
       * Recursively flatten `array` up to `depth` times.
       *
       * @static
       * @memberOf _
       * @since 4.4.0
       * @category Array
       * @param {Array} array The array to flatten.
       * @param {number} [depth=1] The maximum recursion depth.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * var array = [1, [2, [3, [4]], 5]];
       *
       * _.flattenDepth(array, 1);
       * // => [1, 2, [3, [4]], 5]
       *
       * _.flattenDepth(array, 2);
       * // => [1, 2, 3, [4], 5]
       */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return [];}depth=depth===undefined$1?1:toInteger(depth);return baseFlatten(array,depth);}/**
       * The inverse of `_.toPairs`; this method returns an object composed
       * from key-value `pairs`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} pairs The key-value pairs.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.fromPairs([['a', 1], ['b', 2]]);
       * // => { 'a': 1, 'b': 2 }
       */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
       * Gets the first element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @alias first
       * @category Array
       * @param {Array} array The array to query.
       * @returns {*} Returns the first element of `array`.
       * @example
       *
       * _.head([1, 2, 3]);
       * // => 1
       *
       * _.head([]);
       * // => undefined
       */function head(array){return array&&array.length?array[0]:undefined$1;}/**
       * Gets the index at which the first occurrence of `value` is found in `array`
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. If `fromIndex` is negative, it's used as the
       * offset from the end of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.indexOf([1, 2, 1, 2], 2);
       * // => 1
       *
       * // Search from the `fromIndex`.
       * _.indexOf([1, 2, 1, 2], 2, 2);
       * // => 3
       */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
       * Gets all but the last element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.initial([1, 2, 3]);
       * // => [1, 2]
       */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
       * Creates an array of unique values that are included in all given arrays
       * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons. The order and references of result values are
       * determined by the first array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * _.intersection([2, 1], [2, 3]);
       * // => [2]
       */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
       * This method is like `_.intersection` except that it accepts `iteratee`
       * which is invoked for each element of each `arrays` to generate the criterion
       * by which they're compared. The order and references of result values are
       * determined by the first array. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [2.1]
       *
       * // The `_.property` iteratee shorthand.
       * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }]
       */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined$1;}else {mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
       * This method is like `_.intersection` except that it accepts `comparator`
       * which is invoked to compare elements of `arrays`. The order and references
       * of result values are determined by the first array. The comparator is
       * invoked with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of intersecting values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.intersectionWith(objects, others, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }]
       */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined$1;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined$1,comparator):[];});/**
       * Converts all elements in `array` into a string separated by `separator`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to convert.
       * @param {string} [separator=','] The element separator.
       * @returns {string} Returns the joined string.
       * @example
       *
       * _.join(['a', 'b', 'c'], '~');
       * // => 'a~b~c'
       */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
       * Gets the last element of `array`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {*} Returns the last element of `array`.
       * @example
       *
       * _.last([1, 2, 3]);
       * // => 3
       */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined$1;}/**
       * This method is like `_.indexOf` except that it iterates over elements of
       * `array` from right to left.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=array.length-1] The index to search from.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.lastIndexOf([1, 2, 1, 2], 2);
       * // => 3
       *
       * // Search from the `fromIndex`.
       * _.lastIndexOf([1, 2, 1, 2], 2, 2);
       * // => 1
       */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=length;if(fromIndex!==undefined$1){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
       * Gets the element at index `n` of `array`. If `n` is negative, the nth
       * element from the end is returned.
       *
       * @static
       * @memberOf _
       * @since 4.11.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=0] The index of the element to return.
       * @returns {*} Returns the nth element of `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'd'];
       *
       * _.nth(array, 1);
       * // => 'b'
       *
       * _.nth(array, -2);
       * // => 'c';
       */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined$1;}/**
       * Removes all given values from `array` using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
       * to remove elements from an array by predicate.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {...*} [values] The values to remove.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
       *
       * _.pull(array, 'a', 'c');
       * console.log(array);
       * // => ['b', 'b']
       */var pull=baseRest(pullAll);/**
       * This method is like `_.pull` except that it accepts an array of values to remove.
       *
       * **Note:** Unlike `_.difference`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
       *
       * _.pullAll(array, ['a', 'c']);
       * console.log(array);
       * // => ['b', 'b']
       */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
       * This method is like `_.pullAll` except that it accepts `iteratee` which is
       * invoked for each element of `array` and `values` to generate the criterion
       * by which they're compared. The iteratee is invoked with one argument: (value).
       *
       * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
       *
       * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
       * console.log(array);
       * // => [{ 'x': 2 }]
       */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
       * This method is like `_.pullAll` except that it accepts `comparator` which
       * is invoked to compare elements of `array` to `values`. The comparator is
       * invoked with two arguments: (arrVal, othVal).
       *
       * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Array} values The values to remove.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
       *
       * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
       * console.log(array);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
       */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined$1,comparator):array;}/**
       * Removes elements from `array` corresponding to `indexes` and returns an
       * array of removed elements.
       *
       * **Note:** Unlike `_.at`, this method mutates `array`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {...(number|number[])} [indexes] The indexes of elements to remove.
       * @returns {Array} Returns the new array of removed elements.
       * @example
       *
       * var array = ['a', 'b', 'c', 'd'];
       * var pulled = _.pullAt(array, [1, 3]);
       *
       * console.log(array);
       * // => ['a', 'c']
       *
       * console.log(pulled);
       * // => ['b', 'd']
       */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
       * Removes all elements from `array` that `predicate` returns truthy for
       * and returns an array of the removed elements. The predicate is invoked
       * with three arguments: (value, index, array).
       *
       * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
       * to pull elements from an array by value.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new array of removed elements.
       * @example
       *
       * var array = [1, 2, 3, 4];
       * var evens = _.remove(array, function(n) {
       *   return n % 2 == 0;
       * });
       *
       * console.log(array);
       * // => [1, 3]
       *
       * console.log(evens);
       * // => [2, 4]
       */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
       * Reverses `array` so that the first element becomes the last, the second
       * element becomes the second to last, and so on.
       *
       * **Note:** This method mutates `array` and is based on
       * [`Array#reverse`](https://mdn.io/Array/reverse).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to modify.
       * @returns {Array} Returns `array`.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _.reverse(array);
       * // => [3, 2, 1]
       *
       * console.log(array);
       * // => [3, 2, 1]
       */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
       * Creates a slice of `array` from `start` up to, but not including, `end`.
       *
       * **Note:** This method is used instead of
       * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
       * returned.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to slice.
       * @param {number} [start=0] The start position.
       * @param {number} [end=array.length] The end position.
       * @returns {Array} Returns the slice of `array`.
       */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return [];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else {start=start==null?0:toInteger(start);end=end===undefined$1?length:toInteger(end);}return baseSlice(array,start,end);}/**
       * Uses a binary search to determine the lowest index at which `value`
       * should be inserted into `array` in order to maintain its sort order.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * _.sortedIndex([30, 50], 40);
       * // => 1
       */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
       * This method is like `_.sortedIndex` except that it accepts `iteratee`
       * which is invoked for `value` and each element of `array` to compute their
       * sort ranking. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * var objects = [{ 'x': 4 }, { 'x': 5 }];
       *
       * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
       * // => 0
       *
       * // The `_.property` iteratee shorthand.
       * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
       * // => 0
       */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
       * This method is like `_.indexOf` except that it performs a binary
       * search on a sorted `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
       * // => 1
       */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return -1;}/**
       * This method is like `_.sortedIndex` except that it returns the highest
       * index at which `value` should be inserted into `array` in order to
       * maintain its sort order.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
       * // => 4
       */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
       * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
       * which is invoked for `value` and each element of `array` to compute their
       * sort ranking. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The sorted array to inspect.
       * @param {*} value The value to evaluate.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the index at which `value` should be inserted
       *  into `array`.
       * @example
       *
       * var objects = [{ 'x': 4 }, { 'x': 5 }];
       *
       * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
       * // => 1
       *
       * // The `_.property` iteratee shorthand.
       * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
       * // => 1
       */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
       * This method is like `_.lastIndexOf` except that it performs a binary
       * search on a sorted `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {*} value The value to search for.
       * @returns {number} Returns the index of the matched value, else `-1`.
       * @example
       *
       * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
       * // => 3
       */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return -1;}/**
       * This method is like `_.uniq` except that it's designed and optimized
       * for sorted arrays.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.sortedUniq([1, 1, 2]);
       * // => [1, 2]
       */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
       * This method is like `_.uniqBy` except that it's designed and optimized
       * for sorted arrays.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
       * // => [1.1, 2.3]
       */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
       * Gets all but the first element of `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.tail([1, 2, 3]);
       * // => [2, 3]
       */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
       * Creates a slice of `array` with `n` elements taken from the beginning.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to take.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.take([1, 2, 3]);
       * // => [1]
       *
       * _.take([1, 2, 3], 2);
       * // => [1, 2]
       *
       * _.take([1, 2, 3], 5);
       * // => [1, 2, 3]
       *
       * _.take([1, 2, 3], 0);
       * // => []
       */function take(array,n,guard){if(!(array&&array.length)){return [];}n=guard||n===undefined$1?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
       * Creates a slice of `array` with `n` elements taken from the end.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {number} [n=1] The number of elements to take.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * _.takeRight([1, 2, 3]);
       * // => [3]
       *
       * _.takeRight([1, 2, 3], 2);
       * // => [2, 3]
       *
       * _.takeRight([1, 2, 3], 5);
       * // => [1, 2, 3]
       *
       * _.takeRight([1, 2, 3], 0);
       * // => []
       */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
       * Creates a slice of `array` with elements taken from the end. Elements are
       * taken until `predicate` returns falsey. The predicate is invoked with
       * three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': true },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': false }
       * ];
       *
       * _.takeRightWhile(users, function(o) { return !o.active; });
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.matches` iteratee shorthand.
       * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
       * // => objects for ['pebbles']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.takeRightWhile(users, ['active', false]);
       * // => objects for ['fred', 'pebbles']
       *
       * // The `_.property` iteratee shorthand.
       * _.takeRightWhile(users, 'active');
       * // => []
       */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
       * Creates a slice of `array` with elements taken from the beginning. Elements
       * are taken until `predicate` returns falsey. The predicate is invoked with
       * three arguments: (value, index, array).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Array
       * @param {Array} array The array to query.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the slice of `array`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'active': false },
       *   { 'user': 'fred',    'active': false },
       *   { 'user': 'pebbles', 'active': true }
       * ];
       *
       * _.takeWhile(users, function(o) { return !o.active; });
       * // => objects for ['barney', 'fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.takeWhile(users, { 'user': 'barney', 'active': false });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.takeWhile(users, ['active', false]);
       * // => objects for ['barney', 'fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.takeWhile(users, 'active');
       * // => []
       */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
       * Creates an array of unique values, in order, from all given arrays using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * _.union([2], [1, 2]);
       * // => [2, 1]
       */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
       * This method is like `_.union` except that it accepts `iteratee` which is
       * invoked for each element of each `arrays` to generate the criterion by
       * which uniqueness is computed. Result values are chosen from the first
       * array in which the value occurs. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * _.unionBy([2.1], [1.2, 2.3], Math.floor);
       * // => [2.1, 1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }, { 'x': 2 }]
       */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
       * This method is like `_.union` except that it accepts `comparator` which
       * is invoked to compare elements of `arrays`. Result values are chosen from
       * the first array in which the value occurs. The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of combined values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.unionWith(objects, others, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
       */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined$1;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined$1,comparator);});/**
       * Creates a duplicate-free version of an array, using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons, in which only the first occurrence of each element
       * is kept. The order of result values is determined by the order they occur
       * in the array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.uniq([2, 1, 2]);
       * // => [2, 1]
       */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
       * This method is like `_.uniq` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * uniqueness is computed. The order of result values is determined by the
       * order they occur in the array. The iteratee is invoked with one argument:
       * (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
       * // => [2.1, 1.2]
       *
       * // The `_.property` iteratee shorthand.
       * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 1 }, { 'x': 2 }]
       */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
       * This method is like `_.uniq` except that it accepts `comparator` which
       * is invoked to compare elements of `array`. The order of result values is
       * determined by the order they occur in the array.The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new duplicate free array.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.uniqWith(objects, _.isEqual);
       * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
       */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined$1;return array&&array.length?baseUniq(array,undefined$1,comparator):[];}/**
       * This method is like `_.zip` except that it accepts an array of grouped
       * elements and creates an array regrouping the elements to their pre-zip
       * configuration.
       *
       * @static
       * @memberOf _
       * @since 1.2.0
       * @category Array
       * @param {Array} array The array of grouped elements to process.
       * @returns {Array} Returns the new array of regrouped elements.
       * @example
       *
       * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
       * // => [['a', 1, true], ['b', 2, false]]
       *
       * _.unzip(zipped);
       * // => [['a', 'b'], [1, 2], [true, false]]
       */function unzip(array){if(!(array&&array.length)){return [];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
       * This method is like `_.unzip` except that it accepts `iteratee` to specify
       * how regrouped values should be combined. The iteratee is invoked with the
       * elements of each group: (...group).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Array
       * @param {Array} array The array of grouped elements to process.
       * @param {Function} [iteratee=_.identity] The function to combine
       *  regrouped values.
       * @returns {Array} Returns the new array of regrouped elements.
       * @example
       *
       * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
       * // => [[1, 10, 100], [2, 20, 200]]
       *
       * _.unzipWith(zipped, _.add);
       * // => [3, 30, 300]
       */function unzipWith(array,iteratee){if(!(array&&array.length)){return [];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined$1,group);});}/**
       * Creates an array excluding all given values using
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * for equality comparisons.
       *
       * **Note:** Unlike `_.pull`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {Array} array The array to inspect.
       * @param {...*} [values] The values to exclude.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.difference, _.xor
       * @example
       *
       * _.without([2, 1, 2, 3], 1, 2);
       * // => [3]
       */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
       * Creates an array of unique values that is the
       * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
       * of the given arrays. The order of result values is determined by the order
       * they occur in the arrays.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @returns {Array} Returns the new array of filtered values.
       * @see _.difference, _.without
       * @example
       *
       * _.xor([2, 1], [2, 3]);
       * // => [1, 3]
       */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
       * This method is like `_.xor` except that it accepts `iteratee` which is
       * invoked for each element of each `arrays` to generate the criterion by
       * which by which they're compared. The order of result values is determined
       * by the order they occur in the arrays. The iteratee is invoked with one
       * argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
       * // => [1.2, 3.4]
       *
       * // The `_.property` iteratee shorthand.
       * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
       * // => [{ 'x': 2 }]
       */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
       * This method is like `_.xor` except that it accepts `comparator` which is
       * invoked to compare elements of `arrays`. The order of result values is
       * determined by the order they occur in the arrays. The comparator is invoked
       * with two arguments: (arrVal, othVal).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Array
       * @param {...Array} [arrays] The arrays to inspect.
       * @param {Function} [comparator] The comparator invoked per element.
       * @returns {Array} Returns the new array of filtered values.
       * @example
       *
       * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
       * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
       *
       * _.xorWith(objects, others, _.isEqual);
       * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
       */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined$1;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined$1,comparator);});/**
       * Creates an array of grouped elements, the first of which contains the
       * first elements of the given arrays, the second of which contains the
       * second elements of the given arrays, and so on.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Array
       * @param {...Array} [arrays] The arrays to process.
       * @returns {Array} Returns the new array of grouped elements.
       * @example
       *
       * _.zip(['a', 'b'], [1, 2], [true, false]);
       * // => [['a', 1, true], ['b', 2, false]]
       */var zip=baseRest(unzip);/**
       * This method is like `_.fromPairs` except that it accepts two arrays,
       * one of property identifiers and one of corresponding values.
       *
       * @static
       * @memberOf _
       * @since 0.4.0
       * @category Array
       * @param {Array} [props=[]] The property identifiers.
       * @param {Array} [values=[]] The property values.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.zipObject(['a', 'b'], [1, 2]);
       * // => { 'a': 1, 'b': 2 }
       */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
       * This method is like `_.zipObject` except that it supports property paths.
       *
       * @static
       * @memberOf _
       * @since 4.1.0
       * @category Array
       * @param {Array} [props=[]] The property identifiers.
       * @param {Array} [values=[]] The property values.
       * @returns {Object} Returns the new object.
       * @example
       *
       * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
       * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
       */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
       * This method is like `_.zip` except that it accepts `iteratee` to specify
       * how grouped values should be combined. The iteratee is invoked with the
       * elements of each group: (...group).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Array
       * @param {...Array} [arrays] The arrays to process.
       * @param {Function} [iteratee=_.identity] The function to combine
       *  grouped values.
       * @returns {Array} Returns the new array of grouped elements.
       * @example
       *
       * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
       *   return a + b + c;
       * });
       * // => [111, 222]
       */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined$1;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined$1;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
       * Creates a `lodash` wrapper instance that wraps `value` with explicit method
       * chain sequences enabled. The result of such sequences must be unwrapped
       * with `_#value`.
       *
       * @static
       * @memberOf _
       * @since 1.3.0
       * @category Seq
       * @param {*} value The value to wrap.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36 },
       *   { 'user': 'fred',    'age': 40 },
       *   { 'user': 'pebbles', 'age': 1 }
       * ];
       *
       * var youngest = _
       *   .chain(users)
       *   .sortBy('age')
       *   .map(function(o) {
       *     return o.user + ' is ' + o.age;
       *   })
       *   .head()
       *   .value();
       * // => 'pebbles is 1'
       */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
       * This method invokes `interceptor` and returns `value`. The interceptor
       * is invoked with one argument; (value). The purpose of this method is to
       * "tap into" a method chain sequence in order to modify intermediate results.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @param {*} value The value to provide to `interceptor`.
       * @param {Function} interceptor The function to invoke.
       * @returns {*} Returns `value`.
       * @example
       *
       * _([1, 2, 3])
       *  .tap(function(array) {
       *    // Mutate input array.
       *    array.pop();
       *  })
       *  .reverse()
       *  .value();
       * // => [2, 1]
       */function tap(value,interceptor){interceptor(value);return value;}/**
       * This method is like `_.tap` except that it returns the result of `interceptor`.
       * The purpose of this method is to "pass thru" values replacing intermediate
       * results in a method chain sequence.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Seq
       * @param {*} value The value to provide to `interceptor`.
       * @param {Function} interceptor The function to invoke.
       * @returns {*} Returns the result of `interceptor`.
       * @example
       *
       * _('  abc  ')
       *  .chain()
       *  .trim()
       *  .thru(function(value) {
       *    return [value];
       *  })
       *  .value();
       * // => ['abc']
       */function thru(value,interceptor){return interceptor(value);}/**
       * This method is the wrapper version of `_.at`.
       *
       * @name at
       * @memberOf _
       * @since 1.0.0
       * @category Seq
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
       *
       * _(object).at(['a[0].b.c', 'a[1]']).value();
       * // => [3, 4]
       */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function interceptor(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined$1});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined$1);}return array;});});/**
       * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
       *
       * @name chain
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 40 }
       * ];
       *
       * // A sequence without explicit chaining.
       * _(users).head();
       * // => { 'user': 'barney', 'age': 36 }
       *
       * // A sequence with explicit chaining.
       * _(users)
       *   .chain()
       *   .head()
       *   .pick('user')
       *   .value();
       * // => { 'user': 'barney' }
       */function wrapperChain(){return chain(this);}/**
       * Executes the chain sequence and returns the wrapped result.
       *
       * @name commit
       * @memberOf _
       * @since 3.2.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var array = [1, 2];
       * var wrapped = _(array).push(3);
       *
       * console.log(array);
       * // => [1, 2]
       *
       * wrapped = wrapped.commit();
       * console.log(array);
       * // => [1, 2, 3]
       *
       * wrapped.last();
       * // => 3
       *
       * console.log(array);
       * // => [1, 2, 3]
       */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
       * Gets the next value on a wrapped object following the
       * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
       *
       * @name next
       * @memberOf _
       * @since 4.0.0
       * @category Seq
       * @returns {Object} Returns the next iterator value.
       * @example
       *
       * var wrapped = _([1, 2]);
       *
       * wrapped.next();
       * // => { 'done': false, 'value': 1 }
       *
       * wrapped.next();
       * // => { 'done': false, 'value': 2 }
       *
       * wrapped.next();
       * // => { 'done': true, 'value': undefined }
       */function wrapperNext(){if(this.__values__===undefined$1){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined$1:this.__values__[this.__index__++];return {'done':done,'value':value};}/**
       * Enables the wrapper to be iterable.
       *
       * @name Symbol.iterator
       * @memberOf _
       * @since 4.0.0
       * @category Seq
       * @returns {Object} Returns the wrapper object.
       * @example
       *
       * var wrapped = _([1, 2]);
       *
       * wrapped[Symbol.iterator]() === wrapped;
       * // => true
       *
       * Array.from(wrapped);
       * // => [1, 2]
       */function wrapperToIterator(){return this;}/**
       * Creates a clone of the chain sequence planting `value` as the wrapped value.
       *
       * @name plant
       * @memberOf _
       * @since 3.2.0
       * @category Seq
       * @param {*} value The value to plant.
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var wrapped = _([1, 2]).map(square);
       * var other = wrapped.plant([3, 4]);
       *
       * other.value();
       * // => [9, 16]
       *
       * wrapped.value();
       * // => [1, 4]
       */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined$1;if(result){previous.__wrapped__=clone;}else {result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
       * This method is the wrapper version of `_.reverse`.
       *
       * **Note:** This method mutates the wrapped array.
       *
       * @name reverse
       * @memberOf _
       * @since 0.1.0
       * @category Seq
       * @returns {Object} Returns the new `lodash` wrapper instance.
       * @example
       *
       * var array = [1, 2, 3];
       *
       * _(array).reverse().value()
       * // => [3, 2, 1]
       *
       * console.log(array);
       * // => [3, 2, 1]
       */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined$1});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
       * Executes the chain sequence to resolve the unwrapped value.
       *
       * @name value
       * @memberOf _
       * @since 0.1.0
       * @alias toJSON, valueOf
       * @category Seq
       * @returns {*} Returns the resolved unwrapped value.
       * @example
       *
       * _([1, 2, 3]).value();
       * // => [1, 2, 3]
       */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The corresponding value of
       * each key is the number of times the key was returned by `iteratee`. The
       * iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * _.countBy([6.1, 4.2, 6.3], Math.floor);
       * // => { '4': 1, '6': 2 }
       *
       * // The `_.property` iteratee shorthand.
       * _.countBy(['one', 'two', 'three'], 'length');
       * // => { '3': 2, '5': 1 }
       */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else {baseAssignValue(result,key,1);}});/**
       * Checks if `predicate` returns truthy for **all** elements of `collection`.
       * Iteration is stopped once `predicate` returns falsey. The predicate is
       * invoked with three arguments: (value, index|key, collection).
       *
       * **Note:** This method returns `true` for
       * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
       * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
       * elements of empty collections.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {boolean} Returns `true` if all elements pass the predicate check,
       *  else `false`.
       * @example
       *
       * _.every([true, 1, null, 'yes'], Boolean);
       * // => false
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': false },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.every(users, { 'user': 'barney', 'active': false });
       * // => false
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.every(users, ['active', false]);
       * // => true
       *
       * // The `_.property` iteratee shorthand.
       * _.every(users, 'active');
       * // => false
       */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined$1;}return func(collection,getIteratee(predicate,3));}/**
       * Iterates over elements of `collection`, returning an array of all elements
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index|key, collection).
       *
       * **Note:** Unlike `_.remove`, this method returns a new array.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @see _.reject
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': true },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * _.filter(users, function(o) { return !o.active; });
       * // => objects for ['fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.filter(users, { 'age': 36, 'active': true });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.filter(users, ['active', false]);
       * // => objects for ['fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.filter(users, 'active');
       * // => objects for ['barney']
       *
       * // Combining several predicates using `_.overEvery` or `_.overSome`.
       * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
       * // => objects for ['fred', 'barney']
       */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
       * Iterates over elements of `collection`, returning the first element
       * `predicate` returns truthy for. The predicate is invoked with three
       * arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=0] The index to search from.
       * @returns {*} Returns the matched element, else `undefined`.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36, 'active': true },
       *   { 'user': 'fred',    'age': 40, 'active': false },
       *   { 'user': 'pebbles', 'age': 1,  'active': true }
       * ];
       *
       * _.find(users, function(o) { return o.age < 40; });
       * // => object for 'barney'
       *
       * // The `_.matches` iteratee shorthand.
       * _.find(users, { 'age': 1, 'active': true });
       * // => object for 'pebbles'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.find(users, ['active', false]);
       * // => object for 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.find(users, 'active');
       * // => object for 'barney'
       */var find=createFind(findIndex);/**
       * This method is like `_.find` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param {number} [fromIndex=collection.length-1] The index to search from.
       * @returns {*} Returns the matched element, else `undefined`.
       * @example
       *
       * _.findLast([1, 2, 3, 4], function(n) {
       *   return n % 2 == 1;
       * });
       * // => 3
       */var findLast=createFind(findLastIndex);/**
       * Creates a flattened array of values by running each element in `collection`
       * thru `iteratee` and flattening the mapped results. The iteratee is invoked
       * with three arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [n, n];
       * }
       *
       * _.flatMap([1, 2], duplicate);
       * // => [1, 1, 2, 2]
       */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
       * This method is like `_.flatMap` except that it recursively flattens the
       * mapped results.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [[[n, n]]];
       * }
       *
       * _.flatMapDeep([1, 2], duplicate);
       * // => [1, 1, 2, 2]
       */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
       * This method is like `_.flatMap` except that it recursively flattens the
       * mapped results up to `depth` times.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {number} [depth=1] The maximum recursion depth.
       * @returns {Array} Returns the new flattened array.
       * @example
       *
       * function duplicate(n) {
       *   return [[[n, n]]];
       * }
       *
       * _.flatMapDepth([1, 2], duplicate, 2);
       * // => [[1, 1], [2, 2]]
       */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined$1?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
       * Iterates over elements of `collection` and invokes `iteratee` for each element.
       * The iteratee is invoked with three arguments: (value, index|key, collection).
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * **Note:** As with other "Collections" methods, objects with a "length"
       * property are iterated like arrays. To avoid this behavior use `_.forIn`
       * or `_.forOwn` for object iteration.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @alias each
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @see _.forEachRight
       * @example
       *
       * _.forEach([1, 2], function(value) {
       *   console.log(value);
       * });
       * // => Logs `1` then `2`.
       *
       * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a' then 'b' (iteration order is not guaranteed).
       */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
       * This method is like `_.forEach` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @alias eachRight
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array|Object} Returns `collection`.
       * @see _.forEach
       * @example
       *
       * _.forEachRight([1, 2], function(value) {
       *   console.log(value);
       * });
       * // => Logs `2` then `1`.
       */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The order of grouped values
       * is determined by the order they occur in `collection`. The corresponding
       * value of each key is an array of elements responsible for generating the
       * key. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * _.groupBy([6.1, 4.2, 6.3], Math.floor);
       * // => { '4': [4.2], '6': [6.1, 6.3] }
       *
       * // The `_.property` iteratee shorthand.
       * _.groupBy(['one', 'two', 'three'], 'length');
       * // => { '3': ['one', 'two'], '5': ['three'] }
       */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else {baseAssignValue(result,key,[value]);}});/**
       * Checks if `value` is in `collection`. If `collection` is a string, it's
       * checked for a substring of `value`, otherwise
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * is used for equality comparisons. If `fromIndex` is negative, it's used as
       * the offset from the end of `collection`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object|string} collection The collection to inspect.
       * @param {*} value The value to search for.
       * @param {number} [fromIndex=0] The index to search from.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
       * @returns {boolean} Returns `true` if `value` is found, else `false`.
       * @example
       *
       * _.includes([1, 2, 3], 1);
       * // => true
       *
       * _.includes([1, 2, 3], 1, 2);
       * // => false
       *
       * _.includes({ 'a': 1, 'b': 2 }, 1);
       * // => true
       *
       * _.includes('abcd', 'bc');
       * // => true
       */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
       * Invokes the method at `path` of each element in `collection`, returning
       * an array of the results of each invoked method. Any additional arguments
       * are provided to each invoked method. If `path` is a function, it's invoked
       * for, and `this` bound to, each element in `collection`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Array|Function|string} path The path of the method to invoke or
       *  the function invoked per iteration.
       * @param {...*} [args] The arguments to invoke each method with.
       * @returns {Array} Returns the array of results.
       * @example
       *
       * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
       * // => [[1, 5, 7], [1, 2, 3]]
       *
       * _.invokeMap([123, 456], String.prototype.split, '');
       * // => [['1', '2', '3'], ['4', '5', '6']]
       */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
       * Creates an object composed of keys generated from the results of running
       * each element of `collection` thru `iteratee`. The corresponding value of
       * each key is the last element responsible for generating the key. The
       * iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
       * @returns {Object} Returns the composed aggregate object.
       * @example
       *
       * var array = [
       *   { 'dir': 'left', 'code': 97 },
       *   { 'dir': 'right', 'code': 100 }
       * ];
       *
       * _.keyBy(array, function(o) {
       *   return String.fromCharCode(o.code);
       * });
       * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
       *
       * _.keyBy(array, 'dir');
       * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
       */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
       * Creates an array of values by running each element in `collection` thru
       * `iteratee`. The iteratee is invoked with three arguments:
       * (value, index|key, collection).
       *
       * Many lodash methods are guarded to work as iteratees for methods like
       * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
       *
       * The guarded methods are:
       * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
       * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
       * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
       * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new mapped array.
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * _.map([4, 8], square);
       * // => [16, 64]
       *
       * _.map({ 'a': 4, 'b': 8 }, square);
       * // => [16, 64] (iteration order is not guaranteed)
       *
       * var users = [
       *   { 'user': 'barney' },
       *   { 'user': 'fred' }
       * ];
       *
       * // The `_.property` iteratee shorthand.
       * _.map(users, 'user');
       * // => ['barney', 'fred']
       */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
       * This method is like `_.sortBy` except that it allows specifying the sort
       * orders of the iteratees to sort by. If `orders` is unspecified, all values
       * are sorted in ascending order. Otherwise, specify an order of "desc" for
       * descending or "asc" for ascending sort order of corresponding values.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
       *  The iteratees to sort by.
       * @param {string[]} [orders] The sort orders of `iteratees`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
       * @returns {Array} Returns the new sorted array.
       * @example
       *
       * var users = [
       *   { 'user': 'fred',   'age': 48 },
       *   { 'user': 'barney', 'age': 34 },
       *   { 'user': 'fred',   'age': 40 },
       *   { 'user': 'barney', 'age': 36 }
       * ];
       *
       * // Sort by `user` in ascending order and by `age` in descending order.
       * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
       * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
       */function orderBy(collection,iteratees,orders,guard){if(collection==null){return [];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined$1:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
       * Creates an array of elements split into two groups, the first of which
       * contains elements `predicate` returns truthy for, the second of which
       * contains elements `predicate` returns falsey for. The predicate is
       * invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the array of grouped elements.
       * @example
       *
       * var users = [
       *   { 'user': 'barney',  'age': 36, 'active': false },
       *   { 'user': 'fred',    'age': 40, 'active': true },
       *   { 'user': 'pebbles', 'age': 1,  'active': false }
       * ];
       *
       * _.partition(users, function(o) { return o.active; });
       * // => objects for [['fred'], ['barney', 'pebbles']]
       *
       * // The `_.matches` iteratee shorthand.
       * _.partition(users, { 'age': 1, 'active': false });
       * // => objects for [['pebbles'], ['barney', 'fred']]
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.partition(users, ['active', false]);
       * // => objects for [['barney', 'pebbles'], ['fred']]
       *
       * // The `_.property` iteratee shorthand.
       * _.partition(users, 'active');
       * // => objects for [['fred'], ['barney', 'pebbles']]
       */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return [[],[]];});/**
       * Reduces `collection` to a value which is the accumulated result of running
       * each element in `collection` thru `iteratee`, where each successive
       * invocation is supplied the return value of the previous. If `accumulator`
       * is not given, the first element of `collection` is used as the initial
       * value. The iteratee is invoked with four arguments:
       * (accumulator, value, index|key, collection).
       *
       * Many lodash methods are guarded to work as iteratees for methods like
       * `_.reduce`, `_.reduceRight`, and `_.transform`.
       *
       * The guarded methods are:
       * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
       * and `sortBy`
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @see _.reduceRight
       * @example
       *
       * _.reduce([1, 2], function(sum, n) {
       *   return sum + n;
       * }, 0);
       * // => 3
       *
       * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
       *   (result[value] || (result[value] = [])).push(key);
       *   return result;
       * }, {});
       * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
       */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
       * This method is like `_.reduce` except that it iterates over elements of
       * `collection` from right to left.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The initial value.
       * @returns {*} Returns the accumulated value.
       * @see _.reduce
       * @example
       *
       * var array = [[0, 1], [2, 3], [4, 5]];
       *
       * _.reduceRight(array, function(flattened, other) {
       *   return flattened.concat(other);
       * }, []);
       * // => [4, 5, 2, 3, 0, 1]
       */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
       * The opposite of `_.filter`; this method returns the elements of `collection`
       * that `predicate` does **not** return truthy for.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the new filtered array.
       * @see _.filter
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': false },
       *   { 'user': 'fred',   'age': 40, 'active': true }
       * ];
       *
       * _.reject(users, function(o) { return !o.active; });
       * // => objects for ['fred']
       *
       * // The `_.matches` iteratee shorthand.
       * _.reject(users, { 'age': 40, 'active': true });
       * // => objects for ['barney']
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.reject(users, ['active', false]);
       * // => objects for ['fred']
       *
       * // The `_.property` iteratee shorthand.
       * _.reject(users, 'active');
       * // => objects for ['barney']
       */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
       * Gets a random element from `collection`.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to sample.
       * @returns {*} Returns the random element.
       * @example
       *
       * _.sample([1, 2, 3, 4]);
       * // => 2
       */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
       * Gets `n` random elements at unique keys from `collection` up to the
       * size of `collection`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Collection
       * @param {Array|Object} collection The collection to sample.
       * @param {number} [n=1] The number of elements to sample.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the random elements.
       * @example
       *
       * _.sampleSize([1, 2, 3], 2);
       * // => [3, 1]
       *
       * _.sampleSize([1, 2, 3], 4);
       * // => [2, 3, 1]
       */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined$1){n=1;}else {n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
       * Creates an array of shuffled values, using a version of the
       * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to shuffle.
       * @returns {Array} Returns the new shuffled array.
       * @example
       *
       * _.shuffle([1, 2, 3, 4]);
       * // => [4, 1, 3, 2]
       */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
       * Gets the size of `collection` by returning its length for array-like
       * values or the number of own enumerable string keyed properties for objects.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object|string} collection The collection to inspect.
       * @returns {number} Returns the collection size.
       * @example
       *
       * _.size([1, 2, 3]);
       * // => 3
       *
       * _.size({ 'a': 1, 'b': 2 });
       * // => 2
       *
       * _.size('pebbles');
       * // => 7
       */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
       * Checks if `predicate` returns truthy for **any** element of `collection`.
       * Iteration is stopped once `predicate` returns truthy. The predicate is
       * invoked with three arguments: (value, index|key, collection).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {boolean} Returns `true` if any element passes the predicate check,
       *  else `false`.
       * @example
       *
       * _.some([null, 0, 'yes', false], Boolean);
       * // => true
       *
       * var users = [
       *   { 'user': 'barney', 'active': true },
       *   { 'user': 'fred',   'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.some(users, { 'user': 'barney', 'active': false });
       * // => false
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.some(users, ['active', false]);
       * // => true
       *
       * // The `_.property` iteratee shorthand.
       * _.some(users, 'active');
       * // => true
       */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined$1;}return func(collection,getIteratee(predicate,3));}/**
       * Creates an array of elements, sorted in ascending order by the results of
       * running each element in a collection thru each iteratee. This method
       * performs a stable sort, that is, it preserves the original sort order of
       * equal elements. The iteratees are invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Collection
       * @param {Array|Object} collection The collection to iterate over.
       * @param {...(Function|Function[])} [iteratees=[_.identity]]
       *  The iteratees to sort by.
       * @returns {Array} Returns the new sorted array.
       * @example
       *
       * var users = [
       *   { 'user': 'fred',   'age': 48 },
       *   { 'user': 'barney', 'age': 36 },
       *   { 'user': 'fred',   'age': 30 },
       *   { 'user': 'barney', 'age': 34 }
       * ];
       *
       * _.sortBy(users, [function(o) { return o.user; }]);
       * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
       *
       * _.sortBy(users, ['user', 'age']);
       * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
       */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return [];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
       * Gets the timestamp of the number of milliseconds that have elapsed since
       * the Unix epoch (1 January 1970 00:00:00 UTC).
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Date
       * @returns {number} Returns the timestamp.
       * @example
       *
       * _.defer(function(stamp) {
       *   console.log(_.now() - stamp);
       * }, _.now());
       * // => Logs the number of milliseconds it took for the deferred invocation.
       */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
       * The opposite of `_.before`; this method creates a function that invokes
       * `func` once it's called `n` or more times.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {number} n The number of calls before `func` is invoked.
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * var saves = ['profile', 'settings'];
       *
       * var done = _.after(saves.length, function() {
       *   console.log('done saving!');
       * });
       *
       * _.forEach(saves, function(type) {
       *   asyncSave({ 'type': type, 'complete': done });
       * });
       * // => Logs 'done saving!' after the two async saves have completed.
       */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
       * Creates a function that invokes `func`, with up to `n` arguments,
       * ignoring any additional arguments.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to cap arguments for.
       * @param {number} [n=func.length] The arity cap.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new capped function.
       * @example
       *
       * _.map(['6', '8', '10'], _.ary(parseInt, 1));
       * // => [6, 8, 10]
       */function ary(func,n,guard){n=guard?undefined$1:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,n);}/**
       * Creates a function that invokes `func`, with the `this` binding and arguments
       * of the created function, while it's called less than `n` times. Subsequent
       * calls to the created function return the result of the last `func` invocation.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {number} n The number of calls at which `func` is no longer invoked.
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * jQuery(element).on('click', _.before(5, addContactToList));
       * // => Allows adding up to 4 contacts to the list.
       */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined$1;}return result;};}/**
       * Creates a function that invokes `func` with the `this` binding of `thisArg`
       * and `partials` prepended to the arguments it receives.
       *
       * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
       * may be used as a placeholder for partially applied arguments.
       *
       * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
       * property of bound functions.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to bind.
       * @param {*} thisArg The `this` binding of `func`.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new bound function.
       * @example
       *
       * function greet(greeting, punctuation) {
       *   return greeting + ' ' + this.user + punctuation;
       * }
       *
       * var object = { 'user': 'fred' };
       *
       * var bound = _.bind(greet, object, 'hi');
       * bound('!');
       * // => 'hi fred!'
       *
       * // Bound with placeholders.
       * var bound = _.bind(greet, object, _, '!');
       * bound('hi');
       * // => 'hi fred!'
       */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
       * Creates a function that invokes the method at `object[key]` with `partials`
       * prepended to the arguments it receives.
       *
       * This method differs from `_.bind` by allowing bound functions to reference
       * methods that may be redefined or don't yet exist. See
       * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
       * for more details.
       *
       * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * @static
       * @memberOf _
       * @since 0.10.0
       * @category Function
       * @param {Object} object The object to invoke the method on.
       * @param {string} key The key of the method.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new bound function.
       * @example
       *
       * var object = {
       *   'user': 'fred',
       *   'greet': function(greeting, punctuation) {
       *     return greeting + ' ' + this.user + punctuation;
       *   }
       * };
       *
       * var bound = _.bindKey(object, 'greet', 'hi');
       * bound('!');
       * // => 'hi fred!'
       *
       * object.greet = function(greeting, punctuation) {
       *   return greeting + 'ya ' + this.user + punctuation;
       * };
       *
       * bound('!');
       * // => 'hiya fred!'
       *
       * // Bound with placeholders.
       * var bound = _.bindKey(object, 'greet', _, '!');
       * bound('hi');
       * // => 'hiya fred!'
       */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
       * Creates a function that accepts arguments of `func` and either invokes
       * `func` returning its result, if at least `arity` number of arguments have
       * been provided, or returns a function that accepts the remaining `func`
       * arguments, and so on. The arity of `func` may be specified if `func.length`
       * is not sufficient.
       *
       * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
       * may be used as a placeholder for provided arguments.
       *
       * **Note:** This method doesn't set the "length" property of curried functions.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Function
       * @param {Function} func The function to curry.
       * @param {number} [arity=func.length] The arity of `func`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new curried function.
       * @example
       *
       * var abc = function(a, b, c) {
       *   return [a, b, c];
       * };
       *
       * var curried = _.curry(abc);
       *
       * curried(1)(2)(3);
       * // => [1, 2, 3]
       *
       * curried(1, 2)(3);
       * // => [1, 2, 3]
       *
       * curried(1, 2, 3);
       * // => [1, 2, 3]
       *
       * // Curried with placeholders.
       * curried(1)(_, 3)(2);
       * // => [1, 2, 3]
       */function curry(func,arity,guard){arity=guard?undefined$1:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,undefined$1,arity);result.placeholder=curry.placeholder;return result;}/**
       * This method is like `_.curry` except that arguments are applied to `func`
       * in the manner of `_.partialRight` instead of `_.partial`.
       *
       * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for provided arguments.
       *
       * **Note:** This method doesn't set the "length" property of curried functions.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to curry.
       * @param {number} [arity=func.length] The arity of `func`.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the new curried function.
       * @example
       *
       * var abc = function(a, b, c) {
       *   return [a, b, c];
       * };
       *
       * var curried = _.curryRight(abc);
       *
       * curried(3)(2)(1);
       * // => [1, 2, 3]
       *
       * curried(2, 3)(1);
       * // => [1, 2, 3]
       *
       * curried(1, 2, 3);
       * // => [1, 2, 3]
       *
       * // Curried with placeholders.
       * curried(3)(1, _)(2);
       * // => [1, 2, 3]
       */function curryRight(func,arity,guard){arity=guard?undefined$1:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,undefined$1,arity);result.placeholder=curryRight.placeholder;return result;}/**
       * Creates a debounced function that delays invoking `func` until after `wait`
       * milliseconds have elapsed since the last time the debounced function was
       * invoked. The debounced function comes with a `cancel` method to cancel
       * delayed `func` invocations and a `flush` method to immediately invoke them.
       * Provide `options` to indicate whether `func` should be invoked on the
       * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
       * with the last arguments provided to the debounced function. Subsequent
       * calls to the debounced function return the result of the last `func`
       * invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the debounced function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.debounce` and `_.throttle`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to debounce.
       * @param {number} [wait=0] The number of milliseconds to delay.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=false]
       *  Specify invoking on the leading edge of the timeout.
       * @param {number} [options.maxWait]
       *  The maximum time `func` is allowed to be delayed before it's invoked.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new debounced function.
       * @example
       *
       * // Avoid costly calculations while the window size is in flux.
       * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
       *
       * // Invoke `sendMail` when clicked, debouncing subsequent calls.
       * jQuery(element).on('click', _.debounce(sendMail, 300, {
       *   'leading': true,
       *   'trailing': false
       * }));
       *
       * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
       * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
       * var source = new EventSource('/stream');
       * jQuery(source).on('message', debounced);
       *
       * // Cancel the trailing debounced invocation.
       * jQuery(window).on('popstate', debounced.cancel);
       */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined$1;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
  lastInvokeTime=time;// Start the timer for the trailing edge.
  timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
  return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
  // trailing edge, the system time has gone backwards and we're treating
  // it as the trailing edge, or we've hit the `maxWait` limit.
  return lastCallTime===undefined$1||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
  timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined$1;// Only invoke if we have `lastArgs` which means `func` has been
  // debounced at least once.
  if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined$1;return result;}function cancel(){if(timerId!==undefined$1){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined$1;}function flush(){return timerId===undefined$1?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined$1){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
  clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined$1){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
       * Defers invoking the `func` until the current call stack has cleared. Any
       * additional arguments are provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to defer.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {number} Returns the timer id.
       * @example
       *
       * _.defer(function(text) {
       *   console.log(text);
       * }, 'deferred');
       * // => Logs 'deferred' after one millisecond.
       */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
       * Invokes `func` after `wait` milliseconds. Any additional arguments are
       * provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to delay.
       * @param {number} wait The number of milliseconds to delay invocation.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {number} Returns the timer id.
       * @example
       *
       * _.delay(function(text) {
       *   console.log(text);
       * }, 1000, 'later');
       * // => Logs 'later' after one second.
       */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
       * Creates a function that invokes `func` with arguments reversed.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to flip arguments for.
       * @returns {Function} Returns the new flipped function.
       * @example
       *
       * var flipped = _.flip(function() {
       *   return _.toArray(arguments);
       * });
       *
       * flipped('a', 'b', 'c', 'd');
       * // => ['d', 'c', 'b', 'a']
       */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
       * Creates a function that memoizes the result of `func`. If `resolver` is
       * provided, it determines the cache key for storing the result based on the
       * arguments provided to the memoized function. By default, the first argument
       * provided to the memoized function is used as the map cache key. The `func`
       * is invoked with the `this` binding of the memoized function.
       *
       * **Note:** The cache is exposed as the `cache` property on the memoized
       * function. Its creation may be customized by replacing the `_.memoize.Cache`
       * constructor with one whose instances implement the
       * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
       * method interface of `clear`, `delete`, `get`, `has`, and `set`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to have its output memoized.
       * @param {Function} [resolver] The function to resolve the cache key.
       * @returns {Function} Returns the new memoized function.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       * var other = { 'c': 3, 'd': 4 };
       *
       * var values = _.memoize(_.values);
       * values(object);
       * // => [1, 2]
       *
       * values(other);
       * // => [3, 4]
       *
       * object.a = 2;
       * values(object);
       * // => [1, 2]
       *
       * // Modify the result cache.
       * values.cache.set(object, ['a', 'b']);
       * values(object);
       * // => ['a', 'b']
       *
       * // Replace `_.memoize.Cache`.
       * _.memoize.Cache = WeakMap;
       */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function memoized(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
  memoize.Cache=MapCache;/**
       * Creates a function that negates the result of the predicate `func`. The
       * `func` predicate is invoked with the `this` binding and arguments of the
       * created function.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} predicate The predicate to negate.
       * @returns {Function} Returns the new negated function.
       * @example
       *
       * function isEven(n) {
       *   return n % 2 == 0;
       * }
       *
       * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
       * // => [1, 3, 5]
       */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return !predicate.call(this);case 1:return !predicate.call(this,args[0]);case 2:return !predicate.call(this,args[0],args[1]);case 3:return !predicate.call(this,args[0],args[1],args[2]);}return !predicate.apply(this,args);};}/**
       * Creates a function that is restricted to invoking `func` once. Repeat calls
       * to the function return the value of the first invocation. The `func` is
       * invoked with the `this` binding and arguments of the created function.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to restrict.
       * @returns {Function} Returns the new restricted function.
       * @example
       *
       * var initialize = _.once(createApplication);
       * initialize();
       * initialize();
       * // => `createApplication` is invoked once
       */function once(func){return before(2,func);}/**
       * Creates a function that invokes `func` with its arguments transformed.
       *
       * @static
       * @since 4.0.0
       * @memberOf _
       * @category Function
       * @param {Function} func The function to wrap.
       * @param {...(Function|Function[])} [transforms=[_.identity]]
       *  The argument transforms.
       * @returns {Function} Returns the new function.
       * @example
       *
       * function doubled(n) {
       *   return n * 2;
       * }
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var func = _.overArgs(function(x, y) {
       *   return [x, y];
       * }, [square, doubled]);
       *
       * func(9, 3);
       * // => [81, 6]
       *
       * func(10, 5);
       * // => [100, 10]
       */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
       * Creates a function that invokes `func` with `partials` prepended to the
       * arguments it receives. This method is like `_.bind` except it does **not**
       * alter the `this` binding.
       *
       * The `_.partial.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * **Note:** This method doesn't set the "length" property of partially
       * applied functions.
       *
       * @static
       * @memberOf _
       * @since 0.2.0
       * @category Function
       * @param {Function} func The function to partially apply arguments to.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new partially applied function.
       * @example
       *
       * function greet(greeting, name) {
       *   return greeting + ' ' + name;
       * }
       *
       * var sayHelloTo = _.partial(greet, 'hello');
       * sayHelloTo('fred');
       * // => 'hello fred'
       *
       * // Partially applied with placeholders.
       * var greetFred = _.partial(greet, _, 'fred');
       * greetFred('hi');
       * // => 'hi fred'
       */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined$1,partials,holders);});/**
       * This method is like `_.partial` except that partially applied arguments
       * are appended to the arguments it receives.
       *
       * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
       * builds, may be used as a placeholder for partially applied arguments.
       *
       * **Note:** This method doesn't set the "length" property of partially
       * applied functions.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Function
       * @param {Function} func The function to partially apply arguments to.
       * @param {...*} [partials] The arguments to be partially applied.
       * @returns {Function} Returns the new partially applied function.
       * @example
       *
       * function greet(greeting, name) {
       *   return greeting + ' ' + name;
       * }
       *
       * var greetFred = _.partialRight(greet, 'fred');
       * greetFred('hi');
       * // => 'hi fred'
       *
       * // Partially applied with placeholders.
       * var sayHelloTo = _.partialRight(greet, 'hello', _);
       * sayHelloTo('fred');
       * // => 'hello fred'
       */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined$1,partials,holders);});/**
       * Creates a function that invokes `func` with arguments arranged according
       * to the specified `indexes` where the argument value at the first index is
       * provided as the first argument, the argument value at the second index is
       * provided as the second argument, and so on.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Function
       * @param {Function} func The function to rearrange arguments for.
       * @param {...(number|number[])} indexes The arranged argument indexes.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var rearged = _.rearg(function(a, b, c) {
       *   return [a, b, c];
       * }, [2, 0, 1]);
       *
       * rearged('b', 'c', 'a')
       * // => ['a', 'b', 'c']
       */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined$1,undefined$1,undefined$1,indexes);});/**
       * Creates a function that invokes `func` with the `this` binding of the
       * created function and arguments from `start` and beyond provided as
       * an array.
       *
       * **Note:** This method is based on the
       * [rest parameter](https://mdn.io/rest_parameters).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to apply a rest parameter to.
       * @param {number} [start=func.length-1] The start position of the rest parameter.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var say = _.rest(function(what, names) {
       *   return what + ' ' + _.initial(names).join(', ') +
       *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
       * });
       *
       * say('hello', 'fred', 'barney', 'pebbles');
       * // => 'hello fred, barney, & pebbles'
       */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined$1?start:toInteger(start);return baseRest(func,start);}/**
       * Creates a function that invokes `func` with the `this` binding of the
       * create function and an array of arguments much like
       * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
       *
       * **Note:** This method is based on the
       * [spread operator](https://mdn.io/spread_operator).
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Function
       * @param {Function} func The function to spread arguments over.
       * @param {number} [start=0] The start position of the spread.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var say = _.spread(function(who, what) {
       *   return who + ' says ' + what;
       * });
       *
       * say(['fred', 'hello']);
       * // => 'fred says hello'
       *
       * var numbers = Promise.all([
       *   Promise.resolve(40),
       *   Promise.resolve(36)
       * ]);
       *
       * numbers.then(_.spread(function(x, y) {
       *   return x + y;
       * }));
       * // => a Promise of 76
       */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
       * Creates a throttled function that only invokes `func` at most once per
       * every `wait` milliseconds. The throttled function comes with a `cancel`
       * method to cancel delayed `func` invocations and a `flush` method to
       * immediately invoke them. Provide `options` to indicate whether `func`
       * should be invoked on the leading and/or trailing edge of the `wait`
       * timeout. The `func` is invoked with the last arguments provided to the
       * throttled function. Subsequent calls to the throttled function return the
       * result of the last `func` invocation.
       *
       * **Note:** If `leading` and `trailing` options are `true`, `func` is
       * invoked on the trailing edge of the timeout only if the throttled function
       * is invoked more than once during the `wait` timeout.
       *
       * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
       * until to the next tick, similar to `setTimeout` with a timeout of `0`.
       *
       * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
       * for details over the differences between `_.throttle` and `_.debounce`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {Function} func The function to throttle.
       * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.leading=true]
       *  Specify invoking on the leading edge of the timeout.
       * @param {boolean} [options.trailing=true]
       *  Specify invoking on the trailing edge of the timeout.
       * @returns {Function} Returns the new throttled function.
       * @example
       *
       * // Avoid excessively updating the position while scrolling.
       * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
       *
       * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
       * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
       * jQuery(element).on('click', throttled);
       *
       * // Cancel the trailing throttled invocation.
       * jQuery(window).on('popstate', throttled.cancel);
       */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
       * Creates a function that accepts up to one argument, ignoring any
       * additional arguments.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Function
       * @param {Function} func The function to cap arguments for.
       * @returns {Function} Returns the new capped function.
       * @example
       *
       * _.map(['6', '8', '10'], _.unary(parseInt));
       * // => [6, 8, 10]
       */function unary(func){return ary(func,1);}/**
       * Creates a function that provides `value` to `wrapper` as its first
       * argument. Any additional arguments provided to the function are appended
       * to those provided to the `wrapper`. The wrapper is invoked with the `this`
       * binding of the created function.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Function
       * @param {*} value The value to wrap.
       * @param {Function} [wrapper=identity] The wrapper function.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var p = _.wrap(_.escape, function(func, text) {
       *   return '<p>' + func(text) + '</p>';
       * });
       *
       * p('fred, barney, & pebbles');
       * // => '<p>fred, barney, &amp; pebbles</p>'
       */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
       * Casts `value` as an array if it's not one.
       *
       * @static
       * @memberOf _
       * @since 4.4.0
       * @category Lang
       * @param {*} value The value to inspect.
       * @returns {Array} Returns the cast array.
       * @example
       *
       * _.castArray(1);
       * // => [1]
       *
       * _.castArray({ 'a': 1 });
       * // => [{ 'a': 1 }]
       *
       * _.castArray('abc');
       * // => ['abc']
       *
       * _.castArray(null);
       * // => [null]
       *
       * _.castArray(undefined);
       * // => [undefined]
       *
       * _.castArray();
       * // => []
       *
       * var array = [1, 2, 3];
       * console.log(_.castArray(array) === array);
       * // => true
       */function castArray(){if(!arguments.length){return [];}var value=arguments[0];return isArray(value)?value:[value];}/**
       * Creates a shallow clone of `value`.
       *
       * **Note:** This method is loosely based on the
       * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
       * and supports cloning arrays, array buffers, booleans, date objects, maps,
       * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
       * arrays. The own enumerable properties of `arguments` objects are cloned
       * as plain objects. An empty object is returned for uncloneable values such
       * as error objects, functions, DOM nodes, and WeakMaps.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to clone.
       * @returns {*} Returns the cloned value.
       * @see _.cloneDeep
       * @example
       *
       * var objects = [{ 'a': 1 }, { 'b': 2 }];
       *
       * var shallow = _.clone(objects);
       * console.log(shallow[0] === objects[0]);
       * // => true
       */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
       * This method is like `_.clone` except that it accepts `customizer` which
       * is invoked to produce the cloned value. If `customizer` returns `undefined`,
       * cloning is handled by the method instead. The `customizer` is invoked with
       * up to four arguments; (value [, index|key, object, stack]).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to clone.
       * @param {Function} [customizer] The function to customize cloning.
       * @returns {*} Returns the cloned value.
       * @see _.cloneDeepWith
       * @example
       *
       * function customizer(value) {
       *   if (_.isElement(value)) {
       *     return value.cloneNode(false);
       *   }
       * }
       *
       * var el = _.cloneWith(document.body, customizer);
       *
       * console.log(el === document.body);
       * // => false
       * console.log(el.nodeName);
       * // => 'BODY'
       * console.log(el.childNodes.length);
       * // => 0
       */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
       * This method is like `_.clone` except that it recursively clones `value`.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Lang
       * @param {*} value The value to recursively clone.
       * @returns {*} Returns the deep cloned value.
       * @see _.clone
       * @example
       *
       * var objects = [{ 'a': 1 }, { 'b': 2 }];
       *
       * var deep = _.cloneDeep(objects);
       * console.log(deep[0] === objects[0]);
       * // => false
       */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
       * This method is like `_.cloneWith` except that it recursively clones `value`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to recursively clone.
       * @param {Function} [customizer] The function to customize cloning.
       * @returns {*} Returns the deep cloned value.
       * @see _.cloneWith
       * @example
       *
       * function customizer(value) {
       *   if (_.isElement(value)) {
       *     return value.cloneNode(true);
       *   }
       * }
       *
       * var el = _.cloneDeepWith(document.body, customizer);
       *
       * console.log(el === document.body);
       * // => false
       * console.log(el.nodeName);
       * // => 'BODY'
       * console.log(el.childNodes.length);
       * // => 20
       */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
       * Checks if `object` conforms to `source` by invoking the predicate
       * properties of `source` with the corresponding property values of `object`.
       *
       * **Note:** This method is equivalent to `_.conforms` when `source` is
       * partially applied.
       *
       * @static
       * @memberOf _
       * @since 4.14.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property predicates to conform to.
       * @returns {boolean} Returns `true` if `object` conforms, else `false`.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       *
       * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
       * // => true
       *
       * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
       * // => false
       */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
       * Performs a
       * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
       * comparison between two values to determine if they are equivalent.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.eq(object, object);
       * // => true
       *
       * _.eq(object, other);
       * // => false
       *
       * _.eq('a', 'a');
       * // => true
       *
       * _.eq('a', Object('a'));
       * // => false
       *
       * _.eq(NaN, NaN);
       * // => true
       */function eq(value,other){return value===other||value!==value&&other!==other;}/**
       * Checks if `value` is greater than `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than `other`,
       *  else `false`.
       * @see _.lt
       * @example
       *
       * _.gt(3, 1);
       * // => true
       *
       * _.gt(3, 3);
       * // => false
       *
       * _.gt(1, 3);
       * // => false
       */var gt=createRelationalOperation(baseGt);/**
       * Checks if `value` is greater than or equal to `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is greater than or equal to
       *  `other`, else `false`.
       * @see _.lte
       * @example
       *
       * _.gte(3, 1);
       * // => true
       *
       * _.gte(3, 3);
       * // => true
       *
       * _.gte(1, 3);
       * // => false
       */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
       * Checks if `value` is likely an `arguments` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an `arguments` object,
       *  else `false`.
       * @example
       *
       * _.isArguments(function() { return arguments; }());
       * // => true
       *
       * _.isArguments([1, 2, 3]);
       * // => false
       */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
       * Checks if `value` is classified as an `Array` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array, else `false`.
       * @example
       *
       * _.isArray([1, 2, 3]);
       * // => true
       *
       * _.isArray(document.body.children);
       * // => false
       *
       * _.isArray('abc');
       * // => false
       *
       * _.isArray(_.noop);
       * // => false
       */var isArray=Array.isArray;/**
       * Checks if `value` is classified as an `ArrayBuffer` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
       * @example
       *
       * _.isArrayBuffer(new ArrayBuffer(2));
       * // => true
       *
       * _.isArrayBuffer(new Array(2));
       * // => false
       */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
       * Checks if `value` is array-like. A value is considered array-like if it's
       * not a function and has a `value.length` that's an integer greater than or
       * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
       * @example
       *
       * _.isArrayLike([1, 2, 3]);
       * // => true
       *
       * _.isArrayLike(document.body.children);
       * // => true
       *
       * _.isArrayLike('abc');
       * // => true
       *
       * _.isArrayLike(_.noop);
       * // => false
       */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
       * This method is like `_.isArrayLike` except that it also checks if `value`
       * is an object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an array-like object,
       *  else `false`.
       * @example
       *
       * _.isArrayLikeObject([1, 2, 3]);
       * // => true
       *
       * _.isArrayLikeObject(document.body.children);
       * // => true
       *
       * _.isArrayLikeObject('abc');
       * // => false
       *
       * _.isArrayLikeObject(_.noop);
       * // => false
       */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
       * Checks if `value` is classified as a boolean primitive or object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
       * @example
       *
       * _.isBoolean(false);
       * // => true
       *
       * _.isBoolean(null);
       * // => false
       */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
       * Checks if `value` is a buffer.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
       * @example
       *
       * _.isBuffer(new Buffer(2));
       * // => true
       *
       * _.isBuffer(new Uint8Array(2));
       * // => false
       */var isBuffer=nativeIsBuffer||stubFalse;/**
       * Checks if `value` is classified as a `Date` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
       * @example
       *
       * _.isDate(new Date);
       * // => true
       *
       * _.isDate('Mon April 23 2012');
       * // => false
       */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
       * Checks if `value` is likely a DOM element.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
       * @example
       *
       * _.isElement(document.body);
       * // => true
       *
       * _.isElement('<body>');
       * // => false
       */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
       * Checks if `value` is an empty object, collection, map, or set.
       *
       * Objects are considered empty if they have no own enumerable string keyed
       * properties.
       *
       * Array-like values such as `arguments` objects, arrays, buffers, strings, or
       * jQuery-like collections are considered empty if they have a `length` of `0`.
       * Similarly, maps and sets are considered empty if they have a `size` of `0`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is empty, else `false`.
       * @example
       *
       * _.isEmpty(null);
       * // => true
       *
       * _.isEmpty(true);
       * // => true
       *
       * _.isEmpty(1);
       * // => true
       *
       * _.isEmpty([1, 2, 3]);
       * // => false
       *
       * _.isEmpty({ 'a': 1 });
       * // => false
       */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return !value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return !value.size;}if(isPrototype(value)){return !baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
       * Performs a deep comparison between two values to determine if they are
       * equivalent.
       *
       * **Note:** This method supports comparing arrays, array buffers, booleans,
       * date objects, error objects, maps, numbers, `Object` objects, regexes,
       * sets, strings, symbols, and typed arrays. `Object` objects are compared
       * by their own, not inherited, enumerable properties. Functions and DOM
       * nodes are compared by strict equality, i.e. `===`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * var object = { 'a': 1 };
       * var other = { 'a': 1 };
       *
       * _.isEqual(object, other);
       * // => true
       *
       * object === other;
       * // => false
       */function isEqual(value,other){return baseIsEqual(value,other);}/**
       * This method is like `_.isEqual` except that it accepts `customizer` which
       * is invoked to compare values. If `customizer` returns `undefined`, comparisons
       * are handled by the method instead. The `customizer` is invoked with up to
       * six arguments: (objValue, othValue [, index|key, object, other, stack]).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
       * @example
       *
       * function isGreeting(value) {
       *   return /^h(?:i|ello)$/.test(value);
       * }
       *
       * function customizer(objValue, othValue) {
       *   if (isGreeting(objValue) && isGreeting(othValue)) {
       *     return true;
       *   }
       * }
       *
       * var array = ['hello', 'goodbye'];
       * var other = ['hi', 'goodbye'];
       *
       * _.isEqualWith(array, other, customizer);
       * // => true
       */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;var result=customizer?customizer(value,other):undefined$1;return result===undefined$1?baseIsEqual(value,other,undefined$1,customizer):!!result;}/**
       * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
       * `SyntaxError`, `TypeError`, or `URIError` object.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
       * @example
       *
       * _.isError(new Error);
       * // => true
       *
       * _.isError(Error);
       * // => false
       */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
       * Checks if `value` is a finite primitive number.
       *
       * **Note:** This method is based on
       * [`Number.isFinite`](https://mdn.io/Number/isFinite).
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
       * @example
       *
       * _.isFinite(3);
       * // => true
       *
       * _.isFinite(Number.MIN_VALUE);
       * // => true
       *
       * _.isFinite(Infinity);
       * // => false
       *
       * _.isFinite('3');
       * // => false
       */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
       * Checks if `value` is classified as a `Function` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a function, else `false`.
       * @example
       *
       * _.isFunction(_);
       * // => true
       *
       * _.isFunction(/abc/);
       * // => false
       */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
       * Checks if `value` is an integer.
       *
       * **Note:** This method is based on
       * [`Number.isInteger`](https://mdn.io/Number/isInteger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
       * @example
       *
       * _.isInteger(3);
       * // => true
       *
       * _.isInteger(Number.MIN_VALUE);
       * // => false
       *
       * _.isInteger(Infinity);
       * // => false
       *
       * _.isInteger('3');
       * // => false
       */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
       * Checks if `value` is a valid array-like length.
       *
       * **Note:** This method is loosely based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
       * @example
       *
       * _.isLength(3);
       * // => true
       *
       * _.isLength(Number.MIN_VALUE);
       * // => false
       *
       * _.isLength(Infinity);
       * // => false
       *
       * _.isLength('3');
       * // => false
       */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
       * Checks if `value` is the
       * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
       * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is an object, else `false`.
       * @example
       *
       * _.isObject({});
       * // => true
       *
       * _.isObject([1, 2, 3]);
       * // => true
       *
       * _.isObject(_.noop);
       * // => true
       *
       * _.isObject(null);
       * // => false
       */function isObject(value){var type=_typeof$1(value);return value!=null&&(type=='object'||type=='function');}/**
       * Checks if `value` is object-like. A value is object-like if it's not `null`
       * and has a `typeof` result of "object".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
       * @example
       *
       * _.isObjectLike({});
       * // => true
       *
       * _.isObjectLike([1, 2, 3]);
       * // => true
       *
       * _.isObjectLike(_.noop);
       * // => false
       *
       * _.isObjectLike(null);
       * // => false
       */function isObjectLike(value){return value!=null&&_typeof$1(value)=='object';}/**
       * Checks if `value` is classified as a `Map` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a map, else `false`.
       * @example
       *
       * _.isMap(new Map);
       * // => true
       *
       * _.isMap(new WeakMap);
       * // => false
       */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
       * Performs a partial deep comparison between `object` and `source` to
       * determine if `object` contains equivalent property values.
       *
       * **Note:** This method is equivalent to `_.matches` when `source` is
       * partially applied.
       *
       * Partial comparisons will match empty array and empty object `source`
       * values against any array or object value, respectively. See `_.isEqual`
       * for a list of supported value comparisons.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       * @example
       *
       * var object = { 'a': 1, 'b': 2 };
       *
       * _.isMatch(object, { 'b': 2 });
       * // => true
       *
       * _.isMatch(object, { 'b': 1 });
       * // => false
       */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
       * This method is like `_.isMatch` except that it accepts `customizer` which
       * is invoked to compare values. If `customizer` returns `undefined`, comparisons
       * are handled by the method instead. The `customizer` is invoked with five
       * arguments: (objValue, srcValue, index|key, object, source).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {Object} object The object to inspect.
       * @param {Object} source The object of property values to match.
       * @param {Function} [customizer] The function to customize comparisons.
       * @returns {boolean} Returns `true` if `object` is a match, else `false`.
       * @example
       *
       * function isGreeting(value) {
       *   return /^h(?:i|ello)$/.test(value);
       * }
       *
       * function customizer(objValue, srcValue) {
       *   if (isGreeting(objValue) && isGreeting(srcValue)) {
       *     return true;
       *   }
       * }
       *
       * var object = { 'greeting': 'hello' };
       * var source = { 'greeting': 'hi' };
       *
       * _.isMatchWith(object, source, customizer);
       * // => true
       */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
       * Checks if `value` is `NaN`.
       *
       * **Note:** This method is based on
       * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
       * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
       * `undefined` and other non-number values.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
       * @example
       *
       * _.isNaN(NaN);
       * // => true
       *
       * _.isNaN(new Number(NaN));
       * // => true
       *
       * isNaN(undefined);
       * // => true
       *
       * _.isNaN(undefined);
       * // => false
       */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
  // Perform the `toStringTag` check first to avoid errors with some
  // ActiveX objects in IE.
  return isNumber(value)&&value!=+value;}/**
       * Checks if `value` is a pristine native function.
       *
       * **Note:** This method can't reliably detect native functions in the presence
       * of the core-js package because core-js circumvents this kind of detection.
       * Despite multiple requests, the core-js maintainer has made it clear: any
       * attempt to fix the detection will be obstructed. As a result, we're left
       * with little choice but to throw an error. Unfortunately, this also affects
       * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
       * which rely on core-js.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a native function,
       *  else `false`.
       * @example
       *
       * _.isNative(Array.prototype.push);
       * // => true
       *
       * _.isNative(_);
       * // => false
       */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
       * Checks if `value` is `null`.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
       * @example
       *
       * _.isNull(null);
       * // => true
       *
       * _.isNull(void 0);
       * // => false
       */function isNull(value){return value===null;}/**
       * Checks if `value` is `null` or `undefined`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
       * @example
       *
       * _.isNil(null);
       * // => true
       *
       * _.isNil(void 0);
       * // => true
       *
       * _.isNil(NaN);
       * // => false
       */function isNil(value){return value==null;}/**
       * Checks if `value` is classified as a `Number` primitive or object.
       *
       * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
       * classified as numbers, use the `_.isFinite` method.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a number, else `false`.
       * @example
       *
       * _.isNumber(3);
       * // => true
       *
       * _.isNumber(Number.MIN_VALUE);
       * // => true
       *
       * _.isNumber(Infinity);
       * // => true
       *
       * _.isNumber('3');
       * // => false
       */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
       * Checks if `value` is a plain object, that is, an object created by the
       * `Object` constructor or one with a `[[Prototype]]` of `null`.
       *
       * @static
       * @memberOf _
       * @since 0.8.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * _.isPlainObject(new Foo);
       * // => false
       *
       * _.isPlainObject([1, 2, 3]);
       * // => false
       *
       * _.isPlainObject({ 'x': 0, 'y': 0 });
       * // => true
       *
       * _.isPlainObject(Object.create(null));
       * // => true
       */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
       * Checks if `value` is classified as a `RegExp` object.
       *
       * @static
       * @memberOf _
       * @since 0.1.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
       * @example
       *
       * _.isRegExp(/abc/);
       * // => true
       *
       * _.isRegExp('/abc/');
       * // => false
       */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
       * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
       * double precision number which isn't the result of a rounded unsafe integer.
       *
       * **Note:** This method is based on
       * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
       * @example
       *
       * _.isSafeInteger(3);
       * // => true
       *
       * _.isSafeInteger(Number.MIN_VALUE);
       * // => false
       *
       * _.isSafeInteger(Infinity);
       * // => false
       *
       * _.isSafeInteger('3');
       * // => false
       */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
       * Checks if `value` is classified as a `Set` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a set, else `false`.
       * @example
       *
       * _.isSet(new Set);
       * // => true
       *
       * _.isSet(new WeakSet);
       * // => false
       */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
       * Checks if `value` is classified as a `String` primitive or object.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a string, else `false`.
       * @example
       *
       * _.isString('abc');
       * // => true
       *
       * _.isString(1);
       * // => false
       */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
       * Checks if `value` is classified as a `Symbol` primitive or object.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
       * @example
       *
       * _.isSymbol(Symbol.iterator);
       * // => true
       *
       * _.isSymbol('abc');
       * // => false
       */function isSymbol(value){return _typeof$1(value)=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
       * Checks if `value` is classified as a typed array.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
       * @example
       *
       * _.isTypedArray(new Uint8Array);
       * // => true
       *
       * _.isTypedArray([]);
       * // => false
       */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
       * Checks if `value` is `undefined`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
       * @example
       *
       * _.isUndefined(void 0);
       * // => true
       *
       * _.isUndefined(null);
       * // => false
       */function isUndefined(value){return value===undefined$1;}/**
       * Checks if `value` is classified as a `WeakMap` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
       * @example
       *
       * _.isWeakMap(new WeakMap);
       * // => true
       *
       * _.isWeakMap(new Map);
       * // => false
       */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
       * Checks if `value` is classified as a `WeakSet` object.
       *
       * @static
       * @memberOf _
       * @since 4.3.0
       * @category Lang
       * @param {*} value The value to check.
       * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
       * @example
       *
       * _.isWeakSet(new WeakSet);
       * // => true
       *
       * _.isWeakSet(new Set);
       * // => false
       */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
       * Checks if `value` is less than `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than `other`,
       *  else `false`.
       * @see _.gt
       * @example
       *
       * _.lt(1, 3);
       * // => true
       *
       * _.lt(3, 3);
       * // => false
       *
       * _.lt(3, 1);
       * // => false
       */var lt=createRelationalOperation(baseLt);/**
       * Checks if `value` is less than or equal to `other`.
       *
       * @static
       * @memberOf _
       * @since 3.9.0
       * @category Lang
       * @param {*} value The value to compare.
       * @param {*} other The other value to compare.
       * @returns {boolean} Returns `true` if `value` is less than or equal to
       *  `other`, else `false`.
       * @see _.gte
       * @example
       *
       * _.lte(1, 3);
       * // => true
       *
       * _.lte(3, 3);
       * // => true
       *
       * _.lte(3, 1);
       * // => false
       */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
       * Converts `value` to an array.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {Array} Returns the converted array.
       * @example
       *
       * _.toArray({ 'a': 1, 'b': 2 });
       * // => [1, 2]
       *
       * _.toArray('abc');
       * // => ['a', 'b', 'c']
       *
       * _.toArray(1);
       * // => []
       *
       * _.toArray(null);
       * // => []
       */function toArray(value){if(!value){return [];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
       * Converts `value` to a finite number.
       *
       * @static
       * @memberOf _
       * @since 4.12.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted number.
       * @example
       *
       * _.toFinite(3.2);
       * // => 3.2
       *
       * _.toFinite(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toFinite(Infinity);
       * // => 1.7976931348623157e+308
       *
       * _.toFinite('3.2');
       * // => 3.2
       */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
       * Converts `value` to an integer.
       *
       * **Note:** This method is loosely based on
       * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toInteger(3.2);
       * // => 3
       *
       * _.toInteger(Number.MIN_VALUE);
       * // => 0
       *
       * _.toInteger(Infinity);
       * // => 1.7976931348623157e+308
       *
       * _.toInteger('3.2');
       * // => 3
       */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
       * Converts `value` to an integer suitable for use as the length of an
       * array-like object.
       *
       * **Note:** This method is based on
       * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toLength(3.2);
       * // => 3
       *
       * _.toLength(Number.MIN_VALUE);
       * // => 0
       *
       * _.toLength(Infinity);
       * // => 4294967295
       *
       * _.toLength('3.2');
       * // => 3
       */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
       * Converts `value` to a number.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to process.
       * @returns {number} Returns the number.
       * @example
       *
       * _.toNumber(3.2);
       * // => 3.2
       *
       * _.toNumber(Number.MIN_VALUE);
       * // => 5e-324
       *
       * _.toNumber(Infinity);
       * // => Infinity
       *
       * _.toNumber('3.2');
       * // => 3.2
       */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=baseTrim(value);var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
       * Converts `value` to a plain object flattening inherited enumerable string
       * keyed properties of `value` to own properties of the plain object.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {Object} Returns the converted plain object.
       * @example
       *
       * function Foo() {
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.assign({ 'a': 1 }, new Foo);
       * // => { 'a': 1, 'b': 2 }
       *
       * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
       * // => { 'a': 1, 'b': 2, 'c': 3 }
       */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
       * Converts `value` to a safe integer. A safe integer can be compared and
       * represented correctly.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.toSafeInteger(3.2);
       * // => 3
       *
       * _.toSafeInteger(Number.MIN_VALUE);
       * // => 0
       *
       * _.toSafeInteger(Infinity);
       * // => 9007199254740991
       *
       * _.toSafeInteger('3.2');
       * // => 3
       */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
       * Converts `value` to a string. An empty string is returned for `null`
       * and `undefined` values. The sign of `-0` is preserved.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Lang
       * @param {*} value The value to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.toString(null);
       * // => ''
       *
       * _.toString(-0);
       * // => '-0'
       *
       * _.toString([1, 2, 3]);
       * // => '1,2,3'
       */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
       * Assigns own enumerable string keyed properties of source objects to the
       * destination object. Source objects are applied from left to right.
       * Subsequent sources overwrite property assignments of previous sources.
       *
       * **Note:** This method mutates `object` and is loosely based on
       * [`Object.assign`](https://mdn.io/Object/assign).
       *
       * @static
       * @memberOf _
       * @since 0.10.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.assignIn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * function Bar() {
       *   this.c = 3;
       * }
       *
       * Foo.prototype.b = 2;
       * Bar.prototype.d = 4;
       *
       * _.assign({ 'a': 0 }, new Foo, new Bar);
       * // => { 'a': 1, 'c': 3 }
       */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
       * This method is like `_.assign` except that it iterates over own and
       * inherited source properties.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias extend
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.assign
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       * }
       *
       * function Bar() {
       *   this.c = 3;
       * }
       *
       * Foo.prototype.b = 2;
       * Bar.prototype.d = 4;
       *
       * _.assignIn({ 'a': 0 }, new Foo, new Bar);
       * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
       */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
       * This method is like `_.assignIn` except that it accepts `customizer`
       * which is invoked to produce the assigned values. If `customizer` returns
       * `undefined`, assignment is handled by the method instead. The `customizer`
       * is invoked with five arguments: (objValue, srcValue, key, object, source).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias extendWith
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @see _.assignWith
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   return _.isUndefined(objValue) ? srcValue : objValue;
       * }
       *
       * var defaults = _.partialRight(_.assignInWith, customizer);
       *
       * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
       * This method is like `_.assign` except that it accepts `customizer`
       * which is invoked to produce the assigned values. If `customizer` returns
       * `undefined`, assignment is handled by the method instead. The `customizer`
       * is invoked with five arguments: (objValue, srcValue, key, object, source).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @see _.assignInWith
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   return _.isUndefined(objValue) ? srcValue : objValue;
       * }
       *
       * var defaults = _.partialRight(_.assignWith, customizer);
       *
       * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
       * Creates an array of values corresponding to `paths` of `object`.
       *
       * @static
       * @memberOf _
       * @since 1.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Array} Returns the picked values.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
       *
       * _.at(object, ['a[0].b.c', 'a[1]']);
       * // => [3, 4]
       */var at=flatRest(baseAt);/**
       * Creates an object that inherits from the `prototype` object. If a
       * `properties` object is given, its own enumerable string keyed properties
       * are assigned to the created object.
       *
       * @static
       * @memberOf _
       * @since 2.3.0
       * @category Object
       * @param {Object} prototype The object to inherit from.
       * @param {Object} [properties] The properties to assign to the object.
       * @returns {Object} Returns the new object.
       * @example
       *
       * function Shape() {
       *   this.x = 0;
       *   this.y = 0;
       * }
       *
       * function Circle() {
       *   Shape.call(this);
       * }
       *
       * Circle.prototype = _.create(Shape.prototype, {
       *   'constructor': Circle
       * });
       *
       * var circle = new Circle;
       * circle instanceof Circle;
       * // => true
       *
       * circle instanceof Shape;
       * // => true
       */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
       * Assigns own and inherited enumerable string keyed properties of source
       * objects to the destination object for all destination properties that
       * resolve to `undefined`. Source objects are applied from left to right.
       * Once a property is set, additional values of the same property are ignored.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.defaultsDeep
       * @example
       *
       * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
       * // => { 'a': 1, 'b': 2 }
       */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined$1;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined$1||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
       * This method is like `_.defaults` except that it recursively assigns
       * default properties.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @see _.defaults
       * @example
       *
       * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
       * // => { 'a': { 'b': 2, 'c': 3 } }
       */var defaultsDeep=baseRest(function(args){args.push(undefined$1,customDefaultsMerge);return apply(mergeWith,undefined$1,args);});/**
       * This method is like `_.find` except that it returns the key of the first
       * element `predicate` returns truthy for instead of the element itself.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {string|undefined} Returns the key of the matched element,
       *  else `undefined`.
       * @example
       *
       * var users = {
       *   'barney':  { 'age': 36, 'active': true },
       *   'fred':    { 'age': 40, 'active': false },
       *   'pebbles': { 'age': 1,  'active': true }
       * };
       *
       * _.findKey(users, function(o) { return o.age < 40; });
       * // => 'barney' (iteration order is not guaranteed)
       *
       * // The `_.matches` iteratee shorthand.
       * _.findKey(users, { 'age': 1, 'active': true });
       * // => 'pebbles'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findKey(users, ['active', false]);
       * // => 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.findKey(users, 'active');
       * // => 'barney'
       */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
       * This method is like `_.findKey` except that it iterates over elements of
       * a collection in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @param {Function} [predicate=_.identity] The function invoked per iteration.
       * @returns {string|undefined} Returns the key of the matched element,
       *  else `undefined`.
       * @example
       *
       * var users = {
       *   'barney':  { 'age': 36, 'active': true },
       *   'fred':    { 'age': 40, 'active': false },
       *   'pebbles': { 'age': 1,  'active': true }
       * };
       *
       * _.findLastKey(users, function(o) { return o.age < 40; });
       * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
       *
       * // The `_.matches` iteratee shorthand.
       * _.findLastKey(users, { 'age': 36, 'active': true });
       * // => 'barney'
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.findLastKey(users, ['active', false]);
       * // => 'fred'
       *
       * // The `_.property` iteratee shorthand.
       * _.findLastKey(users, 'active');
       * // => 'pebbles'
       */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
       * Iterates over own and inherited enumerable string keyed properties of an
       * object and invokes `iteratee` for each property. The iteratee is invoked
       * with three arguments: (value, key, object). Iteratee functions may exit
       * iteration early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 0.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forInRight
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forIn(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
       */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
       * This method is like `_.forIn` except that it iterates over properties of
       * `object` in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forIn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forInRight(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
       */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
       * Iterates over own enumerable string keyed properties of an object and
       * invokes `iteratee` for each property. The iteratee is invoked with three
       * arguments: (value, key, object). Iteratee functions may exit iteration
       * early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 0.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forOwnRight
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forOwn(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'a' then 'b' (iteration order is not guaranteed).
       */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
       * This method is like `_.forOwn` except that it iterates over properties of
       * `object` in the opposite order.
       *
       * @static
       * @memberOf _
       * @since 2.0.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns `object`.
       * @see _.forOwn
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.forOwnRight(new Foo, function(value, key) {
       *   console.log(key);
       * });
       * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
       */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
       * Creates an array of function property names from own enumerable properties
       * of `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the function names.
       * @see _.functionsIn
       * @example
       *
       * function Foo() {
       *   this.a = _.constant('a');
       *   this.b = _.constant('b');
       * }
       *
       * Foo.prototype.c = _.constant('c');
       *
       * _.functions(new Foo);
       * // => ['a', 'b']
       */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
       * Creates an array of function property names from own and inherited
       * enumerable properties of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to inspect.
       * @returns {Array} Returns the function names.
       * @see _.functions
       * @example
       *
       * function Foo() {
       *   this.a = _.constant('a');
       *   this.b = _.constant('b');
       * }
       *
       * Foo.prototype.c = _.constant('c');
       *
       * _.functionsIn(new Foo);
       * // => ['a', 'b', 'c']
       */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
       * Gets the value at `path` of `object`. If the resolved value is
       * `undefined`, the `defaultValue` is returned in its place.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to get.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.get(object, 'a[0].b.c');
       * // => 3
       *
       * _.get(object, ['a', '0', 'b', 'c']);
       * // => 3
       *
       * _.get(object, 'a.b.c', 'default');
       * // => 'default'
       */function get(object,path,defaultValue){var result=object==null?undefined$1:baseGet(object,path);return result===undefined$1?defaultValue:result;}/**
       * Checks if `path` is a direct property of `object`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       * @example
       *
       * var object = { 'a': { 'b': 2 } };
       * var other = _.create({ 'a': _.create({ 'b': 2 }) });
       *
       * _.has(object, 'a');
       * // => true
       *
       * _.has(object, 'a.b');
       * // => true
       *
       * _.has(object, ['a', 'b']);
       * // => true
       *
       * _.has(other, 'a');
       * // => false
       */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
       * Checks if `path` is a direct or inherited property of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path to check.
       * @returns {boolean} Returns `true` if `path` exists, else `false`.
       * @example
       *
       * var object = _.create({ 'a': _.create({ 'b': 2 }) });
       *
       * _.hasIn(object, 'a');
       * // => true
       *
       * _.hasIn(object, 'a.b');
       * // => true
       *
       * _.hasIn(object, ['a', 'b']);
       * // => true
       *
       * _.hasIn(object, 'b');
       * // => false
       */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
       * Creates an object composed of the inverted keys and values of `object`.
       * If `object` contains duplicate values, subsequent values overwrite
       * property assignments of previous values.
       *
       * @static
       * @memberOf _
       * @since 0.7.0
       * @category Object
       * @param {Object} object The object to invert.
       * @returns {Object} Returns the new inverted object.
       * @example
       *
       * var object = { 'a': 1, 'b': 2, 'c': 1 };
       *
       * _.invert(object);
       * // => { '1': 'c', '2': 'b' }
       */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
       * This method is like `_.invert` except that the inverted object is generated
       * from the results of running each element of `object` thru `iteratee`. The
       * corresponding inverted value of each inverted key is an array of keys
       * responsible for generating the inverted value. The iteratee is invoked
       * with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.1.0
       * @category Object
       * @param {Object} object The object to invert.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {Object} Returns the new inverted object.
       * @example
       *
       * var object = { 'a': 1, 'b': 2, 'c': 1 };
       *
       * _.invertBy(object);
       * // => { '1': ['a', 'c'], '2': ['b'] }
       *
       * _.invertBy(object, function(value) {
       *   return 'group' + value;
       * });
       * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
       */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else {result[value]=[key];}},getIteratee);/**
       * Invokes the method at `path` of `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the method to invoke.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {*} Returns the result of the invoked method.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
       *
       * _.invoke(object, 'a[0].b.c.slice', 1, 3);
       * // => [2, 3]
       */var invoke=baseRest(baseInvoke);/**
       * Creates an array of the own enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects. See the
       * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
       * for more details.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keys(new Foo);
       * // => ['a', 'b'] (iteration order is not guaranteed)
       *
       * _.keys('hi');
       * // => ['0', '1']
       */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
       * Creates an array of the own and inherited enumerable property names of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property names.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.keysIn(new Foo);
       * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
       */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
       * The opposite of `_.mapValues`; this method creates an object with the
       * same values as `object` and keys generated by running each own enumerable
       * string keyed property of `object` thru `iteratee`. The iteratee is invoked
       * with three arguments: (value, key, object).
       *
       * @static
       * @memberOf _
       * @since 3.8.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns the new mapped object.
       * @see _.mapValues
       * @example
       *
       * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
       *   return key + value;
       * });
       * // => { 'a1': 1, 'b2': 2 }
       */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
       * Creates an object with the same keys as `object` and values generated
       * by running each own enumerable string keyed property of `object` thru
       * `iteratee`. The iteratee is invoked with three arguments:
       * (value, key, object).
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Object} Returns the new mapped object.
       * @see _.mapKeys
       * @example
       *
       * var users = {
       *   'fred':    { 'user': 'fred',    'age': 40 },
       *   'pebbles': { 'user': 'pebbles', 'age': 1 }
       * };
       *
       * _.mapValues(users, function(o) { return o.age; });
       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
       *
       * // The `_.property` iteratee shorthand.
       * _.mapValues(users, 'age');
       * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
       */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
       * This method is like `_.assign` except that it recursively merges own and
       * inherited enumerable string keyed properties of source objects into the
       * destination object. Source properties that resolve to `undefined` are
       * skipped if a destination value exists. Array and plain object properties
       * are merged recursively. Other objects and value types are overridden by
       * assignment. Source objects are applied from left to right. Subsequent
       * sources overwrite property assignments of previous sources.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 0.5.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} [sources] The source objects.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {
       *   'a': [{ 'b': 2 }, { 'd': 4 }]
       * };
       *
       * var other = {
       *   'a': [{ 'c': 3 }, { 'e': 5 }]
       * };
       *
       * _.merge(object, other);
       * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
       */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
       * This method is like `_.merge` except that it accepts `customizer` which
       * is invoked to produce the merged values of the destination and source
       * properties. If `customizer` returns `undefined`, merging is handled by the
       * method instead. The `customizer` is invoked with six arguments:
       * (objValue, srcValue, key, object, source, stack).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The destination object.
       * @param {...Object} sources The source objects.
       * @param {Function} customizer The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * function customizer(objValue, srcValue) {
       *   if (_.isArray(objValue)) {
       *     return objValue.concat(srcValue);
       *   }
       * }
       *
       * var object = { 'a': [1], 'b': [2] };
       * var other = { 'a': [3], 'b': [4] };
       *
       * _.mergeWith(object, other, customizer);
       * // => { 'a': [1, 3], 'b': [2, 4] }
       */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
       * The opposite of `_.pick`; this method creates an object composed of the
       * own and inherited enumerable property paths of `object` that are not omitted.
       *
       * **Note:** This method is considerably slower than `_.pick`.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The source object.
       * @param {...(string|string[])} [paths] The property paths to omit.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.omit(object, ['a', 'c']);
       * // => { 'b': '2' }
       */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
       * The opposite of `_.pickBy`; this method creates an object composed of
       * the own and inherited enumerable string keyed properties of `object` that
       * `predicate` doesn't return truthy for. The predicate is invoked with two
       * arguments: (value, key).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The source object.
       * @param {Function} [predicate=_.identity] The function invoked per property.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.omitBy(object, _.isNumber);
       * // => { 'b': '2' }
       */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
       * Creates an object composed of the picked `object` properties.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The source object.
       * @param {...(string|string[])} [paths] The property paths to pick.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.pick(object, ['a', 'c']);
       * // => { 'a': 1, 'c': 3 }
       */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
       * Creates an object composed of the `object` properties `predicate` returns
       * truthy for. The predicate is invoked with two arguments: (value, key).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The source object.
       * @param {Function} [predicate=_.identity] The function invoked per property.
       * @returns {Object} Returns the new object.
       * @example
       *
       * var object = { 'a': 1, 'b': '2', 'c': 3 };
       *
       * _.pickBy(object, _.isNumber);
       * // => { 'a': 1, 'c': 3 }
       */function pickBy(object,predicate){if(object==null){return {};}var props=arrayMap(getAllKeysIn(object),function(prop){return [prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
       * This method is like `_.get` except that if the resolved value is a
       * function it's invoked with the `this` binding of its parent object and
       * its result is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @param {Array|string} path The path of the property to resolve.
       * @param {*} [defaultValue] The value returned for `undefined` resolved values.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
       *
       * _.result(object, 'a[0].b.c1');
       * // => 3
       *
       * _.result(object, 'a[0].b.c2');
       * // => 4
       *
       * _.result(object, 'a[0].b.c3', 'default');
       * // => 'default'
       *
       * _.result(object, 'a[0].b.c3', _.constant('default'));
       * // => 'default'
       */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
  if(!length){length=1;object=undefined$1;}while(++index<length){var value=object==null?undefined$1:object[toKey(path[index])];if(value===undefined$1){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
       * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
       * it's created. Arrays are created for missing index properties while objects
       * are created for all other missing properties. Use `_.setWith` to customize
       * `path` creation.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.set(object, 'a[0].b.c', 4);
       * console.log(object.a[0].b.c);
       * // => 4
       *
       * _.set(object, ['x', '0', 'y', 'z'], 5);
       * console.log(object.x[0].y.z);
       * // => 5
       */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
       * This method is like `_.set` except that it accepts `customizer` which is
       * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
       * path creation is handled by the method instead. The `customizer` is invoked
       * with three arguments: (nsValue, key, nsObject).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {*} value The value to set.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {};
       *
       * _.setWith(object, '[0][1]', 'a', Object);
       * // => { '0': { '1': 'a' } }
       */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return object==null?object:baseSet(object,path,value,customizer);}/**
       * Creates an array of own enumerable string keyed-value pairs for `object`
       * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
       * entries are returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias entries
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the key-value pairs.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.toPairs(new Foo);
       * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
       */var toPairs=createToPairs(keys);/**
       * Creates an array of own and inherited enumerable string keyed-value pairs
       * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
       * or set, its entries are returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @alias entriesIn
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the key-value pairs.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.toPairsIn(new Foo);
       * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
       */var toPairsIn=createToPairs(keysIn);/**
       * An alternative to `_.reduce`; this method transforms `object` to a new
       * `accumulator` object which is the result of running each of its own
       * enumerable string keyed properties thru `iteratee`, with each invocation
       * potentially mutating the `accumulator` object. If `accumulator` is not
       * provided, a new object with the same `[[Prototype]]` will be used. The
       * iteratee is invoked with four arguments: (accumulator, value, key, object).
       * Iteratee functions may exit iteration early by explicitly returning `false`.
       *
       * @static
       * @memberOf _
       * @since 1.3.0
       * @category Object
       * @param {Object} object The object to iterate over.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @param {*} [accumulator] The custom accumulator value.
       * @returns {*} Returns the accumulated value.
       * @example
       *
       * _.transform([2, 3, 4], function(result, n) {
       *   result.push(n *= n);
       *   return n % 2 == 0;
       * }, []);
       * // => [4, 9]
       *
       * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
       *   (result[value] || (result[value] = [])).push(key);
       * }, {});
       * // => { '1': ['a', 'c'], '2': ['b'] }
       */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else {accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
       * Removes the property at `path` of `object`.
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to unset.
       * @returns {boolean} Returns `true` if the property is deleted, else `false`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 7 } }] };
       * _.unset(object, 'a[0].b.c');
       * // => true
       *
       * console.log(object);
       * // => { 'a': [{ 'b': {} }] };
       *
       * _.unset(object, ['a', '0', 'b', 'c']);
       * // => true
       *
       * console.log(object);
       * // => { 'a': [{ 'b': {} }] };
       */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
       * This method is like `_.set` except that accepts `updater` to produce the
       * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
       * is invoked with one argument: (value).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {Function} updater The function to produce the updated value.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = { 'a': [{ 'b': { 'c': 3 } }] };
       *
       * _.update(object, 'a[0].b.c', function(n) { return n * n; });
       * console.log(object.a[0].b.c);
       * // => 9
       *
       * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
       * console.log(object.x[0].y.z);
       * // => 0
       */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
       * This method is like `_.update` except that it accepts `customizer` which is
       * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
       * path creation is handled by the method instead. The `customizer` is invoked
       * with three arguments: (nsValue, key, nsObject).
       *
       * **Note:** This method mutates `object`.
       *
       * @static
       * @memberOf _
       * @since 4.6.0
       * @category Object
       * @param {Object} object The object to modify.
       * @param {Array|string} path The path of the property to set.
       * @param {Function} updater The function to produce the updated value.
       * @param {Function} [customizer] The function to customize assigned values.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var object = {};
       *
       * _.updateWith(object, '[0][1]', _.constant('a'), Object);
       * // => { '0': { '1': 'a' } }
       */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
       * Creates an array of the own enumerable string keyed property values of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property values.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.values(new Foo);
       * // => [1, 2] (iteration order is not guaranteed)
       *
       * _.values('hi');
       * // => ['h', 'i']
       */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
       * Creates an array of the own and inherited enumerable string keyed property
       * values of `object`.
       *
       * **Note:** Non-object values are coerced to objects.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Object
       * @param {Object} object The object to query.
       * @returns {Array} Returns the array of property values.
       * @example
       *
       * function Foo() {
       *   this.a = 1;
       *   this.b = 2;
       * }
       *
       * Foo.prototype.c = 3;
       *
       * _.valuesIn(new Foo);
       * // => [1, 2, 3] (iteration order is not guaranteed)
       */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
       * Clamps `number` within the inclusive `lower` and `upper` bounds.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Number
       * @param {number} number The number to clamp.
       * @param {number} [lower] The lower bound.
       * @param {number} upper The upper bound.
       * @returns {number} Returns the clamped number.
       * @example
       *
       * _.clamp(-10, -5, 5);
       * // => -5
       *
       * _.clamp(10, -5, 5);
       * // => 5
       */function clamp(number,lower,upper){if(upper===undefined$1){upper=lower;lower=undefined$1;}if(upper!==undefined$1){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined$1){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
       * Checks if `n` is between `start` and up to, but not including, `end`. If
       * `end` is not specified, it's set to `start` with `start` then set to `0`.
       * If `start` is greater than `end` the params are swapped to support
       * negative ranges.
       *
       * @static
       * @memberOf _
       * @since 3.3.0
       * @category Number
       * @param {number} number The number to check.
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
       * @see _.range, _.rangeRight
       * @example
       *
       * _.inRange(3, 2, 4);
       * // => true
       *
       * _.inRange(4, 8);
       * // => true
       *
       * _.inRange(4, 2);
       * // => false
       *
       * _.inRange(2, 2);
       * // => false
       *
       * _.inRange(1.2, 2);
       * // => true
       *
       * _.inRange(5.2, 4);
       * // => false
       *
       * _.inRange(-3, -2, -6);
       * // => true
       */function inRange(number,start,end){start=toFinite(start);if(end===undefined$1){end=start;start=0;}else {end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
       * Produces a random number between the inclusive `lower` and `upper` bounds.
       * If only one argument is provided a number between `0` and the given number
       * is returned. If `floating` is `true`, or either `lower` or `upper` are
       * floats, a floating-point number is returned instead of an integer.
       *
       * **Note:** JavaScript follows the IEEE-754 standard for resolving
       * floating-point values which can produce unexpected results.
       *
       * @static
       * @memberOf _
       * @since 0.7.0
       * @category Number
       * @param {number} [lower=0] The lower bound.
       * @param {number} [upper=1] The upper bound.
       * @param {boolean} [floating] Specify returning a floating-point number.
       * @returns {number} Returns the random number.
       * @example
       *
       * _.random(0, 5);
       * // => an integer between 0 and 5
       *
       * _.random(5);
       * // => also an integer between 0 and 5
       *
       * _.random(5, true);
       * // => a floating-point number between 0 and 5
       *
       * _.random(1.2, 5.2);
       * // => a floating-point number between 1.2 and 5.2
       */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined$1;}if(floating===undefined$1){if(typeof upper=='boolean'){floating=upper;upper=undefined$1;}else if(typeof lower=='boolean'){floating=lower;lower=undefined$1;}}if(lower===undefined$1&&upper===undefined$1){lower=0;upper=1;}else {lower=toFinite(lower);if(upper===undefined$1){upper=lower;lower=0;}else {upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
       * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the camel cased string.
       * @example
       *
       * _.camelCase('Foo Bar');
       * // => 'fooBar'
       *
       * _.camelCase('--foo-bar--');
       * // => 'fooBar'
       *
       * _.camelCase('__FOO_BAR__');
       * // => 'fooBar'
       */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
       * Converts the first character of `string` to upper case and the remaining
       * to lower case.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to capitalize.
       * @returns {string} Returns the capitalized string.
       * @example
       *
       * _.capitalize('FRED');
       * // => 'Fred'
       */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
       * Deburrs `string` by converting
       * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
       * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
       * letters to basic Latin letters and removing
       * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to deburr.
       * @returns {string} Returns the deburred string.
       * @example
       *
       * _.deburr('dj vu');
       * // => 'deja vu'
       */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
       * Checks if `string` ends with the given target string.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {string} [target] The string to search for.
       * @param {number} [position=string.length] The position to search up to.
       * @returns {boolean} Returns `true` if `string` ends with `target`,
       *  else `false`.
       * @example
       *
       * _.endsWith('abc', 'c');
       * // => true
       *
       * _.endsWith('abc', 'b');
       * // => false
       *
       * _.endsWith('abc', 'b', 2);
       * // => true
       */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined$1?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
       * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
       * corresponding HTML entities.
       *
       * **Note:** No other characters are escaped. To escape additional
       * characters use a third-party library like [_he_](https://mths.be/he).
       *
       * Though the ">" character is escaped for symmetry, characters like
       * ">" and "/" don't need escaping in HTML and have no special meaning
       * unless they're part of a tag or unquoted attribute value. See
       * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
       * (under "semi-related fun fact") for more details.
       *
       * When working with HTML you should always
       * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
       * XSS vectors.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escape('fred, barney, & pebbles');
       * // => 'fred, barney, &amp; pebbles'
       */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
       * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
       * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to escape.
       * @returns {string} Returns the escaped string.
       * @example
       *
       * _.escapeRegExp('[lodash](https://lodash.com/)');
       * // => '\[lodash\]\(https://lodash\.com/\)'
       */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
       * Converts `string` to
       * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the kebab cased string.
       * @example
       *
       * _.kebabCase('Foo Bar');
       * // => 'foo-bar'
       *
       * _.kebabCase('fooBar');
       * // => 'foo-bar'
       *
       * _.kebabCase('__FOO_BAR__');
       * // => 'foo-bar'
       */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
       * Converts `string`, as space separated words, to lower case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the lower cased string.
       * @example
       *
       * _.lowerCase('--Foo-Bar--');
       * // => 'foo bar'
       *
       * _.lowerCase('fooBar');
       * // => 'foo bar'
       *
       * _.lowerCase('__FOO_BAR__');
       * // => 'foo bar'
       */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
       * Converts the first character of `string` to lower case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.lowerFirst('Fred');
       * // => 'fred'
       *
       * _.lowerFirst('FRED');
       * // => 'fRED'
       */var lowerFirst=createCaseFirst('toLowerCase');/**
       * Pads `string` on the left and right sides if it's shorter than `length`.
       * Padding characters are truncated if they can't be evenly divided by `length`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.pad('abc', 8);
       * // => '  abc   '
       *
       * _.pad('abc', 8, '_-');
       * // => '_-abc_-_'
       *
       * _.pad('abc', 3);
       * // => 'abc'
       */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
       * Pads `string` on the right side if it's shorter than `length`. Padding
       * characters are truncated if they exceed `length`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.padEnd('abc', 6);
       * // => 'abc   '
       *
       * _.padEnd('abc', 6, '_-');
       * // => 'abc_-_'
       *
       * _.padEnd('abc', 3);
       * // => 'abc'
       */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
       * Pads `string` on the left side if it's shorter than `length`. Padding
       * characters are truncated if they exceed `length`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to pad.
       * @param {number} [length=0] The padding length.
       * @param {string} [chars=' '] The string used as padding.
       * @returns {string} Returns the padded string.
       * @example
       *
       * _.padStart('abc', 6);
       * // => '   abc'
       *
       * _.padStart('abc', 6, '_-');
       * // => '_-_abc'
       *
       * _.padStart('abc', 3);
       * // => 'abc'
       */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
       * Converts `string` to an integer of the specified radix. If `radix` is
       * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
       * hexadecimal, in which case a `radix` of `16` is used.
       *
       * **Note:** This method aligns with the
       * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
       *
       * @static
       * @memberOf _
       * @since 1.1.0
       * @category String
       * @param {string} string The string to convert.
       * @param {number} [radix=10] The radix to interpret `value` by.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {number} Returns the converted integer.
       * @example
       *
       * _.parseInt('08');
       * // => 8
       *
       * _.map(['6', '08', '10'], _.parseInt);
       * // => [6, 8, 10]
       */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
       * Repeats the given string `n` times.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to repeat.
       * @param {number} [n=1] The number of times to repeat the string.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the repeated string.
       * @example
       *
       * _.repeat('*', 3);
       * // => '***'
       *
       * _.repeat('abc', 2);
       * // => 'abcabc'
       *
       * _.repeat('abc', 0);
       * // => ''
       */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined$1){n=1;}else {n=toInteger(n);}return baseRepeat(toString(string),n);}/**
       * Replaces matches for `pattern` in `string` with `replacement`.
       *
       * **Note:** This method is based on
       * [`String#replace`](https://mdn.io/String/replace).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to modify.
       * @param {RegExp|string} pattern The pattern to replace.
       * @param {Function|string} replacement The match replacement.
       * @returns {string} Returns the modified string.
       * @example
       *
       * _.replace('Hi Fred', 'Fred', 'Barney');
       * // => 'Hi Barney'
       */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
       * Converts `string` to
       * [snake case](https://en.wikipedia.org/wiki/Snake_case).
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the snake cased string.
       * @example
       *
       * _.snakeCase('Foo Bar');
       * // => 'foo_bar'
       *
       * _.snakeCase('fooBar');
       * // => 'foo_bar'
       *
       * _.snakeCase('--FOO-BAR--');
       * // => 'foo_bar'
       */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
       * Splits `string` by `separator`.
       *
       * **Note:** This method is based on
       * [`String#split`](https://mdn.io/String/split).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to split.
       * @param {RegExp|string} separator The separator pattern to split by.
       * @param {number} [limit] The length to truncate results to.
       * @returns {Array} Returns the string segments.
       * @example
       *
       * _.split('a-b-c', '-', 2);
       * // => ['a', 'b']
       */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined$1;}limit=limit===undefined$1?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return [];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
       * Converts `string` to
       * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
       *
       * @static
       * @memberOf _
       * @since 3.1.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the start cased string.
       * @example
       *
       * _.startCase('--foo-bar--');
       * // => 'Foo Bar'
       *
       * _.startCase('fooBar');
       * // => 'Foo Bar'
       *
       * _.startCase('__FOO_BAR__');
       * // => 'FOO BAR'
       */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
       * Checks if `string` starts with the given target string.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {string} [target] The string to search for.
       * @param {number} [position=0] The position to search from.
       * @returns {boolean} Returns `true` if `string` starts with `target`,
       *  else `false`.
       * @example
       *
       * _.startsWith('abc', 'a');
       * // => true
       *
       * _.startsWith('abc', 'b');
       * // => false
       *
       * _.startsWith('abc', 'b', 1);
       * // => true
       */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
       * Creates a compiled template function that can interpolate data properties
       * in "interpolate" delimiters, HTML-escape interpolated data properties in
       * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
       * properties may be accessed as free variables in the template. If a setting
       * object is given, it takes precedence over `_.templateSettings` values.
       *
       * **Note:** In the development build `_.template` utilizes
       * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
       * for easier debugging.
       *
       * For more information on precompiling templates see
       * [lodash's custom builds documentation](https://lodash.com/custom-builds).
       *
       * For more information on Chrome extension sandboxes see
       * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category String
       * @param {string} [string=''] The template string.
       * @param {Object} [options={}] The options object.
       * @param {RegExp} [options.escape=_.templateSettings.escape]
       *  The HTML "escape" delimiter.
       * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
       *  The "evaluate" delimiter.
       * @param {Object} [options.imports=_.templateSettings.imports]
       *  An object to import into the template as free variables.
       * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
       *  The "interpolate" delimiter.
       * @param {string} [options.sourceURL='lodash.templateSources[n]']
       *  The sourceURL of the compiled template.
       * @param {string} [options.variable='obj']
       *  The data object variable name.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Function} Returns the compiled template function.
       * @example
       *
       * // Use the "interpolate" delimiter to create a compiled template.
       * var compiled = _.template('hello <%= user %>!');
       * compiled({ 'user': 'fred' });
       * // => 'hello fred!'
       *
       * // Use the HTML "escape" delimiter to escape data property values.
       * var compiled = _.template('<b><%- value %></b>');
       * compiled({ 'value': '<script>' });
       * // => '<b>&lt;script&gt;</b>'
       *
       * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
       * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // Use the internal `print` function in "evaluate" delimiters.
       * var compiled = _.template('<% print("hello " + user); %>!');
       * compiled({ 'user': 'barney' });
       * // => 'hello barney!'
       *
       * // Use the ES template literal delimiter as an "interpolate" delimiter.
       * // Disable support by replacing the "interpolate" delimiter.
       * var compiled = _.template('hello ${ user }!');
       * compiled({ 'user': 'pebbles' });
       * // => 'hello pebbles!'
       *
       * // Use backslashes to treat delimiters as plain text.
       * var compiled = _.template('<%= "\\<%- value %\\>" %>');
       * compiled({ 'value': 'ignored' });
       * // => '<%- value %>'
       *
       * // Use the `imports` option to import `jQuery` as `jq`.
       * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
       * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
       * compiled({ 'users': ['fred', 'barney'] });
       * // => '<li>fred</li><li>barney</li>'
       *
       * // Use the `sourceURL` option to specify a custom sourceURL for the template.
       * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
       * compiled(data);
       * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
       *
       * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
       * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
       * compiled.source;
       * // => function(data) {
       * //   var __t, __p = '';
       * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
       * //   return __p;
       * // }
       *
       * // Use custom template delimiters.
       * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
       * var compiled = _.template('hello {{ user }}!');
       * compiled({ 'user': 'mustache' });
       * // => 'hello mustache!'
       *
       * // Use the `source` property to inline compiled templates for meaningful
       * // line numbers in error messages and stack traces.
       * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
       *   var JST = {\
       *     "main": ' + _.template(mainText).source + '\
       *   };\
       * ');
       */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
  // (http://ejohn.org/blog/javascript-micro-templating/)
  // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined$1;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
  var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
  // The sourceURL gets injected into the source that's eval-ed, so be careful
  // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
  // and escape the comment, thus injecting code that gets evaled.
  var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/\s/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
  source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
  if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
  // order to produce the correct `offset` value.
  return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
  // code to add the data object to the top of the scope chain.
  var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Throw an error if a forbidden character was found in `variable`, to prevent
  // potential command injection attacks.
  else if(reForbiddenIdentifierChars.test(variable)){throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);}// Cleanup code by stripping empty strings.
  source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
  source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined$1,importsValues);});// Provide the compiled function's source by its `toString` method or
  // the `source` property as a convenience for inlining compiled templates.
  result.source=source;if(isError(result)){throw result;}return result;}/**
       * Converts `string`, as a whole, to lower case just like
       * [String#toLowerCase](https://mdn.io/toLowerCase).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the lower cased string.
       * @example
       *
       * _.toLower('--Foo-Bar--');
       * // => '--foo-bar--'
       *
       * _.toLower('fooBar');
       * // => 'foobar'
       *
       * _.toLower('__FOO_BAR__');
       * // => '__foo_bar__'
       */function toLower(value){return toString(value).toLowerCase();}/**
       * Converts `string`, as a whole, to upper case just like
       * [String#toUpperCase](https://mdn.io/toUpperCase).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the upper cased string.
       * @example
       *
       * _.toUpper('--foo-bar--');
       * // => '--FOO-BAR--'
       *
       * _.toUpper('fooBar');
       * // => 'FOOBAR'
       *
       * _.toUpper('__foo_bar__');
       * // => '__FOO_BAR__'
       */function toUpper(value){return toString(value).toUpperCase();}/**
       * Removes leading and trailing whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trim('  abc  ');
       * // => 'abc'
       *
       * _.trim('-_-abc-_-', '_-');
       * // => 'abc'
       *
       * _.map(['  foo  ', '  bar  '], _.trim);
       * // => ['foo', 'bar']
       */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return baseTrim(string);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
       * Removes trailing whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trimEnd('  abc  ');
       * // => '  abc'
       *
       * _.trimEnd('-_-abc-_-', '_-');
       * // => '-_-abc'
       */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.slice(0,trimmedEndIndex(string)+1);}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
       * Removes leading whitespace or specified characters from `string`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to trim.
       * @param {string} [chars=whitespace] The characters to trim.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {string} Returns the trimmed string.
       * @example
       *
       * _.trimStart('  abc  ');
       * // => 'abc  '
       *
       * _.trimStart('-_-abc-_-', '_-');
       * // => 'abc-_-'
       */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
       * Truncates `string` if it's longer than the given maximum string length.
       * The last characters of the truncated string are replaced with the omission
       * string which defaults to "...".
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to truncate.
       * @param {Object} [options={}] The options object.
       * @param {number} [options.length=30] The maximum string length.
       * @param {string} [options.omission='...'] The string to indicate text is omitted.
       * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
       * @returns {string} Returns the truncated string.
       * @example
       *
       * _.truncate('hi-diddly-ho there, neighborino');
       * // => 'hi-diddly-ho there, neighbo...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'length': 24,
       *   'separator': ' '
       * });
       * // => 'hi-diddly-ho there,...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'length': 24,
       *   'separator': /,? +/
       * });
       * // => 'hi-diddly-ho there...'
       *
       * _.truncate('hi-diddly-ho there, neighborino', {
       *   'omission': ' [...]'
       * });
       * // => 'hi-diddly-ho there, neig [...]'
       */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined$1){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined$1?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
       * The inverse of `_.escape`; this method converts the HTML entities
       * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
       * their corresponding characters.
       *
       * **Note:** No other HTML entities are unescaped. To unescape additional
       * HTML entities use a third-party library like [_he_](https://mths.be/he).
       *
       * @static
       * @memberOf _
       * @since 0.6.0
       * @category String
       * @param {string} [string=''] The string to unescape.
       * @returns {string} Returns the unescaped string.
       * @example
       *
       * _.unescape('fred, barney, &amp; pebbles');
       * // => 'fred, barney, & pebbles'
       */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
       * Converts `string`, as space separated words, to upper case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the upper cased string.
       * @example
       *
       * _.upperCase('--foo-bar');
       * // => 'FOO BAR'
       *
       * _.upperCase('fooBar');
       * // => 'FOO BAR'
       *
       * _.upperCase('__foo_bar__');
       * // => 'FOO BAR'
       */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
       * Converts the first character of `string` to upper case.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category String
       * @param {string} [string=''] The string to convert.
       * @returns {string} Returns the converted string.
       * @example
       *
       * _.upperFirst('fred');
       * // => 'Fred'
       *
       * _.upperFirst('FRED');
       * // => 'FRED'
       */var upperFirst=createCaseFirst('toUpperCase');/**
       * Splits `string` into an array of its words.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category String
       * @param {string} [string=''] The string to inspect.
       * @param {RegExp|string} [pattern] The pattern to match words.
       * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
       * @returns {Array} Returns the words of `string`.
       * @example
       *
       * _.words('fred, barney, & pebbles');
       * // => ['fred', 'barney', 'pebbles']
       *
       * _.words('fred, barney, & pebbles', /[^, ]+/g);
       * // => ['fred', 'barney', '&', 'pebbles']
       */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined$1:pattern;if(pattern===undefined$1){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
       * Attempts to invoke `func`, returning either the result or the caught error
       * object. Any additional arguments are provided to `func` when it's invoked.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Function} func The function to attempt.
       * @param {...*} [args] The arguments to invoke `func` with.
       * @returns {*} Returns the `func` result or error object.
       * @example
       *
       * // Avoid throwing errors for invalid selectors.
       * var elements = _.attempt(function(selector) {
       *   return document.querySelectorAll(selector);
       * }, '>_>');
       *
       * if (_.isError(elements)) {
       *   elements = [];
       * }
       */var attempt=baseRest(function(func,args){try{return apply(func,undefined$1,args);}catch(e){return isError(e)?e:new Error(e);}});/**
       * Binds methods of an object to the object itself, overwriting the existing
       * method.
       *
       * **Note:** This method doesn't set the "length" property of bound functions.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {Object} object The object to bind and assign the bound methods to.
       * @param {...(string|string[])} methodNames The object method names to bind.
       * @returns {Object} Returns `object`.
       * @example
       *
       * var view = {
       *   'label': 'docs',
       *   'click': function() {
       *     console.log('clicked ' + this.label);
       *   }
       * };
       *
       * _.bindAll(view, ['click']);
       * jQuery(element).on('click', view.click);
       * // => Logs 'clicked docs' when clicked.
       */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
       * Creates a function that iterates over `pairs` and invokes the corresponding
       * function of the first predicate to return truthy. The predicate-function
       * pairs are invoked with the `this` binding and arguments of the created
       * function.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {Array} pairs The predicate-function pairs.
       * @returns {Function} Returns the new composite function.
       * @example
       *
       * var func = _.cond([
       *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
       *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
       *   [_.stubTrue,                      _.constant('no match')]
       * ]);
       *
       * func({ 'a': 1, 'b': 2 });
       * // => 'matches A'
       *
       * func({ 'a': 0, 'b': 1 });
       * // => 'matches B'
       *
       * func({ 'a': '1', 'b': '2' });
       * // => 'no match'
       */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return [toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
       * Creates a function that invokes the predicate properties of `source` with
       * the corresponding property values of a given object, returning `true` if
       * all predicates return truthy, else `false`.
       *
       * **Note:** The created function is equivalent to `_.conformsTo` with
       * `source` partially applied.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {Object} source The object of property predicates to conform to.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 2, 'b': 1 },
       *   { 'a': 1, 'b': 2 }
       * ];
       *
       * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
       * // => [{ 'a': 1, 'b': 2 }]
       */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
       * Creates a function that returns `value`.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {*} value The value to return from the new function.
       * @returns {Function} Returns the new constant function.
       * @example
       *
       * var objects = _.times(2, _.constant({ 'a': 1 }));
       *
       * console.log(objects);
       * // => [{ 'a': 1 }, { 'a': 1 }]
       *
       * console.log(objects[0] === objects[1]);
       * // => true
       */function constant(value){return function(){return value;};}/**
       * Checks `value` to determine whether a default value should be returned in
       * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
       * or `undefined`.
       *
       * @static
       * @memberOf _
       * @since 4.14.0
       * @category Util
       * @param {*} value The value to check.
       * @param {*} defaultValue The default value.
       * @returns {*} Returns the resolved value.
       * @example
       *
       * _.defaultTo(1, 10);
       * // => 1
       *
       * _.defaultTo(undefined, 10);
       * // => 10
       */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
       * Creates a function that returns the result of invoking the given functions
       * with the `this` binding of the created function, where each successive
       * invocation is supplied the return value of the previous.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {...(Function|Function[])} [funcs] The functions to invoke.
       * @returns {Function} Returns the new composite function.
       * @see _.flowRight
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var addSquare = _.flow([_.add, square]);
       * addSquare(1, 2);
       * // => 9
       */var flow=createFlow();/**
       * This method is like `_.flow` except that it creates a function that
       * invokes the given functions from right to left.
       *
       * @static
       * @since 3.0.0
       * @memberOf _
       * @category Util
       * @param {...(Function|Function[])} [funcs] The functions to invoke.
       * @returns {Function} Returns the new composite function.
       * @see _.flow
       * @example
       *
       * function square(n) {
       *   return n * n;
       * }
       *
       * var addSquare = _.flowRight([square, _.add]);
       * addSquare(1, 2);
       * // => 9
       */var flowRight=createFlow(true);/**
       * This method returns the first argument it receives.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {*} value Any value.
       * @returns {*} Returns `value`.
       * @example
       *
       * var object = { 'a': 1 };
       *
       * console.log(_.identity(object) === object);
       * // => true
       */function identity(value){return value;}/**
       * Creates a function that invokes `func` with the arguments of the created
       * function. If `func` is a property name, the created function returns the
       * property value for a given element. If `func` is an array or object, the
       * created function returns `true` for elements that contain the equivalent
       * source properties, otherwise it returns `false`.
       *
       * @static
       * @since 4.0.0
       * @memberOf _
       * @category Util
       * @param {*} [func=_.identity] The value to convert to a callback.
       * @returns {Function} Returns the callback.
       * @example
       *
       * var users = [
       *   { 'user': 'barney', 'age': 36, 'active': true },
       *   { 'user': 'fred',   'age': 40, 'active': false }
       * ];
       *
       * // The `_.matches` iteratee shorthand.
       * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
       * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
       *
       * // The `_.matchesProperty` iteratee shorthand.
       * _.filter(users, _.iteratee(['user', 'fred']));
       * // => [{ 'user': 'fred', 'age': 40 }]
       *
       * // The `_.property` iteratee shorthand.
       * _.map(users, _.iteratee('user'));
       * // => ['barney', 'fred']
       *
       * // Create custom iteratee shorthands.
       * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
       *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
       *     return func.test(string);
       *   };
       * });
       *
       * _.filter(['abc', 'def'], /ef/);
       * // => ['def']
       */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
       * Creates a function that performs a partial deep comparison between a given
       * object and `source`, returning `true` if the given object has equivalent
       * property values, else `false`.
       *
       * **Note:** The created function is equivalent to `_.isMatch` with `source`
       * partially applied.
       *
       * Partial comparisons will match empty array and empty object `source`
       * values against any array or object value, respectively. See `_.isEqual`
       * for a list of supported value comparisons.
       *
       * **Note:** Multiple values can be checked by combining several matchers
       * using `_.overSome`
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Object} source The object of property values to match.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 1, 'b': 2, 'c': 3 },
       *   { 'a': 4, 'b': 5, 'c': 6 }
       * ];
       *
       * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
       * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
       *
       * // Checking for several possible values
       * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
       * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
       */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
       * Creates a function that performs a partial deep comparison between the
       * value at `path` of a given object to `srcValue`, returning `true` if the
       * object value is equivalent, else `false`.
       *
       * **Note:** Partial comparisons will match empty array and empty object
       * `srcValue` values against any array or object value, respectively. See
       * `_.isEqual` for a list of supported value comparisons.
       *
       * **Note:** Multiple values can be checked by combining several matchers
       * using `_.overSome`
       *
       * @static
       * @memberOf _
       * @since 3.2.0
       * @category Util
       * @param {Array|string} path The path of the property to get.
       * @param {*} srcValue The value to match.
       * @returns {Function} Returns the new spec function.
       * @example
       *
       * var objects = [
       *   { 'a': 1, 'b': 2, 'c': 3 },
       *   { 'a': 4, 'b': 5, 'c': 6 }
       * ];
       *
       * _.find(objects, _.matchesProperty('a', 4));
       * // => { 'a': 4, 'b': 5, 'c': 6 }
       *
       * // Checking for several possible values
       * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
       * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
       */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
       * Creates a function that invokes the method at `path` of a given object.
       * Any additional arguments are provided to the invoked method.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Util
       * @param {Array|string} path The path of the method to invoke.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {Function} Returns the new invoker function.
       * @example
       *
       * var objects = [
       *   { 'a': { 'b': _.constant(2) } },
       *   { 'a': { 'b': _.constant(1) } }
       * ];
       *
       * _.map(objects, _.method('a.b'));
       * // => [2, 1]
       *
       * _.map(objects, _.method(['a', 'b']));
       * // => [2, 1]
       */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
       * The opposite of `_.method`; this method creates a function that invokes
       * the method at a given path of `object`. Any additional arguments are
       * provided to the invoked method.
       *
       * @static
       * @memberOf _
       * @since 3.7.0
       * @category Util
       * @param {Object} object The object to query.
       * @param {...*} [args] The arguments to invoke the method with.
       * @returns {Function} Returns the new invoker function.
       * @example
       *
       * var array = _.times(3, _.constant),
       *     object = { 'a': array, 'b': array, 'c': array };
       *
       * _.map(['a[2]', 'c[0]'], _.methodOf(object));
       * // => [2, 0]
       *
       * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
       * // => [2, 0]
       */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
       * Adds all own enumerable string keyed function properties of a source
       * object to the destination object. If `object` is a function, then methods
       * are added to its prototype as well.
       *
       * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
       * avoid conflicts caused by modifying the original.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {Function|Object} [object=lodash] The destination object.
       * @param {Object} source The object of functions to add.
       * @param {Object} [options={}] The options object.
       * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
       * @returns {Function|Object} Returns `object`.
       * @example
       *
       * function vowels(string) {
       *   return _.filter(string, function(v) {
       *     return /[aeiou]/i.test(v);
       *   });
       * }
       *
       * _.mixin({ 'vowels': vowels });
       * _.vowels('fred');
       * // => ['e']
       *
       * _('fred').vowels().value();
       * // => ['e']
       *
       * _.mixin({ 'vowels': vowels }, { 'chain': false });
       * _('fred').vowels();
       * // => ['e']
       */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
       * Reverts the `_` variable to its previous value and returns a reference to
       * the `lodash` function.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @returns {Function} Returns the `lodash` function.
       * @example
       *
       * var lodash = _.noConflict();
       */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
       * This method returns `undefined`.
       *
       * @static
       * @memberOf _
       * @since 2.3.0
       * @category Util
       * @example
       *
       * _.times(2, _.noop);
       * // => [undefined, undefined]
       */function noop(){// No operation performed.
  }/**
       * Creates a function that gets the argument at index `n`. If `n` is negative,
       * the nth argument from the end is returned.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {number} [n=0] The index of the argument to return.
       * @returns {Function} Returns the new pass-thru function.
       * @example
       *
       * var func = _.nthArg(1);
       * func('a', 'b', 'c', 'd');
       * // => 'b'
       *
       * var func = _.nthArg(-2);
       * func('a', 'b', 'c', 'd');
       * // => 'c'
       */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
       * Creates a function that invokes `iteratees` with the arguments it receives
       * and returns their results.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [iteratees=[_.identity]]
       *  The iteratees to invoke.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.over([Math.max, Math.min]);
       *
       * func(1, 2, 3, 4);
       * // => [4, 1]
       */var over=createOver(arrayMap);/**
       * Creates a function that checks if **all** of the `predicates` return
       * truthy when invoked with the arguments it receives.
       *
       * Following shorthands are possible for providing predicates.
       * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
       * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [predicates=[_.identity]]
       *  The predicates to check.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.overEvery([Boolean, isFinite]);
       *
       * func('1');
       * // => true
       *
       * func(null);
       * // => false
       *
       * func(NaN);
       * // => false
       */var overEvery=createOver(arrayEvery);/**
       * Creates a function that checks if **any** of the `predicates` return
       * truthy when invoked with the arguments it receives.
       *
       * Following shorthands are possible for providing predicates.
       * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
       * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {...(Function|Function[])} [predicates=[_.identity]]
       *  The predicates to check.
       * @returns {Function} Returns the new function.
       * @example
       *
       * var func = _.overSome([Boolean, isFinite]);
       *
       * func('1');
       * // => true
       *
       * func(null);
       * // => true
       *
       * func(NaN);
       * // => false
       *
       * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
       * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
       */var overSome=createOver(arraySome);/**
       * Creates a function that returns the value at `path` of a given object.
       *
       * @static
       * @memberOf _
       * @since 2.4.0
       * @category Util
       * @param {Array|string} path The path of the property to get.
       * @returns {Function} Returns the new accessor function.
       * @example
       *
       * var objects = [
       *   { 'a': { 'b': 2 } },
       *   { 'a': { 'b': 1 } }
       * ];
       *
       * _.map(objects, _.property('a.b'));
       * // => [2, 1]
       *
       * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
       * // => [1, 2]
       */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
       * The opposite of `_.property`; this method creates a function that returns
       * the value at a given path of `object`.
       *
       * @static
       * @memberOf _
       * @since 3.0.0
       * @category Util
       * @param {Object} object The object to query.
       * @returns {Function} Returns the new accessor function.
       * @example
       *
       * var array = [0, 1, 2],
       *     object = { 'a': array, 'b': array, 'c': array };
       *
       * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
       * // => [2, 0]
       *
       * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
       * // => [2, 0]
       */function propertyOf(object){return function(path){return object==null?undefined$1:baseGet(object,path);};}/**
       * Creates an array of numbers (positive and/or negative) progressing from
       * `start` up to, but not including, `end`. A step of `-1` is used if a negative
       * `start` is specified without an `end` or `step`. If `end` is not specified,
       * it's set to `start` with `start` then set to `0`.
       *
       * **Note:** JavaScript follows the IEEE-754 standard for resolving
       * floating-point values which can produce unexpected results.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @param {number} [step=1] The value to increment or decrement by.
       * @returns {Array} Returns the range of numbers.
       * @see _.inRange, _.rangeRight
       * @example
       *
       * _.range(4);
       * // => [0, 1, 2, 3]
       *
       * _.range(-4);
       * // => [0, -1, -2, -3]
       *
       * _.range(1, 5);
       * // => [1, 2, 3, 4]
       *
       * _.range(0, 20, 5);
       * // => [0, 5, 10, 15]
       *
       * _.range(0, -4, -1);
       * // => [0, -1, -2, -3]
       *
       * _.range(1, 4, 0);
       * // => [1, 1, 1]
       *
       * _.range(0);
       * // => []
       */var range=createRange();/**
       * This method is like `_.range` except that it populates values in
       * descending order.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {number} [start=0] The start of the range.
       * @param {number} end The end of the range.
       * @param {number} [step=1] The value to increment or decrement by.
       * @returns {Array} Returns the range of numbers.
       * @see _.inRange, _.range
       * @example
       *
       * _.rangeRight(4);
       * // => [3, 2, 1, 0]
       *
       * _.rangeRight(-4);
       * // => [-3, -2, -1, 0]
       *
       * _.rangeRight(1, 5);
       * // => [4, 3, 2, 1]
       *
       * _.rangeRight(0, 20, 5);
       * // => [15, 10, 5, 0]
       *
       * _.rangeRight(0, -4, -1);
       * // => [-3, -2, -1, 0]
       *
       * _.rangeRight(1, 4, 0);
       * // => [1, 1, 1]
       *
       * _.rangeRight(0);
       * // => []
       */var rangeRight=createRange(true);/**
       * This method returns a new empty array.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {Array} Returns the new empty array.
       * @example
       *
       * var arrays = _.times(2, _.stubArray);
       *
       * console.log(arrays);
       * // => [[], []]
       *
       * console.log(arrays[0] === arrays[1]);
       * // => false
       */function stubArray(){return [];}/**
       * This method returns `false`.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {boolean} Returns `false`.
       * @example
       *
       * _.times(2, _.stubFalse);
       * // => [false, false]
       */function stubFalse(){return false;}/**
       * This method returns a new empty object.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {Object} Returns the new empty object.
       * @example
       *
       * var objects = _.times(2, _.stubObject);
       *
       * console.log(objects);
       * // => [{}, {}]
       *
       * console.log(objects[0] === objects[1]);
       * // => false
       */function stubObject(){return {};}/**
       * This method returns an empty string.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {string} Returns the empty string.
       * @example
       *
       * _.times(2, _.stubString);
       * // => ['', '']
       */function stubString(){return '';}/**
       * This method returns `true`.
       *
       * @static
       * @memberOf _
       * @since 4.13.0
       * @category Util
       * @returns {boolean} Returns `true`.
       * @example
       *
       * _.times(2, _.stubTrue);
       * // => [true, true]
       */function stubTrue(){return true;}/**
       * Invokes the iteratee `n` times, returning an array of the results of
       * each invocation. The iteratee is invoked with one argument; (index).
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {number} n The number of times to invoke `iteratee`.
       * @param {Function} [iteratee=_.identity] The function invoked per iteration.
       * @returns {Array} Returns the array of results.
       * @example
       *
       * _.times(3, String);
       * // => ['0', '1', '2']
       *
       *  _.times(4, _.constant(0));
       * // => [0, 0, 0, 0]
       */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return [];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
       * Converts `value` to a property path array.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Util
       * @param {*} value The value to convert.
       * @returns {Array} Returns the new property path array.
       * @example
       *
       * _.toPath('a.b.c');
       * // => ['a', 'b', 'c']
       *
       * _.toPath('a[0].b.c');
       * // => ['a', '0', 'b', 'c']
       */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
       * Generates a unique ID. If `prefix` is given, the ID is appended to it.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Util
       * @param {string} [prefix=''] The value to prefix the ID with.
       * @returns {string} Returns the unique ID.
       * @example
       *
       * _.uniqueId('contact_');
       * // => 'contact_104'
       *
       * _.uniqueId();
       * // => '105'
       */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
       * Adds two numbers.
       *
       * @static
       * @memberOf _
       * @since 3.4.0
       * @category Math
       * @param {number} augend The first number in an addition.
       * @param {number} addend The second number in an addition.
       * @returns {number} Returns the total.
       * @example
       *
       * _.add(6, 4);
       * // => 10
       */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
       * Computes `number` rounded up to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round up.
       * @param {number} [precision=0] The precision to round up to.
       * @returns {number} Returns the rounded up number.
       * @example
       *
       * _.ceil(4.006);
       * // => 5
       *
       * _.ceil(6.004, 2);
       * // => 6.01
       *
       * _.ceil(6040, -2);
       * // => 6100
       */var ceil=createRound('ceil');/**
       * Divide two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {number} dividend The first number in a division.
       * @param {number} divisor The second number in a division.
       * @returns {number} Returns the quotient.
       * @example
       *
       * _.divide(6, 4);
       * // => 1.5
       */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
       * Computes `number` rounded down to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round down.
       * @param {number} [precision=0] The precision to round down to.
       * @returns {number} Returns the rounded down number.
       * @example
       *
       * _.floor(4.006);
       * // => 4
       *
       * _.floor(0.046, 2);
       * // => 0.04
       *
       * _.floor(4060, -2);
       * // => 4000
       */var floor=createRound('floor');/**
       * Computes the maximum value of `array`. If `array` is empty or falsey,
       * `undefined` is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {*} Returns the maximum value.
       * @example
       *
       * _.max([4, 2, 8, 6]);
       * // => 8
       *
       * _.max([]);
       * // => undefined
       */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined$1;}/**
       * This method is like `_.max` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * the value is ranked. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {*} Returns the maximum value.
       * @example
       *
       * var objects = [{ 'n': 1 }, { 'n': 2 }];
       *
       * _.maxBy(objects, function(o) { return o.n; });
       * // => { 'n': 2 }
       *
       * // The `_.property` iteratee shorthand.
       * _.maxBy(objects, 'n');
       * // => { 'n': 2 }
       */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined$1;}/**
       * Computes the mean of the values in `array`.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {number} Returns the mean.
       * @example
       *
       * _.mean([4, 2, 8, 6]);
       * // => 5
       */function mean(array){return baseMean(array,identity);}/**
       * This method is like `_.mean` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the value to be averaged.
       * The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the mean.
       * @example
       *
       * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
       *
       * _.meanBy(objects, function(o) { return o.n; });
       * // => 5
       *
       * // The `_.property` iteratee shorthand.
       * _.meanBy(objects, 'n');
       * // => 5
       */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
       * Computes the minimum value of `array`. If `array` is empty or falsey,
       * `undefined` is returned.
       *
       * @static
       * @since 0.1.0
       * @memberOf _
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {*} Returns the minimum value.
       * @example
       *
       * _.min([4, 2, 8, 6]);
       * // => 2
       *
       * _.min([]);
       * // => undefined
       */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined$1;}/**
       * This method is like `_.min` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the criterion by which
       * the value is ranked. The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {*} Returns the minimum value.
       * @example
       *
       * var objects = [{ 'n': 1 }, { 'n': 2 }];
       *
       * _.minBy(objects, function(o) { return o.n; });
       * // => { 'n': 1 }
       *
       * // The `_.property` iteratee shorthand.
       * _.minBy(objects, 'n');
       * // => { 'n': 1 }
       */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined$1;}/**
       * Multiply two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.7.0
       * @category Math
       * @param {number} multiplier The first number in a multiplication.
       * @param {number} multiplicand The second number in a multiplication.
       * @returns {number} Returns the product.
       * @example
       *
       * _.multiply(6, 4);
       * // => 24
       */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
       * Computes `number` rounded to `precision`.
       *
       * @static
       * @memberOf _
       * @since 3.10.0
       * @category Math
       * @param {number} number The number to round.
       * @param {number} [precision=0] The precision to round to.
       * @returns {number} Returns the rounded number.
       * @example
       *
       * _.round(4.006);
       * // => 4
       *
       * _.round(4.006, 2);
       * // => 4.01
       *
       * _.round(4060, -2);
       * // => 4100
       */var round=createRound('round');/**
       * Subtract two numbers.
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {number} minuend The first number in a subtraction.
       * @param {number} subtrahend The second number in a subtraction.
       * @returns {number} Returns the difference.
       * @example
       *
       * _.subtract(6, 4);
       * // => 2
       */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
       * Computes the sum of the values in `array`.
       *
       * @static
       * @memberOf _
       * @since 3.4.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @returns {number} Returns the sum.
       * @example
       *
       * _.sum([4, 2, 8, 6]);
       * // => 20
       */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
       * This method is like `_.sum` except that it accepts `iteratee` which is
       * invoked for each element in `array` to generate the value to be summed.
       * The iteratee is invoked with one argument: (value).
       *
       * @static
       * @memberOf _
       * @since 4.0.0
       * @category Math
       * @param {Array} array The array to iterate over.
       * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
       * @returns {number} Returns the sum.
       * @example
       *
       * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
       *
       * _.sumBy(objects, function(o) { return o.n; });
       * // => 20
       *
       * // The `_.property` iteratee shorthand.
       * _.sumBy(objects, 'n');
       * // => 20
       */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
  lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
  lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
  mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
  lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
  lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
       * The semantic version number.
       *
       * @static
       * @memberOf _
       * @type {string}
       */lodash.VERSION=VERSION;// Assign default placeholders.
  arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
  arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined$1?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else {result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
  arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
  arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
  arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined$1){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
  baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function interceptor(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
  isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined$1});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
  arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
  baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined$1,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined$1}];// Add methods to `LazyWrapper`.
  LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
  lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
  lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
  var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
  if(freeModule){// Export for Node.js.
  (freeModule.exports=_)._=_;// Export for CommonJS support.
  freeExports._=_;}else {// Export to the global object.
  root._=_;}}).call(commonjsGlobal);})(lodash,lodash.exports);

  var messageProps = {
    align: {
      type: String,
      default: "left",
      validator: function validator(val) {
        if (!val) return true;
        return ["left", "center"].includes(val);
      }
    },
    closeBtn: {
      type: [Boolean, Function],
      default: false
    },
    content: {
      type: [String, Function]
    },
    duration: {
      type: Number,
      default: 3e3
    },
    icon: {
      type: [Boolean, Function],
      default: true
    },
    marquee: {
      type: [Boolean, Object],
      default: false
    },
    offset: {
      type: Array
    },
    theme: {
      type: String,
      default: "info",
      validator: function validator(val) {
        if (!val) return true;
        return ["info", "success", "warning", "error"].includes(val);
      }
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: Boolean,
    zIndex: {
      type: Number
    },
    onChange: Function,
    onClose: Function,
    onClosed: Function,
    onOpen: Function,
    onOpened: Function
  };

  function ownKeys$s(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$s(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$s(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$s(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$D = config.prefix;
  var name$A = "".concat(prefix$D, "-message");
  var iconDefault$2 = {
    info: vue.h(errorCircleFilled),
    success: vue.h(checkCircleFilled),
    warning: vue.h(errorCircleFilled),
    error: vue.h(errorCircleFilled)
  };
  var script$F = vue.defineComponent({
    name: name$A,
    components: {
      TNode: TNodeComponent
    },
    props: messageProps,
    emits: ["change", "open", "opened", "close", "closed"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var state = vue.reactive({
        duration: 0,
        offset: 0,
        listWidth: 0,
        itemWidth: 0,
        scroll: {
          marquee: false,
          speed: 50,
          loop: -1,
          delay: 0
        }
      });
      var _toRefs = vue.toRefs(props),
        visible = _toRefs.visible,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(visible, modelValue, props.defaultVisible, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        currentVisible = _useVModel2[0],
        setVisible = _useVModel2[1];
      var rootClasses = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, name$A, true), _defineProperty$2(_ref, "".concat(name$A, "--").concat(props.theme), true), _defineProperty$2(_ref, "".concat(name$A, "-align--").concat(props.align), !!props.align), _ref;
      });
      var textWrapClasses = vue.computed(function () {
        var _ref2;
        return _ref2 = {}, _defineProperty$2(_ref2, "".concat(name$A, "__text-wrap"), true), _defineProperty$2(_ref2, "".concat(name$A, "__text-nowrap"), props.marquee), _ref2;
      });
      var changeNumToStr = function changeNumToStr(arr) {
        return arr.map(function (item) {
          return typeof item === "number" ? "".concat(item, "px") : item;
        });
      };
      var getMessageStylesOffset = function getMessageStylesOffset(offset) {
        var arr = changeNumToStr(offset);
        return {
          top: arr[0],
          right: arr[1],
          left: arr[1]
        };
      };
      var rootStyles = vue.computed(function () {
        var offset = props.offset;
        var offsetStyle = offset ? getMessageStylesOffset(offset) : [];
        return _objectSpread$s({
          zIndex: props.zIndex
        }, offsetStyle);
      });
      var computedPrefixIcon = vue.computed(function () {
        var icon = props.icon;
        if (!icon) return null;
        if (icon && !context.slots.icon && !lodash.exports.isFunction(icon)) {
          var theme = props.theme;
          return (iconDefault$2 === null || iconDefault$2 === void 0 ? void 0 : iconDefault$2[theme]) || null;
        }
        return renderTNode(internalInstance, "icon");
      });
      var computedContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var computedCloseBtn = vue.computed(function () {
        var closeBtn = props.closeBtn;
        if (lodash.exports.isFunction(closeBtn || context.slots.closeBtn)) {
          return renderTNode(internalInstance, "closeBtn");
        }
        if (closeBtn) {
          var closeIcon = vue.h(close);
          return closeIcon;
        }
        return null;
      });
      var animateStyle = vue.computed(function () {
        return {
          transform: state.offset ? "translateX(".concat(state.offset, "px)") : "",
          transitionDuration: "".concat(state.duration, "s"),
          transitionTimingFunction: "linear"
        };
      });
      var textWrapDOM = vue.ref();
      var textDOM = vue.ref();
      var handleScrolling = function handleScrolling() {
        var _props$marquee, _marquee$speed, _marquee$delay;
        if (!(props !== null && props !== void 0 && props.marquee) || (props === null || props === void 0 ? void 0 : (_props$marquee = props.marquee) === null || _props$marquee === void 0 ? void 0 : _props$marquee.loop) === 0) {
          return;
        }
        if (typeof props.marquee === "boolean") {
          state.scroll = _objectSpread$s(_objectSpread$s({}, state.scroll), {}, {
            marquee: props.marquee
          });
        }
        var marquee = props.marquee;
        state.scroll = {
          marquee: true,
          loop: typeof (marquee === null || marquee === void 0 ? void 0 : marquee.loop) === "undefined" ? state.scroll.loop : marquee.loop,
          speed: (_marquee$speed = marquee.speed) !== null && _marquee$speed !== void 0 ? _marquee$speed : state.scroll.speed,
          delay: (_marquee$delay = marquee.delay) !== null && _marquee$delay !== void 0 ? _marquee$delay : state.scroll.delay
        };
        setTimeout(function () {
          var _textWrapDOM$value, _textDOM$value;
          var textWrapDOMWidth = (_textWrapDOM$value = textWrapDOM.value) === null || _textWrapDOM$value === void 0 ? void 0 : _textWrapDOM$value.getBoundingClientRect().width;
          var textDOMWidth = (_textDOM$value = textDOM.value) === null || _textDOM$value === void 0 ? void 0 : _textDOM$value.getBoundingClientRect().width;
          state.offset = -textDOMWidth;
          state.duration = textDOMWidth / state.scroll.speed;
          state.listWidth = textWrapDOMWidth;
          state.itemWidth = textDOMWidth;
        }, state.scroll.delay);
      };
      var handleTransitionend = function handleTransitionend() {
        state.scroll.loop = --state.scroll.loop;
        if (state.scroll.loop === 0) {
          state.scroll = _objectSpread$s(_objectSpread$s({}, state.scroll), {}, {
            marquee: false
          });
          return;
        }
        state.offset = state.listWidth;
        state.duration = 0;
        setTimeout(function () {
          state.offset = -state.itemWidth;
          state.duration = (state.itemWidth + state.listWidth) / state.scroll.speed;
        }, 0);
      };
      var onClose = function onClose() {
        emitEvent("close");
        setVisible(false);
      };
      var handleDuration = function handleDuration() {
        if (props.duration > 0) {
          setTimeout(function () {
            emitEvent("durationEnd");
            onClose();
          }, props.duration);
        }
      };
      vue.onMounted(function () {
        vue.nextTick(function () {
          if (currentVisible.value) {
            handleScrolling();
          }
        });
      });
      vue.watch(function () {
        return currentVisible.value;
      }, function (val) {
        if (val === false) return;
        emitEvent("open");
        setVisible(true);
        handleDuration();
        vue.nextTick(function () {
          state.offset = state.listWidth;
          state.duration = 0;
          handleScrolling();
        });
      });
      return _objectSpread$s(_objectSpread$s({
        name: vue.ref(name$A)
      }, vue.toRefs(state)), {}, {
        currentVisible: currentVisible,
        rootClasses: rootClasses,
        textWrapClasses: textWrapClasses,
        rootStyles: rootStyles,
        computedPrefixIcon: computedPrefixIcon,
        computedContent: computedContent,
        computedCloseBtn: computedCloseBtn,
        textWrapDOM: textWrapDOM,
        textDOM: textDOM,
        animateStyle: animateStyle,
        onClose: onClose,
        handleTransitionend: handleTransitionend,
        afterEnter: function afterEnter() {
          return emitEvent("opened");
        },
        afterLeave: function afterLeave() {
          return emitEvent("closed");
        }
      });
    }
  });

  function render$E(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createBlock(vue.Transition, {
      name: "message",
      onAfterLeave: _ctx.afterLeave,
      onAfterEnter: _ctx.afterEnter
    }, {
      default: vue.withCtx(function () {
        return [_ctx.currentVisible ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          ref: "root",
          class: vue.normalizeClass(_ctx.rootClasses),
          style: vue.normalizeStyle(_ctx.rootStyles)
        }, [_ctx.computedPrefixIcon ? (vue.openBlock(), vue.createBlock(_component_t_node, {
          key: 0,
          content: _ctx.computedPrefixIcon
        }, null, 8, ["content"])) : vue.createCommentVNode("", true), vue.createElementVNode("div", {
          ref: "textWrapDOM",
          class: vue.normalizeClass(_ctx.textWrapClasses)
        }, [vue.createElementVNode("div", {
          ref: "textDOM",
          class: vue.normalizeClass("".concat(_ctx.name, "__text")),
          style: vue.normalizeStyle(_ctx.scroll.marquee ? _ctx.animateStyle : ""),
          onTransitionend: _cache[0] || (_cache[0] = function ($event) {
            return _ctx.handleTransitionend();
          })
        }, [_ctx.computedContent ? (vue.openBlock(), vue.createBlock(_component_t_node, {
          key: 0,
          content: _ctx.computedContent
        }, null, 8, ["content"])) : vue.createCommentVNode("", true)], 38)], 2), _ctx.computedCloseBtn ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 1,
          onClick: _cache[1] || (_cache[1] = function () {
            return _ctx.onClose && _ctx.onClose.apply(_ctx, arguments);
          })
        }, [vue.createVNode(_component_t_node, {
          content: _ctx.computedCloseBtn
        }, null, 8, ["content"])])) : vue.createCommentVNode("", true)], 6)) : vue.createCommentVNode("", true)];
      }),
      _: 1
    }, 8, ["onAfterLeave", "onAfterEnter"]);
  }

  script$F.render = render$E;

  function ownKeys$r(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$r(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$r(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$r(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function create(props) {
    var visible = vue.ref(false);
    var root = document.createElement("div");
    document.body.appendChild(root);
    var component = vue.defineComponent({
      render: function render() {
        return vue.h(script$F, _objectSpread$r(_objectSpread$r({}, props), {}, {
          visible: visible.value,
          onClose: function onClose() {
            visible.value = false;
          },
          onClosed: function onClosed() {
            root.remove();
          }
        }));
      }
    });
    vue.createApp(component).mount(root);
    vue.nextTick(function () {
      visible.value = true;
    });
  }
  var defaultProps = {
    align: "left",
    closeBtn: false,
    content: "",
    duration: 3e3,
    theme: "info",
    visible: false,
    zIndex: 5e3,
    onClose: function onClose() {},
    onClosed: function onClosed() {},
    onOpen: function onOpen() {},
    onOpened: function onOpened() {},
    onChange: function onChange() {}
  };
  ["info", "success", "warning", "error"].forEach(function (theme) {
    script$F[theme] = function (options) {
      var props = _objectSpread$r(_objectSpread$r({}, defaultProps), {}, {
        theme: theme
      });
      if (typeof options === "string") {
        props.content = options;
      } else {
        props = _objectSpread$r(_objectSpread$r({}, props), options);
      }
      create(props);
    };
  });
  script$F.install = function (app) {
    var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";
    app.component(name || script$F.name, script$F);
    app.config.globalProperties.$message = script$F;
  };
  var MessagePlugin = script$F;

  var dayjs_min = {exports: {}};

  (function (module, exports) {
    !function (t, e) {
      module.exports = e() ;
    }(commonjsGlobal, function () {

      var t = 1e3,
        e = 6e4,
        n = 36e5,
        r = "millisecond",
        i = "second",
        s = "minute",
        u = "hour",
        a = "day",
        o = "week",
        f = "month",
        h = "quarter",
        c = "year",
        d = "date",
        l = "Invalid Date",
        $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
        y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
        M = {
          name: "en",
          weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
          months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
          ordinal: function ordinal(t) {
            var e = ["th", "st", "nd", "rd"],
              n = t % 100;
            return "[" + t + (e[(n - 20) % 10] || e[n] || e[0]) + "]";
          }
        },
        m = function m(t, e, n) {
          var r = String(t);
          return !r || r.length >= e ? t : "" + Array(e + 1 - r.length).join(n) + t;
        },
        v = {
          s: m,
          z: function z(t) {
            var e = -t.utcOffset(),
              n = Math.abs(e),
              r = Math.floor(n / 60),
              i = n % 60;
            return (e <= 0 ? "+" : "-") + m(r, 2, "0") + ":" + m(i, 2, "0");
          },
          m: function t(e, n) {
            if (e.date() < n.date()) return -t(n, e);
            var r = 12 * (n.year() - e.year()) + (n.month() - e.month()),
              i = e.clone().add(r, f),
              s = n - i < 0,
              u = e.clone().add(r + (s ? -1 : 1), f);
            return +(-(r + (n - i) / (s ? i - u : u - i)) || 0);
          },
          a: function a(t) {
            return t < 0 ? Math.ceil(t) || 0 : Math.floor(t);
          },
          p: function p(t) {
            return {
              M: f,
              y: c,
              w: o,
              d: a,
              D: d,
              h: u,
              m: s,
              s: i,
              ms: r,
              Q: h
            }[t] || String(t || "").toLowerCase().replace(/s$/, "");
          },
          u: function u(t) {
            return void 0 === t;
          }
        },
        g = "en",
        D = {};
      D[g] = M;
      var p = function p(t) {
          return t instanceof _;
        },
        S = function t(e, n, r) {
          var i;
          if (!e) return g;
          if ("string" == typeof e) {
            var s = e.toLowerCase();
            D[s] && (i = s), n && (D[s] = n, i = s);
            var u = e.split("-");
            if (!i && u.length > 1) return t(u[0]);
          } else {
            var a = e.name;
            D[a] = e, i = a;
          }
          return !r && i && (g = i), i || !r && g;
        },
        w = function w(t, e) {
          if (p(t)) return t.clone();
          var n = "object" == _typeof$1(e) ? e : {};
          return n.date = t, n.args = arguments, new _(n);
        },
        O = v;
      O.l = S, O.i = p, O.w = function (t, e) {
        return w(t, {
          locale: e.$L,
          utc: e.$u,
          x: e.$x,
          $offset: e.$offset
        });
      };
      var _ = function () {
          function M(t) {
            this.$L = S(t.locale, null, !0), this.parse(t);
          }
          var m = M.prototype;
          return m.parse = function (t) {
            this.$d = function (t) {
              var e = t.date,
                n = t.utc;
              if (null === e) return new Date(NaN);
              if (O.u(e)) return new Date();
              if (e instanceof Date) return new Date(e);
              if ("string" == typeof e && !/Z$/i.test(e)) {
                var r = e.match($);
                if (r) {
                  var i = r[2] - 1 || 0,
                    s = (r[7] || "0").substring(0, 3);
                  return n ? new Date(Date.UTC(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s)) : new Date(r[1], i, r[3] || 1, r[4] || 0, r[5] || 0, r[6] || 0, s);
                }
              }
              return new Date(e);
            }(t), this.$x = t.x || {}, this.init();
          }, m.init = function () {
            var t = this.$d;
            this.$y = t.getFullYear(), this.$M = t.getMonth(), this.$D = t.getDate(), this.$W = t.getDay(), this.$H = t.getHours(), this.$m = t.getMinutes(), this.$s = t.getSeconds(), this.$ms = t.getMilliseconds();
          }, m.$utils = function () {
            return O;
          }, m.isValid = function () {
            return !(this.$d.toString() === l);
          }, m.isSame = function (t, e) {
            var n = w(t);
            return this.startOf(e) <= n && n <= this.endOf(e);
          }, m.isAfter = function (t, e) {
            return w(t) < this.startOf(e);
          }, m.isBefore = function (t, e) {
            return this.endOf(e) < w(t);
          }, m.$g = function (t, e, n) {
            return O.u(t) ? this[e] : this.set(n, t);
          }, m.unix = function () {
            return Math.floor(this.valueOf() / 1e3);
          }, m.valueOf = function () {
            return this.$d.getTime();
          }, m.startOf = function (t, e) {
            var n = this,
              r = !!O.u(e) || e,
              h = O.p(t),
              l = function l(t, e) {
                var i = O.w(n.$u ? Date.UTC(n.$y, e, t) : new Date(n.$y, e, t), n);
                return r ? i : i.endOf(a);
              },
              $ = function $(t, e) {
                return O.w(n.toDate()[t].apply(n.toDate("s"), (r ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e)), n);
              },
              y = this.$W,
              M = this.$M,
              m = this.$D,
              v = "set" + (this.$u ? "UTC" : "");
            switch (h) {
              case c:
                return r ? l(1, 0) : l(31, 11);
              case f:
                return r ? l(1, M) : l(0, M + 1);
              case o:
                var g = this.$locale().weekStart || 0,
                  D = (y < g ? y + 7 : y) - g;
                return l(r ? m - D : m + (6 - D), M);
              case a:
              case d:
                return $(v + "Hours", 0);
              case u:
                return $(v + "Minutes", 1);
              case s:
                return $(v + "Seconds", 2);
              case i:
                return $(v + "Milliseconds", 3);
              default:
                return this.clone();
            }
          }, m.endOf = function (t) {
            return this.startOf(t, !1);
          }, m.$set = function (t, e) {
            var n,
              o = O.p(t),
              h = "set" + (this.$u ? "UTC" : ""),
              l = (n = {}, n[a] = h + "Date", n[d] = h + "Date", n[f] = h + "Month", n[c] = h + "FullYear", n[u] = h + "Hours", n[s] = h + "Minutes", n[i] = h + "Seconds", n[r] = h + "Milliseconds", n)[o],
              $ = o === a ? this.$D + (e - this.$W) : e;
            if (o === f || o === c) {
              var y = this.clone().set(d, 1);
              y.$d[l]($), y.init(), this.$d = y.set(d, Math.min(this.$D, y.daysInMonth())).$d;
            } else l && this.$d[l]($);
            return this.init(), this;
          }, m.set = function (t, e) {
            return this.clone().$set(t, e);
          }, m.get = function (t) {
            return this[O.p(t)]();
          }, m.add = function (r, h) {
            var d,
              l = this;
            r = Number(r);
            var $ = O.p(h),
              y = function y(t) {
                var e = w(l);
                return O.w(e.date(e.date() + Math.round(t * r)), l);
              };
            if ($ === f) return this.set(f, this.$M + r);
            if ($ === c) return this.set(c, this.$y + r);
            if ($ === a) return y(1);
            if ($ === o) return y(7);
            var M = (d = {}, d[s] = e, d[u] = n, d[i] = t, d)[$] || 1,
              m = this.$d.getTime() + r * M;
            return O.w(m, this);
          }, m.subtract = function (t, e) {
            return this.add(-1 * t, e);
          }, m.format = function (t) {
            var e = this,
              n = this.$locale();
            if (!this.isValid()) return n.invalidDate || l;
            var r = t || "YYYY-MM-DDTHH:mm:ssZ",
              i = O.z(this),
              s = this.$H,
              u = this.$m,
              a = this.$M,
              o = n.weekdays,
              f = n.months,
              h = function h(t, n, i, s) {
                return t && (t[n] || t(e, r)) || i[n].slice(0, s);
              },
              c = function c(t) {
                return O.s(s % 12 || 12, t, "0");
              },
              d = n.meridiem || function (t, e, n) {
                var r = t < 12 ? "AM" : "PM";
                return n ? r.toLowerCase() : r;
              },
              $ = {
                YY: String(this.$y).slice(-2),
                YYYY: this.$y,
                M: a + 1,
                MM: O.s(a + 1, 2, "0"),
                MMM: h(n.monthsShort, a, f, 3),
                MMMM: h(f, a),
                D: this.$D,
                DD: O.s(this.$D, 2, "0"),
                d: String(this.$W),
                dd: h(n.weekdaysMin, this.$W, o, 2),
                ddd: h(n.weekdaysShort, this.$W, o, 3),
                dddd: o[this.$W],
                H: String(s),
                HH: O.s(s, 2, "0"),
                h: c(1),
                hh: c(2),
                a: d(s, u, !0),
                A: d(s, u, !1),
                m: String(u),
                mm: O.s(u, 2, "0"),
                s: String(this.$s),
                ss: O.s(this.$s, 2, "0"),
                SSS: O.s(this.$ms, 3, "0"),
                Z: i
              };
            return r.replace(y, function (t, e) {
              return e || $[t] || i.replace(":", "");
            });
          }, m.utcOffset = function () {
            return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
          }, m.diff = function (r, d, l) {
            var $,
              y = O.p(d),
              M = w(r),
              m = (M.utcOffset() - this.utcOffset()) * e,
              v = this - M,
              g = O.m(this, M);
            return g = ($ = {}, $[c] = g / 12, $[f] = g, $[h] = g / 3, $[o] = (v - m) / 6048e5, $[a] = (v - m) / 864e5, $[u] = v / n, $[s] = v / e, $[i] = v / t, $)[y] || v, l ? g : O.a(g);
          }, m.daysInMonth = function () {
            return this.endOf(f).$D;
          }, m.$locale = function () {
            return D[this.$L];
          }, m.locale = function (t, e) {
            if (!t) return this.$L;
            var n = this.clone(),
              r = S(t, e, !0);
            return r && (n.$L = r), n;
          }, m.clone = function () {
            return O.w(this.$d, this);
          }, m.toDate = function () {
            return new Date(this.valueOf());
          }, m.toJSON = function () {
            return this.isValid() ? this.toISOString() : null;
          }, m.toISOString = function () {
            return this.$d.toISOString();
          }, m.toString = function () {
            return this.$d.toUTCString();
          }, M;
        }(),
        T = _.prototype;
      return w.prototype = T, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", f], ["$y", c], ["$D", d]].forEach(function (t) {
        T[t[1]] = function (e) {
          return this.$g(e, t[0], t[1]);
        };
      }), w.extend = function (t, e) {
        return t.$i || (t(e, _, w), t.$i = !0), w;
      }, w.locale = S, w.isDayjs = p, w.unix = function (t) {
        return w(1e3 * t);
      }, w.en = D[g], w.Ls = D, w.p = {}, w;
    });
  })(dayjs_min);
  var dayjs = dayjs_min.exports;

  var weekday$1 = {exports: {}};

  (function (module, exports) {
    !function (e, t) {
      module.exports = t() ;
    }(commonjsGlobal, function () {

      return function (e, t) {
        t.prototype.weekday = function (e) {
          var t = this.$locale().weekStart || 0,
            i = this.$W,
            n = (i < t ? i + 7 : i) - t;
          return this.$utils().u(e) ? n : this.subtract(n, "day").add(e, "day");
        };
      };
    });
  })(weekday$1);
  var weekday = weekday$1.exports;

  var customParseFormat$1 = {exports: {}};

  (function (module, exports) {
    !function (e, t) {
      module.exports = t() ;
    }(commonjsGlobal, function () {

      var e = {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A"
        },
        t = /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|YYYY|YY?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
        n = /\d\d/,
        r = /\d\d?/,
        i = /\d*[^-_:/,()\s\d]+/,
        o = {},
        s = function s(e) {
          return (e = +e) + (e > 68 ? 1900 : 2e3);
        };
      var a = function a(e) {
          return function (t) {
            this[e] = +t;
          };
        },
        f = [/[+-]\d\d:?(\d\d)?|Z/, function (e) {
          (this.zone || (this.zone = {})).offset = function (e) {
            if (!e) return 0;
            if ("Z" === e) return 0;
            var t = e.match(/([+-]|\d\d)/g),
              n = 60 * t[1] + (+t[2] || 0);
            return 0 === n ? 0 : "+" === t[0] ? -n : n;
          }(e);
        }],
        h = function h(e) {
          var t = o[e];
          return t && (t.indexOf ? t : t.s.concat(t.f));
        },
        u = function u(e, t) {
          var n,
            r = o.meridiem;
          if (r) {
            for (var i = 1; i <= 24; i += 1) {
              if (e.indexOf(r(i, 0, t)) > -1) {
                n = i > 12;
                break;
              }
            }
          } else n = e === (t ? "pm" : "PM");
          return n;
        },
        d = {
          A: [i, function (e) {
            this.afternoon = u(e, !1);
          }],
          a: [i, function (e) {
            this.afternoon = u(e, !0);
          }],
          S: [/\d/, function (e) {
            this.milliseconds = 100 * +e;
          }],
          SS: [n, function (e) {
            this.milliseconds = 10 * +e;
          }],
          SSS: [/\d{3}/, function (e) {
            this.milliseconds = +e;
          }],
          s: [r, a("seconds")],
          ss: [r, a("seconds")],
          m: [r, a("minutes")],
          mm: [r, a("minutes")],
          H: [r, a("hours")],
          h: [r, a("hours")],
          HH: [r, a("hours")],
          hh: [r, a("hours")],
          D: [r, a("day")],
          DD: [n, a("day")],
          Do: [i, function (e) {
            var t = o.ordinal,
              n = e.match(/\d+/);
            if (this.day = n[0], t) for (var r = 1; r <= 31; r += 1) {
              t(r).replace(/\[|\]/g, "") === e && (this.day = r);
            }
          }],
          M: [r, a("month")],
          MM: [n, a("month")],
          MMM: [i, function (e) {
            var t = h("months"),
              n = (h("monthsShort") || t.map(function (e) {
                return e.slice(0, 3);
              })).indexOf(e) + 1;
            if (n < 1) throw new Error();
            this.month = n % 12 || n;
          }],
          MMMM: [i, function (e) {
            var t = h("months").indexOf(e) + 1;
            if (t < 1) throw new Error();
            this.month = t % 12 || t;
          }],
          Y: [/[+-]?\d+/, a("year")],
          YY: [n, function (e) {
            this.year = s(e);
          }],
          YYYY: [/\d{4}/, a("year")],
          Z: f,
          ZZ: f
        };
      function c(n) {
        var r, i;
        r = n, i = o && o.formats;
        for (var s = (n = r.replace(/(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g, function (t, n, r) {
            var o = r && r.toUpperCase();
            return n || i[r] || e[r] || i[o].replace(/(\[[^\]]+])|(MMMM|MM|DD|dddd)/g, function (e, t, n) {
              return t || n.slice(1);
            });
          })).match(t), a = s.length, f = 0; f < a; f += 1) {
          var h = s[f],
            u = d[h],
            c = u && u[0],
            l = u && u[1];
          s[f] = l ? {
            regex: c,
            parser: l
          } : h.replace(/^\[|\]$/g, "");
        }
        return function (e) {
          for (var t = {}, n = 0, r = 0; n < a; n += 1) {
            var i = s[n];
            if ("string" == typeof i) r += i.length;else {
              var o = i.regex,
                f = i.parser,
                h = e.slice(r),
                u = o.exec(h)[0];
              f.call(t, u), e = e.replace(u, "");
            }
          }
          return function (e) {
            var t = e.afternoon;
            if (void 0 !== t) {
              var n = e.hours;
              t ? n < 12 && (e.hours += 12) : 12 === n && (e.hours = 0), delete e.afternoon;
            }
          }(t), t;
        };
      }
      return function (e, t, n) {
        n.p.customParseFormat = !0, e && e.parseTwoDigitYear && (s = e.parseTwoDigitYear);
        var r = t.prototype,
          i = r.parse;
        r.parse = function (e) {
          var t = e.date,
            r = e.utc,
            s = e.args;
          this.$u = r;
          var a = s[1];
          if ("string" == typeof a) {
            var f = !0 === s[2],
              h = !0 === s[3],
              u = f || h,
              d = s[2];
            h && (d = s[2]), o = this.$locale(), !f && d && (o = n.Ls[d]), this.$d = function (e, t, n) {
              try {
                if (["x", "X"].indexOf(t) > -1) return new Date(("X" === t ? 1e3 : 1) * e);
                var r = c(t)(e),
                  i = r.year,
                  o = r.month,
                  s = r.day,
                  a = r.hours,
                  f = r.minutes,
                  h = r.seconds,
                  u = r.milliseconds,
                  d = r.zone,
                  l = new Date(),
                  m = s || (i || o ? 1 : l.getDate()),
                  M = i || l.getFullYear(),
                  Y = 0;
                i && !o || (Y = o > 0 ? o - 1 : l.getMonth());
                var p = a || 0,
                  v = f || 0,
                  D = h || 0,
                  g = u || 0;
                return d ? new Date(Date.UTC(M, Y, m, p, v, D, g + 60 * d.offset * 1e3)) : n ? new Date(Date.UTC(M, Y, m, p, v, D, g)) : new Date(M, Y, m, p, v, D, g);
              } catch (e) {
                return new Date("");
              }
            }(t, a, r), this.init(), d && !0 !== d && (this.$L = this.locale(d).$L), u && t != this.format(a) && (this.$d = new Date("")), o = {};
          } else if (a instanceof Array) for (var l = a.length, m = 1; m <= l; m += 1) {
            s[1] = a[m - 1];
            var M = n.apply(this, s);
            if (M.isValid()) {
              this.$d = M.$d, this.$L = M.$L, this.init();
              break;
            }
            m === l && (this.$d = new Date(""));
          } else i.call(this, e);
        };
      };
    });
  })(customParseFormat$1);
  var customParseFormat = customParseFormat$1.exports;

  var DateTimePickerProps = {
    cancelBtn: {
      type: String,
      default: "\u53D6\u6D88"
    },
    confirmBtn: {
      type: String,
      default: ""
    },
    end: {
      type: [String, Number]
    },
    format: {
      type: String,
      default: "YYYY-MM-DD HH:mm:ss"
    },
    mode: {
      type: [String, Array],
      default: "date"
    },
    renderLabel: {
      type: Function
    },
    showWeek: Boolean,
    start: {
      type: [String, Number]
    },
    title: {
      type: String,
      default: "\u9009\u62E9\u65F6\u95F4"
    },
    value: {
      type: [String, Number]
    },
    modelValue: {
      type: [String, Number]
    },
    defaultValue: {
      type: [String, Number]
    },
    onCancel: Function,
    onChange: Function,
    onConfirm: Function,
    onPick: Function
  };

  var PickerProps = {
    cancelBtn: {
      type: [String, Object],
      default: "\u53D6\u6D88"
    },
    columns: {
      type: [Array, Function],
      default: function _default() {
        return [];
      },
      required: true
    },
    confirmBtn: {
      type: [String, Object],
      default: "\u786E\u8BA4"
    },
    renderLabel: {
      type: [String, Function]
    },
    title: {
      type: String,
      default: ""
    },
    value: {
      type: Array
    },
    modelValue: {
      type: Array
    },
    defaultValue: {
      type: Array
    },
    visible: Boolean,
    onCancel: Function,
    onChange: Function,
    onConfirm: Function,
    onPick: Function
  };

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }

  function ownKeys$q(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$q(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$q(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$q(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$C = config.prefix;
  var quartEaseOut = function quartEaseOut(t, b, c, d) {
    var tempT = t;
    return -c * ((tempT = tempT / d - 1) * tempT * tempT * tempT - 1) + b;
  };
  var DEFAULT_ITEM_HEIGHT = 40;
  var DEFAULT_HOLDER_HEIGHT = 200;
  var OFFSET_OF_BOUND = 60;
  var ANIMATION_TIME_LIMIT = 460;
  var ANIMATION_DURATION$1 = 150;
  var Picker$1 = /*#__PURE__*/function () {
    function Picker(options) {
      _classCallCheck(this, Picker);
      _defineProperty$2(this, "holder", void 0);
      _defineProperty$2(this, "options", void 0);
      _defineProperty$2(this, "list", null);
      _defineProperty$2(this, "elementItems", []);
      _defineProperty$2(this, "height", DEFAULT_HOLDER_HEIGHT);
      _defineProperty$2(this, "curIndex", 0);
      _defineProperty$2(this, "itemClassName", "");
      _defineProperty$2(this, "itemSelectedClassName", "");
      _defineProperty$2(this, "itemHeight", DEFAULT_ITEM_HEIGHT);
      _defineProperty$2(this, "lastMoveTime", 0);
      _defineProperty$2(this, "lastMoveStart", 0);
      _defineProperty$2(this, "stopInertiaMove", false);
      _defineProperty$2(this, "startY", 0);
      _defineProperty$2(this, "isPicking", false);
      _defineProperty$2(this, "offsetYOfStartBound", OFFSET_OF_BOUND);
      _defineProperty$2(this, "offsetYOfEndBound", -OFFSET_OF_BOUND);
      _defineProperty$2(this, "offsetY", 0);
      _defineProperty$2(this, "offsetYOfStart", 0);
      _defineProperty$2(this, "offsetYOfEnd", 0);
      _defineProperty$2(this, "onChange", void 0);
      if (!options.el) throw new Error("options el needed!");
      this.holder = options.el;
      this.options = options || {};
      this.onChange = options.onChange;
      this.init();
    }
    _createClass(Picker, [{
      key: "init",
      value: function init() {
        this.initScrollParams();
        this.setSelectedClassName();
        this.bindEvent();
      }
    }, {
      key: "updateItems",
      value: function updateItems() {
        this.elementItems = _toConsumableArray(this.holder.querySelectorAll("li"));
        var itemLen = this.elementItems.length;
        this.offsetYOfEnd = -this.itemHeight * (itemLen - 3);
        this.offsetYOfEndBound = -(this.itemHeight * (itemLen - 3) + OFFSET_OF_BOUND);
      }
    }, {
      key: "initScrollParams",
      value: function initScrollParams() {
        var _this$holder$querySel;
        this.list = this.holder.querySelector("ul");
        this.elementItems = _toConsumableArray(this.holder.querySelectorAll("li"));
        this.itemHeight = ((_this$holder$querySel = this.holder.querySelector("li")) === null || _this$holder$querySel === void 0 ? void 0 : _this$holder$querySel.offsetHeight) || DEFAULT_ITEM_HEIGHT;
        this.height = this.holder.offsetHeight || DEFAULT_HOLDER_HEIGHT;
        this.curIndex = this.options.defaultIndex || 0;
        this.itemClassName = "".concat(prefix$C, "-picker-item__item");
        this.itemSelectedClassName = "".concat(prefix$C, "-picker-item__item--selected");
        this.itemHeight = DEFAULT_ITEM_HEIGHT;
        this.startY = 0;
        this.isPicking = false;
        this.lastMoveTime = 0;
        this.lastMoveStart = 0;
        this.stopInertiaMove = false;
        var startOffsetY = (-this.curIndex + 2) * this.itemHeight;
        var itemLen = this.elementItems.length;
        this.setOffsetY(startOffsetY);
        this.offsetYOfStart = startOffsetY;
        this.offsetYOfEnd = -this.itemHeight * (itemLen - 3);
        this.offsetYOfStartBound = this.itemHeight * 2 + OFFSET_OF_BOUND;
        this.offsetYOfEndBound = -(this.itemHeight * (itemLen - 3) + OFFSET_OF_BOUND);
      }
    }, {
      key: "bindEvent",
      value: function bindEvent() {
        var _this = this;
        this.holder.addEventListener("touchstart", function (e) {
          return _this.touchStartHandler(e);
        }, false);
        this.holder.addEventListener("touchmove", function (e) {
          return _this.touchMoveHandler(e);
        }, false);
        this.holder.addEventListener("touchend", function (e) {
          return _this.touchEndHandler(e);
        }, false);
        this.holder.addEventListener("touchcancel", function (e) {
          return _this.touchEndHandler(e);
        }, false);
      }
    }, {
      key: "touchStartHandler",
      value: function touchStartHandler(event) {
        event.preventDefault();
        this.isPicking = true;
        if (!this.holder) return;
        if (this.list) this.list.style.transition = "";
        this.startY = event.changedTouches[0].pageY;
        this.updateInertiaParams(event, true);
      }
    }, {
      key: "touchMoveHandler",
      value: function touchMoveHandler(event) {
        event.preventDefault();
        if (!this.isPicking || !this.holder) return;
        var endY = event.changedTouches[0].pageY;
        var dragRange = endY - this.startY;
        this.updateInertiaParams(event, false);
        var moveOffsetY = (-this.curIndex + 2) * this.itemHeight + dragRange;
        this.setOffsetY(moveOffsetY);
      }
    }, {
      key: "touchEndHandler",
      value: function touchEndHandler(event) {
        event.preventDefault();
        this.isPicking = false;
        if (!this.holder) return;
        var point = event.changedTouches[0];
        var nowTime = event.timeStamp || Date.now();
        var moveTime = nowTime - this.lastMoveTime;
        if (moveTime > ANIMATION_TIME_LIMIT) {
          this.stopInertiaMove = false;
          this.endScroll();
          return;
        }
        var v = (point.pageY - this.lastMoveStart) / moveTime;
        var dir = v > 0 ? -1 : 1;
        var dampingCoefficient = 8e-4;
        var deceleration = -1 * dir * dampingCoefficient;
        var duration = Math.abs(v / deceleration);
        var endY = event.changedTouches[0].pageY;
        var dragRange = endY - this.startY;
        var dist = v * duration - Math.pow(duration, 2) * deceleration / 2 + dragRange;
        if (dist === 0) {
          this.stopInertiaMove = false;
          this.endScroll();
          return;
        }
        this.scrollDist(nowTime, this.offsetY, dist, duration);
      }
    }, {
      key: "updateInertiaParams",
      value: function updateInertiaParams(event, isStart) {
        var point = event.changedTouches[0];
        if (isStart) {
          this.lastMoveStart = point.pageY;
          this.lastMoveTime = event.timeStamp || Date.now();
        }
        this.stopInertiaMove = true;
      }
    }, {
      key: "scrollDist",
      value: function scrollDist(now, startOffsetY, dist, duration) {
        var _this2 = this;
        this.stopInertiaMove = false;
        var start = null;
        var inertiaMove = function inertiaMove(timestamp) {
          if (_this2.stopInertiaMove) {
            return;
          }
          if (!start) start = timestamp;
          var progress = timestamp - start;
          var newOffsetY = quartEaseOut(progress, startOffsetY, dist, duration);
          _this2.setOffsetY(newOffsetY);
          if (progress > duration || newOffsetY > _this2.offsetYOfStartBound || newOffsetY < _this2.offsetYOfEndBound) {
            _this2.endScroll();
          } else {
            window.requestAnimationFrame(inertiaMove);
          }
        };
        window.requestAnimationFrame(inertiaMove);
      }
    }, {
      key: "update",
      value: function update() {
        this.updateItems();
        var updateIndex = this.curIndex > this.elementItems.length - 1 ? 0 : this.curIndex;
        this.updateIndex(updateIndex);
      }
    }, {
      key: "updateIndex",
      value: function updateIndex(index, options) {
        var realOptions = _objectSpread$q({
          duration: 460,
          isChange: true
        }, options);
        this.curIndex = index;
        this.setSelectedClassName();
        var moveOffsetY = (-index + 2) * this.itemHeight;
        if (this.list) {
          this.list.style.transform = "translate(0,".concat(moveOffsetY, "px) translateZ(0)");
          this.list.style.transitionDuration = "".concat(realOptions.duration, "ms");
          this.list.style.transitionTimingFunction = "ease-out";
        }
        realOptions.isChange && this.onChange(index);
      }
    }, {
      key: "getCurIndex",
      value: function getCurIndex() {
        return this.curIndex;
      }
    }, {
      key: "fix3d",
      value: function fix3d(index) {
        for (var i = 0; i < this.elementItems.length; i++) {
          var deg = 25 * (-index + i);
          this.elementItems[i].style.transform = "rotateX(".concat(deg, "deg)");
          this.elementItems[i].style.webkitTransform = "rotateX(".concat(deg, "deg)");
        }
      }
    }, {
      key: "setSelectedClassName",
      value: function setSelectedClassName() {
        var _this3 = this;
        var regClass = new RegExp(this.itemClassName, "i");
        var regSelected = new RegExp(this.itemSelectedClassName, "i");
        this.elementItems.forEach(function (item, i) {
          var tempItem = item;
          var itemClass = tempItem.className;
          if (itemClass === "" || !itemClass) {
            tempItem.className = _this3.itemClassName;
          } else {
            if (!regClass.test(itemClass)) {
              tempItem.classList.add(_this3.itemClassName);
            }
            if (regSelected.test(itemClass)) {
              tempItem.classList.remove(_this3.itemSelectedClassName);
            }
          }
          if (_this3.curIndex === i) {
            tempItem.classList.add(_this3.itemSelectedClassName);
          }
        });
      }
    }, {
      key: "setOffsetY",
      value: function setOffsetY(offsetY) {
        this.offsetY = offsetY;
        if (this.list) {
          this.list.style.transform = "translate3d(0, ".concat(offsetY, "px, 0)");
        }
      }
    }, {
      key: "endScroll",
      value: function endScroll() {
        if (this.stopInertiaMove) return;
        var curIndex = 0;
        if (this.offsetY > this.offsetYOfStartBound) {
          curIndex = 0;
          if (this.list) {
            this.list.style.transition = "".concat(ANIMATION_DURATION$1, "ms ease-out");
          }
        } else if (this.offsetY < this.offsetYOfEndBound) {
          curIndex = this.elementItems.length - 1;
          if (this.list) {
            this.list.style.transition = "".concat(ANIMATION_DURATION$1, "ms ease-out");
          }
        } else {
          if (this.list) {
            this.list.style.transition = "".concat(ANIMATION_DURATION$1, "ms ease-out");
          }
          curIndex = 2 - Math.round(this.offsetY / this.itemHeight);
          if (curIndex < 0) curIndex = 0;
          if (curIndex > this.elementItems.length - 1) curIndex = this.elementItems.length - 1;
        }
        var offsetY = (-curIndex + 2) * this.itemHeight;
        this.setOffsetY(offsetY);
        if (curIndex !== this.curIndex) {
          this.curIndex = curIndex;
          this.setSelectedClassName();
          this.onChange(this.curIndex);
        }
      }
    }, {
      key: "destroy",
      value: function destroy() {
        delete this.holder;
      }
    }]);
    return Picker;
  }();
  var Picker$2 = Picker$1;

  function ownKeys$p(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$p(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$p(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$p(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$B = config.prefix;
  var name$z = "".concat(prefix$B, "-picker-item");
  var script$E = vue.defineComponent({
    name: name$z,
    props: {
      options: {
        type: Array,
        default: function _default() {
          return [];
        }
      },
      defaultValue: {
        type: [String, Number],
        default: void 0
      },
      renderLabel: {
        type: Function,
        default: void 0
      }
    },
    emits: ["pick"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var picker = null;
      var el = document.createElement("div");
      var root = vue.ref(el);
      var getIndexByValue = function getIndexByValue(val) {
        var defaultIndex = 0;
        if (val !== void 0) {
          defaultIndex = props.options.findIndex(function (item) {
            return item.value === val;
          });
        }
        return defaultIndex < 0 ? 0 : defaultIndex;
      };
      var className = vue.computed(function () {
        return "".concat(name$z);
      });
      var wrapperClassName = vue.computed(function () {
        return ["".concat(name$z, "__wrapper")];
      });
      var itemClassName = vue.computed(function () {
        return ["".concat(name$z, "__item")];
      });
      var setIndex = function setIndex(index) {
        if (picker) {
          picker.updateItems();
          picker.updateIndex(index, {
            isChange: false
          });
        }
      };
      var setValue = function setValue(value) {
        if (picker) {
          picker.updateItems();
          picker.updateIndex(getIndexByValue(value), {
            isChange: false
          });
        }
      };
      var setOptions = function setOptions() {
        picker && picker.update();
      };
      var setUpdateItems = function setUpdateItems() {
        picker && picker.updateItems();
      };
      context.expose({
        setIndex: setIndex,
        setValue: setValue,
        setOptions: setOptions,
        setUpdateItems: setUpdateItems
      });
      vue.onMounted(function () {
        picker = new Picker$2({
          el: root.value,
          defaultIndex: getIndexByValue(props.defaultValue) || 0,
          onChange: function onChange(index) {
            var curItem = props.options[index];
            var changeValue = {
              value: curItem.value,
              index: index
            };
            emitEvent("pick", changeValue);
          }
        });
      });
      return _objectSpread$p({
        root: root,
        className: className,
        wrapperClassName: wrapperClassName,
        itemClassName: itemClassName
      }, vue.toRefs(props));
    }
  });

  function render$D(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "root",
      class: vue.normalizeClass(_ctx.className)
    }, [vue.createElementVNode("ul", {
      class: vue.normalizeClass(_ctx.wrapperClassName)
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.options, function (option, index) {
      return vue.openBlock(), vue.createElementBlock("li", {
        key: index,
        class: vue.normalizeClass(_ctx.itemClassName)
      }, vue.toDisplayString(_ctx.renderLabel ? _ctx.renderLabel(option) : option.label), 3);
    }), 128))], 2)], 2);
  }

  script$E.render = render$D;

  var prefix$A = config.prefix;
  var name$y = "".concat(prefix$A, "-picker");
  var getIndexFromColumns = function getIndexFromColumns(columns, value, column) {
    var _columns$column;
    var resultIndex;
    (_columns$column = columns[column]) === null || _columns$column === void 0 ? void 0 : _columns$column.forEach(function (item, index) {
      if (item.value === value) {
        resultIndex = index;
      }
    });
    return resultIndex;
  };
  var script$D = vue.defineComponent({
    name: name$y,
    components: {
      TButton: _Button,
      PickerItem: script$E
    },
    props: PickerProps,
    emits: ["change", "cancel", "pick", "update:modelValue", "update:value"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var _toRefs = vue.toRefs(props),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        pickerValue = _useVModel2[0],
        setPickerValue = _useVModel2[1];
      var confirmButtonText = vue.computed(function () {
        return props.confirmBtn;
      });
      var cancelButtonText = vue.computed(function () {
        return props.cancelBtn;
      });
      var curValueArray = vue.ref(pickerValue.value.map(function (item) {
        return item;
      }));
      var realColumns = vue.computed(function () {
        if (typeof props.columns === "function") {
          var data = props.columns(curValueArray.value);
          return data;
        }
        return props.columns;
      });
      var lastTimeValueArray = _toConsumableArray(curValueArray.value);
      var curIndexArray = pickerValue.value.map(function (item, index) {
        return getIndexFromColumns(realColumns.value, item, index);
      });
      var lastTimeIndexArray = _toConsumableArray(curIndexArray);
      var pickerItemInstanceArray = vue.ref([]);
      vue.onMounted(function () {
        pickerItemInstanceArray.value = useChildSlots("t-picker-item").map(function (item) {
          return item.component;
        });
      });
      var handleConfirm = function handleConfirm(e) {
        lastTimeValueArray = _toConsumableArray(curValueArray.value);
        lastTimeIndexArray = _toConsumableArray(curIndexArray);
        setPickerValue(curValueArray.value);
        emitEvent("confirm", curValueArray.value, {
          index: curIndexArray
        });
      };
      var handleCancel = function handleCancel(e) {
        curValueArray.value = _toConsumableArray(lastTimeValueArray);
        curIndexArray = _toConsumableArray(lastTimeIndexArray);
        pickerItemInstanceArray.value.forEach(function (item, index) {
          var _item$exposed;
          (_item$exposed = item.exposed) === null || _item$exposed === void 0 ? void 0 : _item$exposed.setIndex(curIndexArray[index]);
        });
        emitEvent("cancel", {
          e: e
        });
      };
      var handlePick = function handlePick(context2, column) {
        if (curValueArray.value[column] !== context2.value) {
          curValueArray.value[column] = context2.value;
          curIndexArray[column] = context2.index;
          if (typeof props.columns === "function") {
            var result = props.columns(curValueArray.value);
            result.forEach(function (item, index) {
              if (!item.filter(function (ele) {
                return ele.value === curValueArray.value[index];
              }).length) {
                var _item$;
                curValueArray.value[index] = (_item$ = item[0]) === null || _item$ === void 0 ? void 0 : _item$.value;
                curIndexArray[index] = 0;
                vue.nextTick(function () {
                  var _pickerItemInstanceAr, _pickerItemInstanceAr2;
                  (_pickerItemInstanceAr = pickerItemInstanceArray.value[index]) === null || _pickerItemInstanceAr === void 0 ? void 0 : (_pickerItemInstanceAr2 = _pickerItemInstanceAr.exposed) === null || _pickerItemInstanceAr2 === void 0 ? void 0 : _pickerItemInstanceAr2.setIndex(0);
                });
              } else {
                vue.nextTick(function () {
                  var _pickerItemInstanceAr3, _pickerItemInstanceAr4;
                  (_pickerItemInstanceAr3 = pickerItemInstanceArray.value[index]) === null || _pickerItemInstanceAr3 === void 0 ? void 0 : (_pickerItemInstanceAr4 = _pickerItemInstanceAr3.exposed) === null || _pickerItemInstanceAr4 === void 0 ? void 0 : _pickerItemInstanceAr4.setUpdateItems();
                });
              }
            });
          }
          emitEvent("pick", curValueArray.value, {
            index: context2.index,
            column: column
          });
        }
      };
      var setValues = function setValues(values) {
        curValueArray.value = values;
        setPickerValue(values);
        vue.nextTick(function () {
          pickerItemInstanceArray.value.forEach(function (item, index) {
            var _item$exposed2;
            (_item$exposed2 = item.exposed) === null || _item$exposed2 === void 0 ? void 0 : _item$exposed2.setValue(values[index]);
          });
        });
      };
      useExpose({
        setValues: setValues
      });
      return {
        name: name$y,
        pickerValue: pickerValue,
        confirmButtonText: confirmButtonText,
        cancelButtonText: cancelButtonText,
        handleConfirm: handleConfirm,
        handleCancel: handleCancel,
        handlePick: handlePick,
        realColumns: realColumns
      };
    }
  });

  function render$C(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_button = vue.resolveComponent("t-button");
    var _component_picker_item = vue.resolveComponent("picker-item");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass("".concat(_ctx.name))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__toolbar"))
    }, [vue.createVNode(_component_t_button, {
      class: vue.normalizeClass("".concat(_ctx.name, "__cancel")),
      variant: "text",
      onClick: _ctx.handleCancel
    }, {
      default: vue.withCtx(function () {
        return [vue.createTextVNode(vue.toDisplayString(_ctx.cancelButtonText), 1)];
      }),
      _: 1
    }, 8, ["class", "onClick"]), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__title"))
    }, vue.toDisplayString(_ctx.title), 3), vue.createVNode(_component_t_button, {
      class: vue.normalizeClass("".concat(_ctx.name, "__confirm")),
      variant: "text",
      onClick: _ctx.handleConfirm
    }, {
      default: vue.withCtx(function () {
        return [vue.createTextVNode(vue.toDisplayString(_ctx.confirmButtonText), 1)];
      }),
      _: 1
    }, 8, ["class", "onClick"])], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__main"))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-item__group"))
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.realColumns, function (item, index) {
      return vue.openBlock(), vue.createBlock(_component_picker_item, {
        key: index,
        options: item,
        "default-value": _ctx.pickerValue[index],
        "render-label": _ctx.renderLabel,
        onPick: function onPick($event) {
          return _ctx.handlePick($event, index);
        }
      }, null, 8, ["options", "default-value", "render-label", "onPick"]);
    }), 128))], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__mask"))
    }, null, 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__indicator"))
    }, null, 2)], 2)], 2);
  }

  script$D.render = render$C;

  function ownKeys$o(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$o(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$o(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$o(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$z = config.prefix;
  var name$x = "".concat(prefix$z, "-cascade");
  var script$C = vue.defineComponent({
    name: name$x,
    components: {
      Picker: script$D
    },
    props: PickerProps,
    setup: function setup(props, context) {
      var pickerProps = vue.computed(function () {
        return _objectSpread$o({}, props);
      });
      var finalDepth = vue.ref(1);
      var finalSubOptionsRecord = vue.ref({});
      var generateCascadePickerColumns = function generateCascadePickerColumns(value, options, depth, subOptionsRecord) {
        var columns = [];
        columns.push(options.map(function (option) {
          return {
            label: option.label,
            value: option.value
          };
        }));
        for (var i = 0; i < depth - 1; i++) {
          var x = value[i];
          var subOptions = subOptionsRecord[x];
          if (!subOptions) {
            columns.push([]);
          } else {
            columns.push(subOptions.map(function (option) {
              return {
                label: option.label,
                value: option.value
              };
            }));
          }
        }
        return columns;
      };
      var initDepthAndRecord = function initDepthAndRecord(options) {
        var depth = 1;
        var subOptionsRecord = {};
        function traverse(option, currentDepth) {
          if (!option.children) {
            return;
          }
          subOptionsRecord[option.value] = option.children;
          var nextDepth = currentDepth + 1;
          if (nextDepth > depth) {
            depth = nextDepth;
          }
          option.children.forEach(function (option2) {
            traverse(option2, nextDepth);
          });
        }
        options.forEach(function (option) {
          traverse(option, 1);
        });
        finalDepth.value = depth;
        finalSubOptionsRecord.value = subOptionsRecord;
      };
      initDepthAndRecord(props.columns);
      return {
        name: name$x,
        finalDepth: finalDepth,
        finalSubOptionsRecord: finalSubOptionsRecord,
        pickerProps: pickerProps,
        generateCascadePickerColumns: generateCascadePickerColumns
      };
    }
  });

  function render$B(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_picker = vue.resolveComponent("picker");
    return vue.openBlock(), vue.createBlock(_component_picker, vue.mergeProps(_ctx.pickerProps, {
      columns: function columns(selected) {
        return _ctx.generateCascadePickerColumns(selected, _ctx.columns, _ctx.finalDepth, _ctx.finalSubOptionsRecord);
      }
    }), null, 16, ["columns"]);
  }

  script$C.render = render$B;

  var Picker = withInstall(script$D);
  var Cascade = withInstall(script$C);

  dayjs.extend(weekday);
  dayjs.extend(customParseFormat);
  var prefix$y = config.prefix;
  var name$w = "".concat(prefix$y, "-date-time-picker");
  var precisionRankRecord = {
    year: 0,
    month: 1,
    date: 2,
    hour: 3,
    minute: 4,
    second: 5
  };
  var script$B = vue.defineComponent({
    name: name$w,
    components: {
      TPicker: Picker
    },
    props: DateTimePickerProps,
    emits: ["change", "cancel", "confirm", "pick", "update:modelValue", "update:value"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var pickeInstance = vue.ref(null);
      var isChanged = vue.ref(false);
      var realDateValue = vue.ref();
      var className = vue.computed(function () {
        return ["".concat(name$w)];
      });
      var _toRefs = vue.toRefs(props),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        dateTimePickerValue = _useVModel2[0],
        setDateTimePickerValue = _useVModel2[1];
      var title = vue.computed(function () {
        return props.title || "\u9009\u62E9\u65F6\u95F4";
      });
      var confirmButtonText = vue.computed(function () {
        return props.confirmBtn || "\u786E\u5B9A";
      });
      var cancelButtonText = vue.computed(function () {
        return props.cancelBtn || "\u53D6\u6D88";
      });
      var start = vue.computed(function () {
        return props.start ? dayjs(props.start) : dayjs().subtract(10, "year");
      });
      var end = vue.computed(function () {
        return props.end ? dayjs(props.end) : dayjs().add(10, "year");
      });
      var renderLabel = vue.computed(function () {
        return props.renderLabel;
      });
      var isPrecision = function isPrecision(type) {
        if (!props.mode) {
          return false;
        }
        switch (type) {
          case "year":
            return typeof props.mode === "string" && precisionRankRecord[props.mode] >= 0 || _typeof$1(props.mode) === "object" && precisionRankRecord[props.mode[0]] >= 0;
          case "month":
            return typeof props.mode === "string" && precisionRankRecord[props.mode] >= 1 || _typeof$1(props.mode) === "object" && precisionRankRecord[props.mode[0]] >= 1;
          case "date":
            return typeof props.mode === "string" && precisionRankRecord[props.mode] >= 2 || _typeof$1(props.mode) === "object" && precisionRankRecord[props.mode[0]] >= 2;
          case "hour":
            return typeof props.mode === "string" && precisionRankRecord[props.mode] >= 3 || _typeof$1(props.mode) === "object" && precisionRankRecord[props.mode[1]] >= 3;
          case "minute":
            return typeof props.mode === "string" && precisionRankRecord[props.mode] >= 4 || _typeof$1(props.mode) === "object" && precisionRankRecord[props.mode[1]] >= 4;
          case "second":
            return typeof props.mode === "string" && precisionRankRecord[props.mode] >= 5 || _typeof$1(props.mode) === "object" && precisionRankRecord[props.mode[1]] >= 5;
          default:
            return true;
        }
      };
      var getPickerValueByDateTimePickerValue = function getPickerValueByDateTimePickerValue(value2) {
        var currentDate = dayjs(value2);
        var ret = [];
        Object.keys(precisionRankRecord).forEach(function (item) {
          if (isPrecision(item)) {
            ret.push("".concat(currentDate[item]()));
          }
        });
        return ret;
      };
      var pickerValue = vue.ref(getPickerValueByDateTimePickerValue(dateTimePickerValue.value || start.value.valueOf()));
      var lastTimePicker = _toConsumableArray(pickerValue.value);
      var currentPicker = _toConsumableArray(pickerValue.value);
      var getDateTimePickerValueByPickerValue = function getDateTimePickerValueByPickerValue(value2) {
        var valueLength = 0;
        var date = dayjs();
        Object.keys(precisionRankRecord).forEach(function (item, index) {
          if (isPrecision(item)) {
            date = date[item](value2[valueLength]);
            valueLength++;
          }
        });
        return date;
      };
      var generateDatePickerColumns = function generateDatePickerColumns(selected, min, max, renderLabel2) {
        var ret = [];
        var minYear = min.year();
        var minMonth = min.month() + 1;
        var minDay = min.date();
        var minHour = min.hour();
        var minMinute = min.minute();
        var minSecond = min.second();
        var maxYear = max.year();
        var maxMonth = max.month() + 1;
        var maxDay = max.date();
        var maxHour = max.hour();
        var maxMinute = max.minute();
        var maxSecond = max.second();
        var selectedDate = {};
        var selectedLength = 0;
        Object.keys(precisionRankRecord).forEach(function (item) {
          var newKey = "selected".concat(item.substr(0, 1).toUpperCase()).concat(item.substr(1, item.length));
          if (isPrecision(item)) {
            selectedDate[newKey] = parseInt("".concat(selected[selectedLength]), 10);
            selectedLength++;
          } else {
            selectedDate[newKey] = void 0;
          }
        });
        var isInMinYear = selectedDate.selectedYear === minYear;
        var isInMaxYear = selectedDate.selectedYear === maxYear;
        var isInMinMonth = isInMinYear && selectedDate.selectedMonth + 1 === minMonth;
        var isInMaxMonth = isInMaxYear && selectedDate.selectedMonth + 1 === maxMonth;
        var isInMinDay = isInMinMonth && selectedDate.selectedDay === minDay;
        var isInMaxDay = isInMaxMonth && selectedDate.selectedDay === maxDay;
        var isInMinHour = isInMinDay && selectedDate.selectedHour === minHour;
        var isInMaxHour = isInMaxDay && selectedDate.selectedHour === maxHour;
        var isInMinMinute = isInMinHour && selectedDate.selectedMinute === minMinute;
        var isInMaxMinute = isInMaxHour && selectedDate.selectedMinute === maxMinute;
        var generateColumn = function generateColumn(start2, end2, type) {
          var arr = [];
          for (var i = start2; i <= end2; i++) {
            var value2 = i.toString();
            arr.push({
              label: renderLabel2 ? renderLabel2(type, i) : value2,
              value: type === "month" ? "".concat(+value2 - 1) : value2
            });
          }
          ret.push(arr);
        };
        if (isPrecision("year")) {
          generateColumn(minYear, maxYear, "year");
        }
        if (isPrecision("month")) {
          var lower = isInMinYear ? minMonth : 1;
          var upper = isInMaxYear ? maxMonth : 12;
          generateColumn(lower, upper, "month");
        }
        if (isPrecision("date")) {
          var _lower = isInMinMonth ? minDay : 1;
          var _upper = isInMaxMonth ? maxDay : dayjs("".concat(selected[0], "-").concat(+selected[1] + 1)).daysInMonth();
          generateColumn(_lower, _upper, "date");
        }
        if (isPrecision("hour")) {
          var _lower2 = isInMinDay ? minHour : 0;
          var _upper2 = isInMaxDay ? maxHour : 23;
          generateColumn(_lower2, _upper2, "hour");
        }
        if (isPrecision("minute")) {
          var _lower3 = isInMinHour ? minMinute : 0;
          var _upper3 = isInMaxHour ? maxMinute : 59;
          generateColumn(_lower3, _upper3, "minute");
        }
        if (isPrecision("second")) {
          var _lower4 = isInMinMinute ? minSecond : 0;
          var _upper4 = isInMaxMinute ? maxSecond : 59;
          generateColumn(_lower4, _upper4, "second");
        }
        return ret;
      };
      var onConfirm = function onConfirm(value2, context2) {
        lastTimePicker = _toConsumableArray(currentPicker);
        var currentDate = getDateTimePickerValueByPickerValue(value2);
        emitEvent("confirm", dayjs(currentDate).format(props.format));
      };
      var onCancel = function onCancel(context2) {
        currentPicker = _toConsumableArray(lastTimePicker);
        emitEvent("cancel", {
          e: context2.e
        });
      };
      var onChange = function onChange(value2, context2) {
        lastTimePicker = _toConsumableArray(currentPicker);
        var currentDate = getDateTimePickerValueByPickerValue(value2);
        realDateValue.value = dayjs(currentDate).format(props.format);
        isChanged.value = true;
      };
      var onPick = function onPick(value2, context2) {
        currentPicker = value2;
        var currentDate = getDateTimePickerValueByPickerValue(value2);
        emitEvent("pick", dayjs(currentDate).format(props.format));
      };
      vue.watch(function () {
        return dateTimePickerValue;
      }, function (val) {
        vue.nextTick(function () {
          if (isChanged.value) {
            isChanged.value = false;
          } else {
            var _pickeInstance$value;
            (_pickeInstance$value = pickeInstance.value) === null || _pickeInstance$value === void 0 ? void 0 : _pickeInstance$value.setValues(getPickerValueByDateTimePickerValue(val.value || start.value.valueOf()));
            currentPicker = _toConsumableArray(vue.ref(getPickerValueByDateTimePickerValue(val.value || start.value.valueOf())).value);
            lastTimePicker = _toConsumableArray(currentPicker);
            isChanged.value = false;
          }
        });
      }, {
        immediate: true,
        deep: true
      });
      vue.watch(function () {
        return isChanged;
      }, function (val) {
        if (val.value) {
          setDateTimePickerValue(realDateValue.value);
        }
      }, {
        immediate: true,
        deep: true
      });
      return {
        pickeInstance: pickeInstance,
        className: className,
        confirmButtonText: confirmButtonText,
        cancelButtonText: cancelButtonText,
        title: title,
        start: start,
        end: end,
        renderLabel: renderLabel,
        pickerValue: pickerValue,
        currentPicker: currentPicker,
        realDateValue: realDateValue,
        isChanged: isChanged,
        generateDatePickerColumns: generateDatePickerColumns,
        onConfirm: onConfirm,
        onCancel: onCancel,
        onPick: onPick,
        onChange: onChange
      };
    }
  });

  function render$A(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_picker = vue.resolveComponent("t-picker");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.className)
    }, [vue.createVNode(_component_t_picker, {
      ref: "pickeInstance",
      value: _ctx.currentPicker,
      title: _ctx.title,
      "confirm-btn": _ctx.confirmButtonText,
      "cancel-btn": _ctx.cancelButtonText,
      columns: function columns(selected) {
        return _ctx.generateDatePickerColumns(selected, _ctx.start, _ctx.end, _ctx.renderLabel);
      },
      onChange: _ctx.onChange,
      onConfirm: _ctx.onConfirm,
      onCancel: _ctx.onCancel,
      onPick: _ctx.onPick
    }, null, 8, ["value", "title", "confirm-btn", "cancel-btn", "columns", "onChange", "onConfirm", "onCancel", "onPick"])], 2);
  }

  script$B.render = render$A;

  var _DateTimePicker = withInstall(script$B);

  var ToastProps = {
    direction: {
      type: String,
      default: "row",
      validator: function validator(val) {
        if (!val) return true;
        return ["row", "column"].includes(val);
      }
    },
    duration: {
      type: Number,
      default: 2e3
    },
    icon: {
      type: [String, Function]
    },
    message: {
      type: [String, Function]
    },
    overlayProps: {
      type: Object,
      default: function _default() {
        return {};
      }
    },
    placement: {
      type: String,
      default: "middle",
      validator: function validator(val) {
        if (!val) return true;
        return ["top", "middle", "bottom"].includes(val);
      }
    },
    preventScrollThrough: Boolean,
    showOverlay: Boolean,
    theme: {
      type: String,
      validator: function validator(val) {
        if (!val) return true;
        return ["loading", "success", "fail"].includes(val);
      }
    }
  };

  function ownKeys$n(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$n(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$n(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$n(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$x = config.prefix;
  var name$v = "".concat(prefix$x, "-toast");
  var script$A = vue.defineComponent({
    name: name$v,
    components: {
      TOverlay: Overlay,
      TNode: TNodeComponent
    },
    props: ToastProps,
    setup: function setup(props) {
      var toastTypeIcon = {
        loading: loading,
        success: checkCircle,
        fail: errorCircle
      };
      var internalInstance = vue.getCurrentInstance();
      var messageContent = vue.computed(function () {
        return renderTNode(internalInstance, "message");
      });
      var iconContent = vue.computed(function () {
        var iconNode = renderTNode(internalInstance, "icon");
        if (iconNode === void 0 && props.theme) {
          iconNode = vue.h(toastTypeIcon[props.theme]);
        }
        return iconNode;
      });
      var classes = vue.computed(function () {
        var _ref;
        return ["".concat(name$v), (_ref = {}, _defineProperty$2(_ref, "".concat(name$v, "--").concat(props.direction), props.direction), _defineProperty$2(_ref, "".concat(name$v, "--text"), !iconContent.value), _defineProperty$2(_ref, "".concat(name$v, "--icononly"), !messageContent.value && iconContent.value), _defineProperty$2(_ref, "".concat(name$v, "--top"), props.placement === "top"), _defineProperty$2(_ref, "".concat(name$v, "--middle"), props.placement === "middle"), _defineProperty$2(_ref, "".concat(name$v, "--bottom"), props.placement === "bottom"), _ref)];
      });
      var customOverlayProps = vue.computed(function () {
        var toastOverlayProps = {
          preventScrollThrough: props.preventScrollThrough,
          visible: props.showOverlay
        };
        return _objectSpread$n(_objectSpread$n({}, props.overlayProps), toastOverlayProps);
      });
      return _objectSpread$n({
        name: vue.ref(name$v),
        classes: classes,
        iconContent: iconContent,
        messageContent: messageContent,
        customOverlayProps: customOverlayProps
      }, vue.toRefs(props));
    }
  });

  function render$z(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_overlay = vue.resolveComponent("t-overlay");
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", null, [vue.createVNode(_component_t_overlay, vue.normalizeProps(vue.guardReactiveProps(_ctx.customOverlayProps)), null, 16), vue.createElementVNode("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"]), _ctx.messageContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__text"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.messageContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2)]);
  }

  script$A.render = render$z;

  function ownKeys$m(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$m(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$m(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$m(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var instance = null;
  var app;
  function Toast(props) {
    var root = document.createElement("div");
    document.body.appendChild(root);
    var propsObject = _objectSpread$m({
      duration: 2e3
    }, parseOptions(props));
    if (instance) {
      instance.clear();
    }
    instance = script$A;
    instance.clear = function () {
      clearTimeout(instance.timer);
      app.unmount();
      root.remove();
    };
    if (propsObject.duration && propsObject.duration > 0) {
      instance.timer = setTimeout(instance.clear, propsObject.duration);
    }
    app = vue.createApp(instance, _objectSpread$m({}, propsObject));
    app.mount(root);
    return instance;
  }
  Toast.clear = function () {
    if (instance) {
      instance.clear();
    }
  };
  ["loading", "success", "fail"].forEach(function (type) {
    if (!type) {
      return;
    }
    Toast[type] = function (options) {
      var props = {
        message: "",
        theme: type
      };
      if (typeof options === "string") {
        props.message = options;
      } else {
        props = _objectSpread$m(_objectSpread$m({}, props), options);
      }
      return Toast(props);
    };
  });
  function parseOptions(message) {
    if (typeof message === "string") {
      return {
        message: message
      };
    }
    return message;
  }
  Toast.install = function (app2) {
    app2.config.globalProperties.$toast = Toast;
  };
  var ToastPlugin = Toast;

  var searchProps = {
    action: {
      type: [String, Function],
      default: ""
    },
    center: Boolean,
    clearable: {
      type: Boolean,
      default: true
    },
    disabled: Boolean,
    focus: Boolean,
    label: {
      type: String,
      default: ""
    },
    leftIcon: {
      type: Function
    },
    placeholder: {
      type: String,
      default: ""
    },
    shape: {
      type: String,
      default: "square",
      validator: function validator(val) {
        if (!val) return true;
        return ["square", "round"].includes(val);
      }
    },
    value: {
      type: String
    },
    modelValue: {
      type: String
    },
    defaultValue: {
      type: String
    },
    onActionClick: Function,
    onBlur: Function,
    onChange: Function,
    onClear: Function,
    onFocus: Function,
    onSubmit: Function
  };

  function ownKeys$l(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$l(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$l(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$l(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$w = config.prefix;
  var name$u = "".concat(prefix$w, "-search");
  var script$z = vue.defineComponent({
    name: name$u,
    components: {
      TIconSearch: search,
      TIconClear: closeCircleFilled,
      TButton: _Button,
      TInput: _Input
    },
    props: searchProps,
    setup: function setup(props, _ref) {
      var emit = _ref.emit;
      var classes = vue.computed(function () {
        var _ref2;
        return _ref2 = {}, _defineProperty$2(_ref2, "".concat(name$u), true), _defineProperty$2(_ref2, "".concat(prefix$w, "-is-focused"), !state.labelActive), _ref2;
      });
      var _useDefault = useDefault(props, emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 1),
        value = _useDefault2[0];
      var shapeStyle = vue.computed(function () {
        return {
          borderRadius: props.shape === "square" ? void 0 : "50px"
        };
      });
      var searchInput = vue.ref();
      var state = vue.reactive({
        labelActive: !value.value,
        inputVal: ""
      });
      var doFocus = function doFocus() {
        var _searchInput$value;
        (_searchInput$value = searchInput.value) === null || _searchInput$value === void 0 ? void 0 : _searchInput$value.focus();
      };
      var onBlur = function onBlur(value2, context) {
        var _props$onBlur;
        state.labelActive = !value2;
        (_props$onBlur = props.onBlur) === null || _props$onBlur === void 0 ? void 0 : _props$onBlur.call(props, value2, {
          e: context.e
        });
      };
      var onClick = function onClick() {
        state.labelActive = !state.labelActive;
        doFocus();
      };
      var onFocus = function onFocus(value2, context) {
        var _props$onFocus;
        state.labelActive = false;
        (_props$onFocus = props.onFocus) === null || _props$onFocus === void 0 ? void 0 : _props$onFocus.call(props, value2, {
          e: context.e
        });
      };
      var onClear = function onClear(e) {
        var _props$onClear;
        searchInput.value.innerValue = "";
        (_props$onClear = props.onClear) === null || _props$onClear === void 0 ? void 0 : _props$onClear.call(props, {
          e: e
        });
      };
      var onCancel = function onCancel(e) {
        var _props$onActionClick;
        state.labelActive = !state.labelActive;
        (_props$onActionClick = props.onActionClick) === null || _props$onActionClick === void 0 ? void 0 : _props$onActionClick.call(props, {
          e: e
        });
      };
      var onChange = function onChange(value2, context) {
        var _props$onChange;
        (_props$onChange = props.onChange) === null || _props$onChange === void 0 ? void 0 : _props$onChange.call(props, value2, {
          e: context === null || context === void 0 ? void 0 : context.e
        });
      };
      extendAPI({
        doFocus: doFocus,
        blur: blur
      });
      return _objectSpread$l(_objectSpread$l({}, vue.toRefs(props)), {}, {
        name: vue.ref(name$u),
        classes: classes,
        shapeStyle: shapeStyle,
        onClick: onClick,
        onCancel: onCancel,
        onBlur: onBlur,
        onFocus: onFocus,
        onClear: onClear,
        onChange: onChange,
        state: state,
        value: value,
        searchInput: searchInput
      });
    }
  });

  function render$y(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_icon_search = vue.resolveComponent("t-icon-search");
    var _component_t_input = vue.resolveComponent("t-input");
    var _component_t_icon_clear = vue.resolveComponent("t-icon-clear");
    var _component_t_button = vue.resolveComponent("t-button");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__form")),
      style: vue.normalizeStyle(_ctx.shapeStyle)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__box"))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__icon-search"))
    }, [vue.renderSlot(_ctx.$slots, "leftIcon", {}, function () {
      return [vue.createVNode(_component_t_icon_search)];
    })], 2), vue.createVNode(_component_t_input, {
      ref: "searchInput",
      modelValue: _ctx.value,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
        return _ctx.value = $event;
      }),
      type: "search",
      class: vue.normalizeClass("".concat(_ctx.name, "__input")),
      autofocus: _ctx.focus,
      placeholder: _ctx.placeholder,
      onBlur: _ctx.onBlur,
      onFocus: _ctx.onFocus,
      onChange: _ctx.onChange
    }, null, 8, ["modelValue", "class", "autofocus", "placeholder", "onBlur", "onFocus", "onChange"]), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__icon-close"))
    }, [vue.createVNode(_component_t_icon_clear, {
      onClick: _ctx.onClear
    }, null, 8, ["onClick"])], 2)], 2), vue.withDirectives(vue.createElementVNode("label", {
      class: vue.normalizeClass("".concat(_ctx.name, "__label")),
      style: vue.normalizeStyle(_ctx.shapeStyle),
      onClick: _cache[1] || (_cache[1] = function () {
        return _ctx.onClick && _ctx.onClick.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__label-icon-search"))
    }, [vue.renderSlot(_ctx.$slots, "leftIcon", {}, function () {
      return [vue.createVNode(_component_t_icon_search)];
    })], 2), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, "__label-text"))
    }, vue.toDisplayString(_ctx.placeholder), 3)], 6), [[vue.vShow, _ctx.state.labelActive]])], 6), vue.renderSlot(_ctx.$slots, "action", {}, function () {
      return [_ctx.action ? vue.withDirectives((vue.openBlock(), vue.createBlock(_component_t_button, {
        key: 0,
        variant: "text",
        class: vue.normalizeClass("".concat(_ctx.name, "__cancel-button")),
        onClick: _ctx.onCancel
      }, {
        default: vue.withCtx(function () {
          return [vue.createTextVNode(vue.toDisplayString(_ctx.action), 1)];
        }),
        _: 1
      }, 8, ["class", "onClick"])), [[vue.vShow, !_ctx.state.labelActive]]) : vue.createCommentVNode("", true)];
    })], 2);
  }

  script$z.render = render$y;

  var _Search = withInstall(script$z);

  var StepsProps = {
    current: {
      type: [String, Number],
      default: void 0
    },
    modelValue: {
      type: [String, Number],
      default: void 0
    },
    defaultCurrent: {
      type: [String, Number],
      default: 0
    },
    layout: {
      type: String,
      default: "horizontal",
      validator: function validator(val) {
        return ["horizontal", "vertical"].includes(val);
      }
    },
    options: {
      type: Array
    },
    readonly: Boolean,
    theme: {
      type: String,
      default: "default",
      validator: function validator(val) {
        return ["default", "dot"].includes(val);
      }
    },
    onChange: Function
  };

  var StepItemProps = {
    content: {
      type: [String, Function],
      default: ""
    },
    icon: {
      type: [Boolean, Function],
      default: true
    },
    status: {
      type: String,
      default: "default",
      validator: function validator(val) {
        return ["default", "process", "finish", "error"].includes(val);
      }
    },
    title: {
      type: [String, Function],
      default: ""
    }
  };

  var prefix$v = config.prefix;
  var name$t = "".concat(prefix$v, "-step");
  var script$y = vue.defineComponent({
    name: name$t,
    components: {
      TNode: TNodeComponent
    },
    props: StepItemProps,
    setup: function setup(props) {
      var internalInstance = vue.getCurrentInstance();
      var proxy = internalInstance.proxy;
      var stepsProvide = vue.inject("stepsProvide", void 0);
      stepsProvide.relation(proxy);
      var index = vue.computed(function () {
        return stepsProvide.state.children.indexOf(proxy);
      });
      var theme = vue.computed(function () {
        return stepsProvide.theme;
      });
      var dot = vue.computed(function () {
        return theme.value === "dot" && stepsProvide.layout === "vertical";
      });
      var iconNode = vue.computed(function () {
        return renderTNode(internalInstance, "icon");
      });
      var iconContent = vue.computed(function () {
        if (dot.value) {
          return "";
        }
        if (props.status === "error") {
          return vue.h(close);
        }
        if (index.value < current.value && readonly.value) {
          return vue.h(check);
        }
        if (typeof iconNode.value === "boolean") {
          return iconNode.value ? index.value + 1 : "";
        }
        return iconNode.value;
      });
      var titleContent = vue.computed(function () {
        return renderTNode(internalInstance, "title");
      });
      var descContent = vue.computed(function () {
        return renderTNode(internalInstance, "content");
      });
      var extraContent = vue.computed(function () {
        return renderTNode(internalInstance, "extra");
      });
      var current = vue.computed(function () {
        return stepsProvide.current.value || stepsProvide.defaultCurrent || 0;
      });
      var stepsStatus = vue.computed(function () {
        return stepsProvide.status;
      });
      var readonly = vue.computed(function () {
        return stepsProvide.readonly;
      });
      var rootClassName = vue.computed(function () {
        return [name$t, _defineProperty$2({}, "".concat(name$t, "--default"), !readonly.value), _defineProperty$2({}, "".concat(name$t, "--").concat(currentStatus.value), currentStatus.value)];
      });
      var innerClassName = vue.computed(function () {
        if (typeof iconNode.value === "boolean") {
          return ["".concat(name$t, "__inner")];
        }
        return ["".concat(name$t, "__inner"), "".concat(name$t, "__inner__icon")];
      });
      var iconClassName = vue.computed(function () {
        return ["".concat(name$t, "-icon__number"), _defineProperty$2({}, "".concat(name$t, "-icon__dot"), dot.value)];
      });
      var currentStatus = vue.computed(function () {
        var status = props.status;
        if (status !== "default") return status;
        if (index.value < current.value) return "finish";
        if (index.value === current.value) return "process";
        return "";
      });
      var onClickIcon = function onClickIcon(e) {
        if (!readonly.value && !dot.value) {
          stepsProvide.onClickItem(index.value, current.value, e);
        }
      };
      return {
        dot: dot,
        name: name$t,
        theme: theme,
        index: index,
        current: current,
        readonly: readonly,
        iconNode: iconNode,
        stepsStatus: stepsStatus,
        descContent: descContent,
        iconContent: iconContent,
        onClickIcon: onClickIcon,
        titleContent: titleContent,
        extraContent: extraContent,
        rootClassName: rootClassName,
        currentStatus: currentStatus,
        iconClassName: iconClassName,
        innerClassName: innerClassName
      };
    }
  });

  function render$x(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.rootClassName)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass(_ctx.innerClassName),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.onClickIcon && _ctx.onClickIcon.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-icon"))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass(_ctx.iconClassName)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"])], 2)], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-content"))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-title"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.titleContent
    }, null, 8, ["content"])], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-description"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.descContent
    }, null, 8, ["content"])], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-extra"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.extraContent
    }, null, 8, ["content"])], 2)], 2)], 2)], 2);
  }

  script$y.render = render$x;

  function ownKeys$k(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$k(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$k(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$k(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$u = config.prefix;
  var name$s = "".concat(prefix$u, "-steps");
  var script$x = vue.defineComponent({
    name: name$s,
    components: {
      TStepItem: script$y
    },
    props: StepsProps,
    emits: ["update:current", "update:modelValue", "change"],
    setup: function setup(props, context) {
      var baseClass = vue.computed(function () {
        return [name$s, "".concat(name$s, "--").concat(props.layout), _defineProperty$2({}, "".concat(name$s, "--readonly"), props.readonly), "".concat(name$s, "--").concat(props.theme, "-anchor")];
      });
      var _useDefault = useDefault(props, context.emit, "current", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 2),
        current = _useDefault2[0],
        setCurrent = _useDefault2[1];
      var state = vue.reactive({
        children: []
      });
      var relation = function relation(child) {
        child && state.children.push(child);
      };
      var onClickItem = function onClickItem(cur, prev, e) {
        setCurrent(cur, prev, {
          e: e
        });
      };
      vue.provide("stepsProvide", _objectSpread$k(_objectSpread$k({}, props), {}, {
        state: state,
        current: current,
        relation: relation,
        onClickItem: onClickItem
      }));
      return _objectSpread$k({
        baseClass: baseClass,
        onClickItem: onClickItem
      }, vue.toRefs(props));
    }
  });

  function render$w(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_step_item = vue.resolveComponent("t-step-item");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.baseClass)
    }, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
      return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.options, function (item, index) {
        return vue.openBlock(), vue.createBlock(_component_t_step_item, {
          key: index,
          title: item.title,
          content: item.content,
          icon: item.icon,
          status: item.status
        }, null, 8, ["title", "content", "icon", "status"]);
      }), 128))];
    })], 2);
  }

  script$x.render = render$w;

  var Step = withInstall(script$y);
  var Steps = withInstall(script$x);

  var IndexesProps = {
    height: {
      type: Number
    },
    list: {
      type: Array,
      default: function _default() {
        return [];
      },
      required: true
    },
    sticky: {
      type: Boolean,
      default: true
    },
    onSelect: Function
  };

  var name$r = "".concat(config.prefix, "-indexes-anchor");
  var script$w = vue.defineComponent({
    name: name$r,
    components: {
      TNode: TNodeComponent
    },
    props: {
      anchorStyle: {
        type: String,
        default: ""
      }
    },
    setup: function setup(props, context) {
      var boxClasses = name$r;
      var stickyContent = vue.computed(function () {
        return renderContent(vue.getCurrentInstance(), "default", "");
      });
      templateRef("boxRef");
      var contentRef = templateRef("contentRef");
      var _useElementBounding = useElementBounding(contentRef),
        height = _useElementBounding.height;
      var boxStyles = vue.computed(function () {
        return "height:".concat(height.value, "px;");
      });
      return {
        boxClasses: boxClasses,
        boxStyles: boxStyles,
        stickyContent: stickyContent
      };
    }
  });

  function render$v(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "boxRef",
      class: vue.normalizeClass(_ctx.boxClasses),
      style: vue.normalizeStyle(_ctx.boxStyles)
    }, [vue.createElementVNode("div", {
      ref: "contentRef",
      class: "t-indexes__anchor",
      style: vue.normalizeStyle(_ctx.anchorStyle)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.stickyContent
    }, null, 8, ["content"])], 4)], 6);
  }

  script$w.render = render$v;

  var prefix$t = config.prefix;
  var componentName$2 = "".concat(prefix$t, "-indexes-cell");
  var script$v = vue.defineComponent({
    name: componentName$2,
    components: {
      TCell: _Cell
    },
    props: {
      title: {
        type: String,
        default: ""
      },
      key: {
        type: String,
        default: ""
      },
      value: {
        type: String,
        default: ""
      },
      link: {
        type: Boolean,
        default: false
      }
    },
    setup: function setup(props, context) {
      var currentSidebar = "";
      var state = vue.reactive({
        title: props.title,
        value: props.value,
        link: props.link,
        key: props.key,
        componentName: componentName$2
      });
      return {
        state: state,
        currentSidebar: currentSidebar
      };
    }
  });

  function render$u(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_cell = vue.resolveComponent("t-cell");
    return vue.openBlock(), vue.createBlock(_component_t_cell, {
      class: vue.normalizeClass(_ctx.state.componentName),
      "data-key": _ctx.state.key,
      title: _ctx.state.title,
      value: _ctx.state.value,
      link: _ctx.state.link
    }, null, 8, ["class", "data-key", "title", "value", "link"]);
  }

  script$v.render = render$u;

  function ownKeys$j(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$j(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$j(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$j(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$s = config.prefix;
  var componentName$1 = "".concat(prefix$s, "-indexes");
  var script$u = vue.defineComponent({
    name: componentName$1,
    components: {
      indexesAnchor: script$w,
      TIndexesCell: script$v
    },
    props: IndexesProps,
    emits: ["select"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var timeOut;
      var indexesRoot = vue.ref(null);
      var state = vue.reactive({
        componentName: componentName$1,
        list: props.list,
        showSidebarTip: false,
        activeSidebar: "",
        activeIndex: -1
      });
      var anchorGroup = vue.ref([]);
      var setAnchorGroupRefs = function setAnchorGroupRefs(index) {
        return function (el) {
          anchorGroup.value[index] = el;
        };
      };
      var anchor = vue.ref([]);
      var anchorStyle = vue.reactive([]);
      var setAnchorRefs = function setAnchorRefs(index) {
        return function (el) {
          anchor.value[index] = el;
        };
      };
      var indexesRootStyle = vue.computed(function () {
        if (typeof props.height !== "number") {
          return {};
        }
        var height = Number(props.height);
        return {
          height: height === 0 ? 0 : "".concat(height, "px")
        };
      });
      var scrollToView = function scrollToView() {
        var _targets$, _targets$$scrollIntoV;
        var children = anchorGroup.value;
        var targets = children.filter(function (ele) {
          var dataset = ele.dataset;
          return dataset && dataset.index === state.activeSidebar;
        });
        (_targets$ = targets[0]) === null || _targets$ === void 0 ? void 0 : (_targets$$scrollIntoV = _targets$.scrollIntoView) === null || _targets$$scrollIntoV === void 0 ? void 0 : _targets$$scrollIntoV.call(_targets$);
      };
      var calcSticky = function calcSticky(indexesRootTop) {
        var children = anchorGroup.value;
        for (var i = 0; i < children.length; i++) {
          var _anchor$value, _anchor$value$$el$get;
          var _children$i$getBoundi = children[i].getBoundingClientRect(),
            childTop = _children$i$getBoundi.top,
            width = _children$i$getBoundi.width;
          anchorStyle[i] = "z-index: ".concat(i + 1, ";");
          if (childTop < indexesRootTop && i === state.activeIndex) {
            anchorStyle[i] += "position:fixed;top:".concat(indexesRootTop, "px;width: ").concat(width, "px;");
          } else {
            anchorStyle[i] += "";
          }
          var anchorHeight = (_anchor$value = anchor.value[i - 1]) === null || _anchor$value === void 0 ? void 0 : (_anchor$value$$el$get = _anchor$value.$el.getBoundingClientRect()) === null || _anchor$value$$el$get === void 0 ? void 0 : _anchor$value$$el$get.height;
          var diff = childTop - indexesRootTop - anchorHeight;
          if (i - 1 === state.activeIndex && diff < 0) {
            anchorStyle[i - 1] += "transform: translateY(".concat(diff, "px)");
          }
        }
      };
      var calcChildPosition = function calcChildPosition(scrollTop) {
        var _children$currentInde;
        var children = anchorGroup.value;
        var currentIndex = -1;
        for (var i = 0; i < children.length - 1; i++) {
          if (scrollTop < children[i + 1].offsetTop) {
            currentIndex = i;
            break;
          }
        }
        if (scrollTop >= children[children.length - 1].offsetTop) {
          currentIndex = children.length - 1;
        }
        state.activeIndex = currentIndex;
        state.activeSidebar = (_children$currentInde = children[currentIndex].dataset.index) !== null && _children$currentInde !== void 0 ? _children$currentInde : "";
      };
      var setActiveSidebarAndTip = function setActiveSidebarAndTip(index) {
        state.activeSidebar = index;
        state.showSidebarTip = true;
      };
      vue.watchEffect(function () {
        if (state.showSidebarTip) {
          clearSidebarTip();
        }
      });
      var handleSidebarItemClick = function handleSidebarItemClick(index) {
        setActiveSidebarAndTip(index);
        scrollToView();
      };
      var handleSidebarTouchstart = function handleSidebarTouchstart(event) {
        event.stopPropagation();
        var touches = event.touches;
        touches[0].clientX;
        touches[0].clientX;
      };
      var handleSidebarTouchmove = function handleSidebarTouchmove(event) {
        event.preventDefault();
        var touches = event.touches;
        var _touches$ = touches[0],
          clientX = _touches$.clientX,
          clientY = _touches$.clientY;
        var target = document.elementFromPoint(clientX, clientY);
        if (target && target.className === "".concat(componentName$1, "__sidebar-item") && target instanceof HTMLElement) {
          var index = target.dataset.index;
          if (index !== void 0 && state.activeSidebar !== index) {
            setActiveSidebarAndTip(index);
            scrollToView();
          }
        }
      };
      var handleRootScroll = function handleRootScroll(event) {
        if (indexesRoot.value) {
          calcChildPosition(indexesRoot.value.scrollTop);
          if (props.sticky) {
            var _indexesRoot$value$ge, _indexesRoot$value, _indexesRoot$value$ge2;
            var indexesRootTop = (_indexesRoot$value$ge = (_indexesRoot$value = indexesRoot.value) === null || _indexesRoot$value === void 0 ? void 0 : (_indexesRoot$value$ge2 = _indexesRoot$value.getBoundingClientRect()) === null || _indexesRoot$value$ge2 === void 0 ? void 0 : _indexesRoot$value$ge2.top) !== null && _indexesRoot$value$ge !== void 0 ? _indexesRoot$value$ge : 0;
            calcSticky(indexesRootTop);
          }
        }
      };
      var clearSidebarTip = function clearSidebarTip() {
        if (state.showSidebarTip && state.activeSidebar) {
          timeOut && clearTimeout(timeOut);
          timeOut = window.setTimeout(function () {
            state.showSidebarTip = false;
          }, 1e3);
        }
      };
      var handleCellClick = function handleCellClick(indexes) {
        emitEvent("select", indexes);
      };
      vue.onMounted(function () {
        var children = anchorGroup.value;
        if (children.length > 0) {
          var index = children[0].dataset.index;
          if (index !== void 0) {
            state.activeSidebar = index;
          }
        }
      });
      vue.onBeforeUnmount(function () {
        timeOut && clearTimeout(timeOut);
      });
      return _objectSpread$j(_objectSpread$j({}, vue.toRefs(state)), {}, {
        indexesRoot: indexesRoot,
        indexesRootStyle: indexesRootStyle,
        anchorGroup: anchorGroup,
        anchorStyle: anchorStyle,
        setAnchorGroupRefs: setAnchorGroupRefs,
        setAnchorRefs: setAnchorRefs,
        handleSidebarItemClick: handleSidebarItemClick,
        handleSidebarTouchmove: handleSidebarTouchmove,
        handleSidebarTouchstart: handleSidebarTouchstart,
        handleRootScroll: handleRootScroll,
        handleCellClick: handleCellClick
      });
    }
  });

  var _hoisted_1$c = ["data-index", "onClick"];
  var _hoisted_2$4 = ["data-index"];
  function render$t(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_indexes_anchor = vue.resolveComponent("indexes-anchor");
    var _component_t_indexes_cell = vue.resolveComponent("t-indexes-cell");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "indexesRoot",
      style: vue.normalizeStyle(_ctx.indexesRootStyle),
      class: vue.normalizeClass(_ctx.componentName),
      onScroll: _cache[2] || (_cache[2] = function () {
        return _ctx.handleRootScroll && _ctx.handleRootScroll.apply(_ctx, arguments);
      })
    }, [_ctx.list.length > 0 ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.componentName, "__sidebar")),
      onTouchstart: _cache[0] || (_cache[0] = function () {
        return _ctx.handleSidebarTouchstart && _ctx.handleSidebarTouchstart.apply(_ctx, arguments);
      }),
      onTouchmove: _cache[1] || (_cache[1] = function () {
        return _ctx.handleSidebarTouchmove && _ctx.handleSidebarTouchmove.apply(_ctx, arguments);
      })
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.list, function (item) {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: item.index,
        class: vue.normalizeClass(["".concat(_ctx.componentName, "__sidebar-item"), _ctx.activeSidebar === item.index ? "".concat(_ctx.componentName, "__sidebar-item--active") : ""]),
        "data-index": item.index,
        onClick: vue.withModifiers(function ($event) {
          return _ctx.handleSidebarItemClick(item.index);
        }, ["prevent"])
      }, [vue.createTextVNode(vue.toDisplayString(item.index) + " ", 1), _ctx.showSidebarTip && _ctx.activeSidebar === item.index ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass("".concat(_ctx.componentName, "__sidebar-tip"))
      }, [vue.createElementVNode("span", {
        class: vue.normalizeClass("".concat(_ctx.componentName, "__sidebar-tip-text"))
      }, vue.toDisplayString(_ctx.activeSidebar), 3)], 2)) : vue.createCommentVNode("", true)], 10, _hoisted_1$c);
    }), 128))], 34)) : vue.createCommentVNode("", true), (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.list, function (item, index) {
      return vue.openBlock(), vue.createElementBlock("div", {
        ref_for: true,
        ref: _ctx.setAnchorGroupRefs(index),
        key: item.index,
        "data-index": item.index
      }, [vue.createVNode(_component_indexes_anchor, {
        ref_for: true,
        ref: _ctx.setAnchorRefs(index),
        "anchor-style": _ctx.anchorStyle[index]
      }, {
        default: vue.withCtx(function () {
          var _item$title;
          return [vue.createTextVNode(vue.toDisplayString((_item$title = item.title) !== null && _item$title !== void 0 ? _item$title : item.index), 1)];
        }),
        _: 2
      }, 1032, ["anchor-style"]), vue.createElementVNode("div", {
        class: vue.normalizeClass(["".concat(_ctx.componentName, "__group")])
      }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(item.children, function (child, childrenIndex) {
        return vue.openBlock(), vue.createBlock(_component_t_indexes_cell, {
          key: child.title,
          value: String(child.title),
          title: child.title,
          link: true,
          bordered: false,
          onClick: function onClick($event) {
            return _ctx.handleCellClick({
              groupIndex: item.index,
              childrenIndex: childrenIndex
            });
          }
        }, null, 8, ["value", "title", "onClick"]);
      }), 128))], 2)], 8, _hoisted_2$4);
    }), 128))], 38);
  }

  script$u.render = render$t;

  var Indexes = withInstall(script$u);
  var IndexesCell = withInstall(script$v);

  var TagProps = {
    closable: Boolean,
    content: {
      type: [String, Number, Function]
    },
    disabled: Boolean,
    icon: {
      type: Function,
      default: void 0
    },
    maxWidth: {
      type: [String, Number]
    },
    shape: {
      type: String,
      default: "square",
      validator: function validator(val) {
        return ["square", "round", "mark"].includes(val);
      }
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator(val) {
        return ["small", "medium", "large"].includes(val);
      }
    },
    theme: {
      type: String,
      default: "default",
      validator: function validator(val) {
        return ["default", "primary", "warning", "danger", "success"].includes(val);
      }
    },
    variant: {
      type: String,
      default: "dark",
      validator: function validator(val) {
        return ["dark", "light", "outline", "light-outline"].includes(val);
      }
    },
    onClick: Function,
    onClose: Function
  };

  var prefix$r = config.prefix;
  var name$q = "".concat(prefix$r, "-tag");
  var Tag$1 = vue.defineComponent({
    name: name$q,
    components: {
      CloseIcon: close,
      TNode: TNodeComponent
    },
    props: TagProps,
    emits: ["close", "click"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var tagContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var iconContent = vue.computed(function () {
        return renderTNode(internalInstance, "icon");
      });
      var baseClass = name$q;
      var tagStyle = vue.computed(function () {
        return props.maxWidth ? {
          maxWidth: typeof props.maxWidth === "number" ? "".concat(props.maxWidth, "px") : props.maxWidth
        } : {};
      });
      var classes = vue.computed(function () {
        var _ref;
        return ["".concat(baseClass), "".concat(baseClass, "--theme-").concat(props.theme), "".concat(baseClass, "--shape-").concat(props.shape), "".concat(baseClass, "--variant-").concat(props.variant), "".concat(baseClass, "--size-").concat(props.size), (_ref = {}, _defineProperty$2(_ref, "".concat(prefix$r, "-is-closable ").concat(baseClass, "--closable"), props.closable), _defineProperty$2(_ref, "".concat(prefix$r, "-is-disabled ").concat(baseClass, "--disabled"), props.disabled), _ref)];
      });
      var onClickClose = function onClickClose(e) {
        if (!props.disabled) {
          emitEvent("close", {
            e: e
          });
        }
      };
      var handleClick = function handleClick(e) {
        if (!props.disabled) {
          emitEvent("click", {
            e: e
          });
        }
      };
      return {
        baseClass: baseClass,
        classes: classes,
        tagStyle: tagStyle,
        onClickClose: onClickClose,
        handleClick: handleClick,
        iconContent: iconContent,
        tagContent: tagContent
      };
    }
  });
  var script$t = Tag$1;

  var _hoisted_1$b = ["aria-disabled"];
  function render$s(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_close_icon = vue.resolveComponent("close-icon");
    return vue.openBlock(), vue.createElementBlock("span", {
      class: vue.normalizeClass(_ctx.classes),
      style: vue.normalizeStyle(_ctx.tagStyle),
      "aria-disabled": _ctx.disabled,
      role: "button",
      onClick: _cache[1] || (_cache[1] = function () {
        return _ctx.handleClick && _ctx.handleClick.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.baseClass, "__icon"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"])], 2), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.baseClass, "__text"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.tagContent
    }, null, 8, ["content"])], 2), _ctx.closable && !_ctx.disabled ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.baseClass, "__icon-close")),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.onClickClose && _ctx.onClickClose.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_close_icon)], 2)) : vue.createCommentVNode("", true)], 14, _hoisted_1$b);
  }

  script$t.render = render$s;

  var CheckTagProps = {
    checked: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultChecked: {
      type: Boolean,
      default: void 0
    },
    closable: Boolean,
    content: {
      type: [String, Number, Function]
    },
    disabled: Boolean,
    icon: {
      type: Function
    },
    shape: {
      type: String,
      default: "square",
      validator: function validator(val) {
        return ["square", "round", "mark"].includes(val);
      }
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator(val) {
        return ["small", "medium", "large"].includes(val);
      }
    },
    onChange: Function,
    onClick: Function
  };

  var prefix$q = config.prefix;
  var name$p = "".concat(prefix$q, "-check-tag");
  var CheckTag$1 = vue.defineComponent({
    name: name$p,
    components: {
      CloseIcon: close,
      TNode: TNodeComponent
    },
    props: CheckTagProps,
    emits: ["change", "click", "update:checked", "update:modelValue"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var tagContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var iconContent = vue.computed(function () {
        return renderTNode(internalInstance, "icon");
      });
      var baseClass = "".concat(prefix$q, "-tag");
      var _toRefs = vue.toRefs(props),
        checked = _toRefs.checked,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(checked, modelValue, props.defaultChecked, props.onChange, "checked"),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        innerChecked = _useVModel2[0],
        setInnerChecked = _useVModel2[1];
      var classes = vue.computed(function () {
        var _ref;
        return ["".concat(baseClass), "".concat(baseClass, "--checkable"), "".concat(baseClass, "--shape-").concat(props.shape), "".concat(baseClass, "--size-").concat(props.size), (_ref = {}, _defineProperty$2(_ref, "".concat(prefix$q, "-is-closable ").concat(baseClass, "--closable"), props.closable), _defineProperty$2(_ref, "".concat(prefix$q, "-is-disabled ").concat(baseClass, "--disabled"), props.disabled), _defineProperty$2(_ref, "".concat(prefix$q, "-is-checked ").concat(baseClass, "--checked"), !props.disabled && innerChecked.value), _ref)];
      });
      var onClickClose = function onClickClose(e) {
        if (!props.disabled) {
          emitEvent("close", {
            e: e
          });
        }
      };
      var handleClick = function handleClick(e) {
        if (!props.disabled) {
          emitEvent("click", {
            e: e
          });
          setInnerChecked(!innerChecked.value);
        }
      };
      return {
        baseClass: baseClass,
        classes: classes,
        onClickClose: onClickClose,
        handleClick: handleClick,
        iconContent: iconContent,
        tagContent: tagContent,
        innerChecked: innerChecked
      };
    }
  });
  var script$s = CheckTag$1;

  var _hoisted_1$a = ["aria-disabled"];
  function render$r(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_close_icon = vue.resolveComponent("close-icon");
    return vue.openBlock(), vue.createElementBlock("span", {
      class: vue.normalizeClass(_ctx.classes),
      "aria-disabled": _ctx.disabled,
      role: "button",
      onClick: _cache[1] || (_cache[1] = function () {
        return _ctx.handleClick && _ctx.handleClick.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.baseClass, "__icon"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"])], 2), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.baseClass, "__text"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.tagContent
    }, null, 8, ["content"])], 2), _ctx.closable && !_ctx.disabled ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.baseClass, "__icon-close")),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.onClickClose && _ctx.onClickClose.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_close_icon)], 2)) : vue.createCommentVNode("", true)], 10, _hoisted_1$a);
  }

  script$s.render = render$r;

  var Tag = withInstall(script$t);
  var CheckTag = withInstall(script$s);

  var TabBarProps = {
    bordered: {
      type: Boolean,
      default: true
    },
    fixed: {
      type: Boolean,
      default: true
    },
    value: {
      type: [String, Number, Array],
      default: void 0
    },
    modelValue: {
      type: [String, Number, Array],
      default: void 0
    },
    defaultValue: {
      type: [String, Number, Array],
      default: void 0
    },
    onChange: Function
  };

  var prefix$p = config.prefix;
  var name$o = "".concat(prefix$p, "-tab-bar");
  var script$r = vue.defineComponent({
    name: name$o,
    props: TabBarProps,
    emits: ["update:value", "update:modelValue", "change"],
    setup: function setup(props, context) {
      var _useDefault = useDefault(props, context.emit, "value", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 1),
        activeValue = _useDefault2[0];
      var defaultIndex = vue.ref(-1);
      var updateChild = function updateChild(currentValue) {
        activeValue.value = currentValue;
      };
      var tabbarClass = vue.computed(function () {
        var _ref;
        return ["".concat(name$o), (_ref = {}, _defineProperty$2(_ref, "".concat(name$o, "--bordered"), props.bordered), _defineProperty$2(_ref, "".concat(name$o, "--fixed"), props.fixed), _ref)];
      });
      vue.provide("tab-bar", {
        defaultIndex: defaultIndex,
        activeValue: activeValue,
        updateChild: updateChild
      });
      return {
        tabbarClass: tabbarClass
      };
    }
  });

  function render$q(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.tabbarClass),
      role: "tablist"
    }, [vue.renderSlot(_ctx.$slots, "default")], 2);
  }

  script$r.render = render$q;

  var initName = function initName(defaultIndex) {
    var _instance$props;
    var index = defaultIndex;
    var instance = vue.getCurrentInstance();
    if (typeof (instance === null || instance === void 0 ? void 0 : (_instance$props = instance.props) === null || _instance$props === void 0 ? void 0 : _instance$props.value) !== "undefined") {
      var _instance$props2;
      return instance === null || instance === void 0 ? void 0 : (_instance$props2 = instance.props) === null || _instance$props2 === void 0 ? void 0 : _instance$props2.value;
    }
    index.value += 1;
    return index.value;
  };

  var TabBarItemProps = {
    badgeProps: {
      type: Object
    },
    icon: {
      type: Function
    },
    subTabBar: {
      type: Array
    },
    value: {
      type: [String, Number]
    }
  };

  function ownKeys$i(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$i(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$i(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$i(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$o = config.prefix;
  var componentName = "".concat(prefix$o, "-tab-bar-item");
  var script$q = vue.defineComponent({
    name: componentName,
    components: {
      TNode: TNodeComponent,
      TBadge: _Badge
    },
    props: TabBarItemProps,
    setup: function setup(props) {
      var _inject = vue.inject("tab-bar"),
        defaultIndex = _inject.defaultIndex,
        activeValue = _inject.activeValue,
        updateChild = _inject.updateChild;
      var currentName = initName(defaultIndex);
      var hasSubTabBar = !!props.subTabBar;
      var isSpread = vue.ref(false);
      var isChecked = vue.computed(function () {
        if (hasSubTabBar && Array.isArray(activeValue.value)) {
          return activeValue.value.includes(currentName);
        }
        return currentName === activeValue.value;
      });
      vue.watch(isChecked, function (newValue) {
        if (!newValue) {
          isSpread.value = false;
        }
      });
      var isToggleCurrent = vue.computed(function () {
        return Array.isArray(activeValue.value) && activeValue.value[0] === currentName;
      });
      var toggle = function toggle() {
        if (hasSubTabBar) {
          isSpread.value = !isSpread.value;
          if (!isToggleCurrent.value) {
            updateChild([currentName]);
            return;
          }
        }
        updateChild(currentName);
      };
      var selectChild = function selectChild(childName) {
        if (!(Array.isArray(activeValue.value) && activeValue.value[1] === childName)) {
          updateChild([currentName, childName]);
        }
        isSpread.value = false;
      };
      var internalInstance = vue.getCurrentInstance();
      var itemContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var iconContent = vue.computed(function () {
        return renderTNode(internalInstance, "icon");
      });
      return _objectSpread$i(_objectSpread$i({}, vue.toRefs(props)), {}, {
        prefix: prefix$o,
        componentName: componentName,
        isChecked: isChecked,
        toggle: toggle,
        isSpread: isSpread,
        selectChild: selectChild,
        itemContent: itemContent,
        iconContent: iconContent
      });
    }
  });

  var _hoisted_1$9 = ["aria-selected", "aria-haspopup"];
  var _hoisted_2$3 = ["aria-label", "onClick"];
  function render$p(_ctx, _cache, $props, $setup, $data, $options) {
    var _normalizeClass2;
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_badge = vue.resolveComponent("t-badge");
    return vue.openBlock(), vue.createElementBlock("div", {
      role: "tab",
      "aria-label": "TabBar",
      "aria-selected": _ctx.isChecked,
      "aria-haspopup": _ctx.subTabBar && _ctx.subTabBar.length > 0,
      class: vue.normalizeClass([_ctx.componentName, _ctx.iconContent && "".concat(_ctx.prefix, "-no-border")])
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, "".concat(_ctx.componentName, "__content"), true), _defineProperty$2(_normalizeClass2, "".concat(_ctx.prefix, "-is-checked"), _ctx.isChecked), _defineProperty$2(_normalizeClass2, "".concat(_ctx.componentName, "--onlytext"), !_ctx.iconContent), _normalizeClass2)),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.toggle && _ctx.toggle.apply(_ctx, arguments);
      })
    }, [_ctx.iconContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.componentName, "__icon"))
    }, [_ctx.badgeProps && (_ctx.badgeProps.dot || _ctx.badgeProps.count) ? (vue.openBlock(), vue.createBlock(_component_t_badge, {
      key: 0,
      count: _ctx.badgeProps.count,
      "max-count": _ctx.badgeProps.maxCount || 99,
      dot: _ctx.badgeProps.dot,
      content: _ctx.badgeProps.content,
      size: _ctx.badgeProps.size,
      offset: _ctx.badgeProps.offset || [0, 5]
    }, {
      default: vue.withCtx(function () {
        return [vue.createVNode(_component_t_node, {
          content: _ctx.iconContent
        }, null, 8, ["content"])];
      }),
      _: 1
    }, 8, ["count", "max-count", "dot", "content", "size", "offset"])) : (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 1,
      content: _ctx.iconContent
    }, null, 8, ["content"]))], 2)) : vue.createCommentVNode("", true), _ctx.itemContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.componentName, "__text"))
    }, [_ctx.subTabBar && _ctx.subTabBar.length > 0 ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.componentName, "__icon-menu"))
    }, null, 2)) : vue.createCommentVNode("", true), vue.createVNode(_component_t_node, {
      content: _ctx.itemContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2), vue.createVNode(vue.Transition, {
      name: "spread"
    }, {
      default: vue.withCtx(function () {
        return [_ctx.subTabBar && _ctx.subTabBar.length > 0 && _ctx.isSpread ? (vue.openBlock(), vue.createElementBlock("ul", {
          key: 0,
          role: "menu",
          class: vue.normalizeClass("".concat(_ctx.componentName, "__spread"))
        }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.subTabBar, function (child, index) {
          return vue.openBlock(), vue.createElementBlock("li", {
            key: child.value || index,
            role: "menuitem",
            "aria-label": child.label,
            class: vue.normalizeClass("".concat(_ctx.componentName, "__spread-item")),
            onClick: function onClick($event) {
              return _ctx.selectChild(child.value || index);
            }
          }, vue.toDisplayString(child.label), 11, _hoisted_2$3);
        }), 128))], 2)) : vue.createCommentVNode("", true)];
      }),
      _: 1
    })], 10, _hoisted_1$9);
  }

  script$q.render = render$p;

  var TabBar = withInstall(script$r);
  var TabBarItem = withInstall(script$q);

  var DropdownMenuExpandState = /* @__PURE__ */function (DropdownMenuExpandState2) {
    DropdownMenuExpandState2["expanded"] = "expanded";
    DropdownMenuExpandState2["collapsed"] = "collapsed";
    return DropdownMenuExpandState2;
  }(DropdownMenuExpandState || {});
  var oldOverflow = null;
  var context = {
    expandedMenuControl: null,
    recordMenuExpanded: function recordMenuExpanded(container, menuControl, action) {
      var containerDom = container;
      if (action === "expanded" /* expanded */) {
        var expandedMenuControl = this.expandedMenuControl;
        if (expandedMenuControl && expandedMenuControl !== menuControl) {
          expandedMenuControl.collapseMenu();
        }
        this.expandedMenuControl = menuControl;
        if (oldOverflow === null) {
          oldOverflow = container.style.overflow;
          containerDom.style.overflow = "hidden";
        }
      } else if (action === "collapsed" /* collapsed */) {
        if (this.expandedMenuControl === menuControl) {
          this.expandedMenuControl = null;
        }
        if (!this.expandedMenuControl && oldOverflow !== null) {
          containerDom.style.overflow = oldOverflow;
          oldOverflow = null;
        }
      }
    }
  };

  var TransAniControl = /*#__PURE__*/function () {
    function TransAniControl() {
      _classCallCheck(this, TransAniControl);
      _defineProperty$2(this, "timeout", void 0);
      _defineProperty$2(this, "finallyDo", void 0);
      this.timeout = null;
      this.finallyDo = NOOP;
    }
    _createClass(TransAniControl, [{
      key: "setTo",
      value: function setTo(duration, nowDo, nextTickDo, finallyDo) {
        var _this = this;
        if (this.timeout) {
          window.clearTimeout(this.timeout);
          this.finallyDo();
        }
        nowDo();
        vue.nextTick(function () {
          return window.setTimeout(nextTickDo, 0);
        });
        this.finallyDo = finallyDo;
        this.timeout = window.setTimeout(function () {
          _this.finallyDo();
          _this.finallyDo = NOOP;
          _this.timeout = 0;
        }, duration);
      }
    }]);
    return TransAniControl;
  }();

  var findRelativeContainer = function findRelativeContainer(dom) {
    var node = dom;
    while (node && node !== document.body) {
      var _getComputedStyle = getComputedStyle(node),
        transform = _getComputedStyle.transform;
      if (!/matrix\([\d,\s]+\)/.test(transform)) {
        node = node.parentNode;
        continue;
      }
      return node;
    }
    return null;
  };
  var findRelativeRect = function findRelativeRect(dom) {
    var container = findRelativeContainer(dom);
    var containerRect = container ? container.getBoundingClientRect() : {
      top: 0,
      left: 0
    };
    var _dom$getBoundingClien = dom.getBoundingClientRect(),
      top = _dom$getBoundingClien.top,
      left = _dom$getBoundingClien.left,
      bottom = _dom$getBoundingClien.bottom,
      right = _dom$getBoundingClien.right,
      width = _dom$getBoundingClien.width,
      height = _dom$getBoundingClien.height;
    return {
      top: top - containerRect.top,
      bottom: bottom - containerRect.top,
      left: left - containerRect.left,
      right: right - containerRect.left,
      width: width,
      height: height
    };
  };

  var DropdownMenuProps = {
    activeColor: {
      type: String,
      default: ""
    },
    closeOnClickOverlay: {
      type: Boolean,
      default: true
    },
    duration: {
      type: [String, Number],
      default: 200
    },
    overlay: {
      type: Boolean,
      default: true
    },
    zIndex: {
      type: Number
    }
  };

  function ownKeys$h(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$h(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$h(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$h(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$n = config.prefix;
  var name$n = "".concat(prefix$n, "-dropdown-menu");
  var script$p = vue.defineComponent({
    name: name$n,
    components: {
      CaretDownSmallIcon: caretDownSmall
    },
    props: DropdownMenuProps,
    setup: function setup(props, _ref) {
      var slots = _ref.slots,
        expose = _ref.expose;
      var state = vue.reactive({
        activeId: null,
        barRect: {},
        childCount: 0
      });
      var menuItems = vue.ref([]);
      var updateItems = function updateItems() {
        if (slots.default) {
          var itemName = "".concat(prefix$n, "-dropdown-item");
          var children = slots.default();
          menuItems.value = children.filter(function (child) {
            var _child$type;
            var childTypeName = child === null || child === void 0 ? void 0 : (_child$type = child.type) === null || _child$type === void 0 ? void 0 : _child$type.name;
            return (childTypeName === null || childTypeName === void 0 ? void 0 : childTypeName.includes) && childTypeName.includes(itemName);
          });
        }
      };
      vue.watch(function () {
        var _slots$default;
        return slots === null || slots === void 0 ? void 0 : (_slots$default = slots.default) === null || _slots$default === void 0 ? void 0 : _slots$default.call(slots);
      }, updateItems, {
        deep: true,
        immediate: true
      });
      var menuTitles = vue.computed(function () {
        return menuItems.value.map(function (item) {
          var _item$props = item.props,
            label = _item$props.label,
            disabled = _item$props.disabled;
          return {
            label: label,
            disabled: disabled !== void 0 && disabled !== false
          };
        });
      });
      var aniControl = new TransAniControl();
      vue.provide("dropdownMenuProps", props);
      vue.provide("dropdownMenuState", state);
      vue.provide("dropdownAniControl", aniControl);
      var classes = vue.computed(function () {
        return ["".concat(name$n)];
      });
      var refBar = vue.ref(null);
      var styleBar = vue.computed(function () {
        return ["".concat(name$n, "__bar"), _defineProperty$2({}, "".concat(name$n, "__bar ").concat(name$n, "__bar--open"), state.activeId)];
      });
      var styleBarItem = vue.computed(function () {
        return function (item, idx) {
          var _ref3;
          return ["".concat(name$n, "__item"), (_ref3 = {}, _defineProperty$2(_ref3, "".concat(prefix$n, "-is-disabled"), item.disabled), _defineProperty$2(_ref3, "".concat(prefix$n, "-is-active"), idx === state.activeId), _ref3)];
        };
      });
      var expandMenu = function expandMenu(item, idx) {
        var disabled = item.disabled;
        if (disabled) return;
        if (state.activeId === idx) {
          collapseMenu();
          return;
        }
        state.activeId = idx;
        var bar = refBar.value;
        var barRect = findRelativeRect(bar);
        state.barRect = barRect;
        var container = findRelativeContainer(bar) || document.body;
        context.recordMenuExpanded(container, control, DropdownMenuExpandState.expanded);
      };
      var collapseMenu = function collapseMenu() {
        state.activeId = null;
        var bar = refBar.value;
        var container = findRelativeContainer(bar) || document.body;
        context.recordMenuExpanded(container, control, DropdownMenuExpandState.collapsed);
      };
      var control = {
        expandMenu: expandMenu,
        collapseMenu: collapseMenu
      };
      vue.provide("dropdownMenuControl", control);
      expose({
        toggle: function toggle(idx) {
          if (idx != null) {
            var item = menuTitles.value[idx];
            expandMenu(item, idx);
          } else {
            collapseMenu();
          }
        }
      });
      return _objectSpread$h(_objectSpread$h({
        name: vue.ref(name$n),
        classes: classes
      }, vue.toRefs(props)), {}, {
        refBar: refBar,
        state: state,
        styleBar: styleBar,
        styleBarItem: styleBarItem,
        menuItems: menuItems,
        menuTitles: menuTitles,
        expandMenu: expandMenu
      });
    }
  });

  var _hoisted_1$8 = ["onClick"];
  function render$o(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_caret_down_small_icon = vue.resolveComponent("caret-down-small-icon");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [vue.createElementVNode("div", {
      ref: "refBar",
      class: vue.normalizeClass(_ctx.styleBar)
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.menuTitles, function (item, idx) {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: idx,
        class: vue.normalizeClass(_ctx.styleBarItem(item, idx)),
        onClick: function onClick($event) {
          return _ctx.expandMenu(item, idx);
        }
      }, [vue.createElementVNode("div", {
        class: vue.normalizeClass("".concat(_ctx.name, "__title"))
      }, vue.toDisplayString(item.label), 3), vue.createVNode(_component_caret_down_small_icon, {
        class: vue.normalizeClass("".concat(_ctx.name, "__arrow")),
        size: "24"
      }, null, 8, ["class"])], 10, _hoisted_1$8);
    }), 128))], 2), vue.renderSlot(_ctx.$slots, "default")], 2);
  }

  script$p.render = render$o;

  var DropdownItemProps = {
    disabled: Boolean,
    label: {
      type: String,
      default: ""
    },
    multiple: Boolean,
    options: {
      type: Array
    },
    optionsColumns: {
      type: [String, Number]
    },
    optionsLayout: {
      type: String,
      default: "columns",
      validator: function validator(val) {
        return ["columns", "tree"].includes(val);
      }
    },
    value: {
      type: [String, Number, Array],
      default: void 0
    },
    modelValue: {
      type: [String, Number, Array],
      default: void 0
    },
    defaultValue: {
      type: [String, Number, Array],
      default: void 0
    },
    onChange: Function
  };

  function ownKeys$g(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$g(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$g(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$g(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$m = config.prefix;
  var name$m = "".concat(prefix$m, "-dropdown-item");
  var script$o = vue.defineComponent({
    name: name$m,
    components: {
      TRadio: _Radio,
      TButton: _Button,
      TCheckbox: CheckBox,
      TRadioGroup: _RadioGroup,
      TCheckboxGroup: CheckboxGroup
    },
    props: DropdownItemProps,
    emits: ["change", "open", "opened", "close", "closed", "update:value", "update:modelValue"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var _toRefs = vue.toRefs(props),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        passInValue = _useVModel2[0],
        setValue = _useVModel2[1];
      var menuProps = vue.inject("dropdownMenuProps");
      var menuState = vue.inject("dropdownMenuState");
      var _inject = vue.inject("dropdownMenuControl"),
        expandMenu = _inject.expandMenu,
        collapseMenu = _inject.collapseMenu;
      var menuAniControl = vue.inject("dropdownAniControl");
      var classes = vue.computed(function () {
        return ["".concat(name$m), _defineProperty$2({}, "".concat(prefix$m, "-is-expanded"), state.isExpanded)];
      });
      var itemId = vue.ref(0);
      vue.onBeforeMount(function () {
        itemId.value = menuState.childCount;
        menuState.childCount += 1;
      });
      var state = vue.reactive({
        showOverlay: vue.computed(function () {
          return menuProps.overlay;
        }),
        isShowItems: false,
        isExpanded: false,
        expandStyle: {},
        transitionStyle: vue.computed(function () {
          return {
            transition: "transform ".concat(menuProps.duration, "ms ease"),
            "-webkit-transition": "transform ".concat(menuProps.duration, "ms ease")
          };
        }),
        multiple: vue.computed(function () {
          return props.multiple;
        }),
        optionsLayout: vue.computed(function () {
          return props.optionsLayout;
        }),
        options: vue.computed(function () {
          return props.options;
        })
      });
      var isCheckedRadio = function isCheckedRadio(value2) {
        return value2 === radioSelect.value;
      };
      var styleDropRadio = function styleDropRadio(value2) {
        var _ref2;
        return ["".concat(name$m, "__radio"), (_ref2 = {}, _defineProperty$2(_ref2, "".concat(prefix$m, "-is-tick"), !props.multiple), _defineProperty$2(_ref2, "".concat(prefix$m, "-is-checked"), isCheckedRadio(value2)), _ref2)];
      };
      var styleContent = vue.computed(function () {
        var _props$optionsColumns, _ref3;
        var optionsLayout = props.optionsLayout;
        var layoutCol = +((_props$optionsColumns = props.optionsColumns) !== null && _props$optionsColumns !== void 0 ? _props$optionsColumns : 0);
        var isTree = optionsLayout === "tree";
        var treeCol = isTree ? treeState.leafLevel + 1 : 0;
        return ["".concat(name$m, "__content"), (_ref3 = {}, _defineProperty$2(_ref3, "".concat(prefix$m, "-is-tree"), isTree), _defineProperty$2(_ref3, "".concat(prefix$m, "-is-single"), !isTree && !props.multiple), _defineProperty$2(_ref3, "".concat(prefix$m, "-is-multi"), !isTree && props.multiple), _defineProperty$2(_ref3, "".concat(prefix$m, "-is-col1"), layoutCol === 1 || treeCol === 1), _defineProperty$2(_ref3, "".concat(prefix$m, "-is-col2"), layoutCol === 2 || treeCol === 2), _defineProperty$2(_ref3, "".concat(prefix$m, "-is-col3"), layoutCol === 3 || treeCol === 3), _ref3)];
      });
      var setExpand = function setExpand(val) {
        var bottom = menuState.barRect.bottom;
        state.expandStyle = {
          zIndex: menuProps.zIndex,
          top: "".concat(bottom, "px")
        };
        var duration = menuProps.duration;
        menuAniControl.setTo(+(duration !== null && duration !== void 0 ? duration : 200), function () {
          emitEvent(val ? "open" : "close");
          if (val) {
            state.isShowItems = val;
          }
          state.isExpanded = !val;
        }, function () {
          state.isExpanded = val;
        }, function () {
          if (!val) {
            state.isShowItems = val;
          }
          emitEvent(val ? "opened" : "closed");
        });
      };
      vue.watch(function () {
        return menuState.activeId === itemId.value;
      }, function (val) {
        return setExpand(val);
      });
      var radioSelect = vue.ref();
      var checkSelect = vue.ref([]);
      var treeState = vue.reactive({
        leafLevel: 0,
        selectList: []
      });
      var styleTreeRadio = vue.computed(function () {
        return function (value2, level) {
          var _ref4;
          return ["".concat(name$m, "__radio"), (_ref4 = {}, _defineProperty$2(_ref4, "".concat(prefix$m, "-is-tick"), level === treeState.leafLevel), _defineProperty$2(_ref4, "".concat(prefix$m, "-is-checked"), value2 === treeState.selectList[level]), _ref4)];
        };
      });
      var selectTreeNode = function selectTreeNode(level, value2) {
        var rebuildTree = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var tempValue = treeState.selectList.slice(0, level);
        tempValue[level] = value2;
        treeState.selectList = tempValue;
        if (rebuildTree) {
          buildTreeOptions();
        }
      };
      var treeOptions = vue.ref([]);
      var buildTreeOptions = function buildTreeOptions() {
        var options = props.options;
        var selectList = treeState.selectList;
        var newTreeOptions = [];
        var level = -1;
        var node = {
          title: "",
          value: "",
          disabled: false,
          options: options
        };
        var _loop = function _loop() {
          var list = node.options;
          newTreeOptions.push(_toConsumableArray(list));
          level += 1;
          var thisValue = selectList[level];
          if (thisValue === void 0) {
            var firstChild = list[0];
            if (firstChild.options) {
              selectTreeNode(level, firstChild.value, false);
              node = firstChild;
            } else {
              selectTreeNode(level, props.multiple ? [] : void 0, false);
              return "break";
            }
          } else if (!Array.isArray(thisValue)) {
            var child = list.find(function (child2) {
              return child2.value === thisValue;
            });
            node = child;
          } else {
            node = void 0;
          }
        };
        while ((_node = node) !== null && _node !== void 0 && _node.options) {
          var _node;
          var _ret = _loop();
          if (_ret === "break") break;
        }
        treeState.leafLevel = Math.max(0, level);
        treeOptions.value = newTreeOptions;
      };
      if (props.optionsLayout === "tree") {
        vue.watch(function () {
          return JSON.stringify({
            options: props.options
          });
        }, /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee() {
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  _context.next = 2;
                  return vue.nextTick();
                case 2:
                  buildTreeOptions();
                case 3:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        })));
        buildTreeOptions();
      }
      var updateSelectValue = function updateSelectValue(val) {
        var layout = props.optionsLayout;
        if (layout === "tree") {
          treeState.selectList = val !== null && val !== void 0 ? val : [];
          buildTreeOptions();
        } else if (layout === "columns") {
          if (!props.multiple) {
            var _ref6;
            var list = props.options;
            var firstChild = list === null || list === void 0 ? void 0 : list[0];
            var newValue = (_ref6 = val !== null && val !== void 0 ? val : firstChild === null || firstChild === void 0 ? void 0 : firstChild.value) !== null && _ref6 !== void 0 ? _ref6 : null;
            radioSelect.value = newValue;
          } else if (props.multiple) {
            if (props.optionsLayout === "columns") {
              checkSelect.value = val !== null && val !== void 0 ? val : [];
            }
          }
        }
      };
      updateSelectValue(passInValue.value || null);
      vue.watch(function () {
        return passInValue.value;
      }, function (val) {
        if (!val) return;
        updateSelectValue(val);
      });
      var isBtnDisabled = vue.computed(function () {
        switch (props.optionsLayout) {
          case "columns":
            return checkSelect.value.length <= 0;
          case "tree":
            if (!props.multiple) {
              return treeState.selectList[treeState.leafLevel] === void 0;
            }
            if (props.multiple) {
              var selectList = treeState.selectList[treeState.leafLevel];
              return selectList && selectList.length <= 0;
            }
        }
        return true;
      });
      var resetSelect = function resetSelect() {
        switch (props.optionsLayout) {
          case "columns":
            checkSelect.value = [];
            break;
          case "tree":
            treeState.selectList = [];
            break;
        }
      };
      var confirmSelect = function confirmSelect() {
        var values;
        switch (props.optionsLayout) {
          case "columns":
            values = checkSelect.value;
            break;
          case "tree":
            values = treeState.selectList;
            break;
        }
        values = JSON.parse(JSON.stringify(values));
        setValue(values);
        collapseMenu();
      };
      vue.watch(radioSelect, function (val) {
        if (props.multiple || props.optionsLayout === "tree") return;
        if (!state.isShowItems) return;
        var value2 = passInValue.value || [];
        if (value2[0] === val) return;
        if (val) {
          setValue(val);
        }
        collapseMenu();
      });
      var onClickOverlay = function onClickOverlay() {
        if (menuProps.closeOnClickOverlay) {
          collapseMenu();
        }
      };
      var TiconCheckIcon = vue.h(check);
      var convertTreeRadioType = function convertTreeRadioType(value2) {
        return value2;
      };
      var convertTreeCheckType = function convertTreeCheckType(value2) {
        return value2;
      };
      return _objectSpread$g(_objectSpread$g(_objectSpread$g({
        name: vue.ref(name$m)
      }, vue.toRefs(props)), vue.toRefs(state)), {}, {
        classes: classes,
        styleContent: styleContent,
        isBtnDisabled: isBtnDisabled,
        radioSelect: radioSelect,
        checkSelect: checkSelect,
        treeOptions: treeOptions,
        treeState: treeState,
        styleTreeRadio: styleTreeRadio,
        isCheckedRadio: isCheckedRadio,
        selectTreeNode: selectTreeNode,
        styleDropRadio: styleDropRadio,
        expandMenu: expandMenu,
        collapseMenu: collapseMenu,
        resetSelect: resetSelect,
        confirmSelect: confirmSelect,
        onClickOverlay: onClickOverlay,
        renderCheckIcon: [TiconCheckIcon],
        convertTreeRadioType: convertTreeRadioType,
        convertTreeCheckType: convertTreeCheckType
      });
    }
  });

  function ownKeys$f(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$f(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$f(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$f(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function render$n(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_radio = vue.resolveComponent("t-radio");
    var _component_t_radio_group = vue.resolveComponent("t-radio-group");
    var _component_t_checkbox = vue.resolveComponent("t-checkbox");
    var _component_t_checkbox_group = vue.resolveComponent("t-checkbox-group");
    var _component_t_button = vue.resolveComponent("t-button");
    return _ctx.isShowItems ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass(_ctx.classes),
      style: vue.normalizeStyle(_objectSpread$f({}, _ctx.expandStyle))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass(_ctx.styleContent),
      style: vue.normalizeStyle(_objectSpread$f({}, _ctx.transitionStyle))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__bd"))
    }, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
      return [_ctx.optionsLayout === "columns" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
        key: 0
      }, [!_ctx.multiple ? (vue.openBlock(), vue.createBlock(_component_t_radio_group, {
        key: 0,
        modelValue: _ctx.radioSelect,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = function ($event) {
          return _ctx.radioSelect = $event;
        })
      }, {
        default: vue.withCtx(function () {
          return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.options, function (option) {
            return vue.openBlock(), vue.createBlock(_component_t_radio, {
              key: option.value,
              value: option.value,
              label: option.title,
              disabled: option.disabled,
              class: vue.normalizeClass(_ctx.styleDropRadio(option.value)),
              align: "right",
              checked: _ctx.isCheckedRadio(option.value),
              icon: _ctx.renderCheckIcon
            }, null, 8, ["value", "label", "disabled", "class", "checked", "icon"]);
          }), 128))];
        }),
        _: 1
      }, 8, ["modelValue"])) : (vue.openBlock(), vue.createBlock(_component_t_checkbox_group, {
        key: 1,
        modelValue: _ctx.checkSelect,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = function ($event) {
          return _ctx.checkSelect = $event;
        })
      }, {
        default: vue.withCtx(function () {
          return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.options, function (option) {
            return vue.openBlock(), vue.createBlock(_component_t_checkbox, {
              key: option.value,
              borderless: "",
              value: option.value,
              label: option.title,
              disabled: option.disabled
            }, null, 8, ["value", "label", "disabled"]);
          }), 128))];
        }),
        _: 1
      }, 8, ["modelValue"]))], 64)) : _ctx.optionsLayout === "tree" ? (vue.openBlock(true), vue.createElementBlock(vue.Fragment, {
        key: 1
      }, vue.renderList(_ctx.treeOptions, function (_, level) {
        return vue.openBlock(), vue.createElementBlock("div", {
          key: level,
          class: vue.normalizeClass("".concat(_ctx.name, "__tree-group"))
        }, [level < _ctx.treeState.leafLevel ? (vue.openBlock(), vue.createBlock(_component_t_radio_group, {
          key: 0,
          "model-value": _ctx.convertTreeRadioType(_ctx.treeState.selectList[level]),
          "onUpdate:modelValue": function onUpdateModelValue($event) {
            return _ctx.selectTreeNode(level, $event);
          }
        }, {
          default: vue.withCtx(function () {
            return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.treeOptions[level], function (option) {
              return vue.openBlock(), vue.createBlock(_component_t_radio, {
                key: option.value,
                class: vue.normalizeClass(_ctx.styleTreeRadio(option.value, level)),
                value: option.value,
                label: option.title,
                disabled: option.disabled,
                align: "right",
                icon: [],
                borderless: ""
              }, null, 8, ["class", "value", "label", "disabled"]);
            }), 128))];
          }),
          _: 2
        }, 1032, ["model-value", "onUpdate:modelValue"])) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
          key: 1
        }, [!_ctx.multiple ? (vue.openBlock(), vue.createBlock(_component_t_radio_group, {
          key: 0,
          value: _ctx.convertTreeRadioType(_ctx.treeState.selectList[level]),
          "onUpdate:value": function onUpdateValue($event) {
            return _ctx.selectTreeNode(level, $event);
          }
        }, {
          default: vue.withCtx(function () {
            return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.treeOptions[level], function (option) {
              return vue.openBlock(), vue.createBlock(_component_t_radio, {
                key: option.value,
                value: option.value,
                label: option.title,
                disabled: option.disabled,
                class: vue.normalizeClass(_ctx.styleTreeRadio(option.value, level)),
                align: "right",
                borderless: ""
              }, null, 8, ["value", "label", "disabled", "class"]);
            }), 128))];
          }),
          _: 2
        }, 1032, ["value", "onUpdate:value"])) : (vue.openBlock(), vue.createBlock(_component_t_checkbox_group, {
          key: 1,
          value: _ctx.convertTreeCheckType(_ctx.treeState.selectList[level]),
          "onUpdate:value": function onUpdateValue($event) {
            return _ctx.selectTreeNode(level, $event);
          }
        }, {
          default: vue.withCtx(function () {
            return [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.treeOptions[level], function (option) {
              return vue.openBlock(), vue.createBlock(_component_t_checkbox, {
                key: option.value,
                value: option.value,
                label: option.title,
                disabled: option.disabled,
                align: "right",
                borderless: ""
              }, null, 8, ["value", "label", "disabled"]);
            }), 128))];
          }),
          _: 2
        }, 1032, ["value", "onUpdate:value"]))], 64))], 2);
      }), 128)) : vue.createCommentVNode("", true)];
    })], 2), _ctx.multiple || _ctx.optionsLayout === "tree" ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__ft"))
    }, [vue.createVNode(_component_t_button, {
      variant: "outline",
      disabled: _ctx.isBtnDisabled,
      onClick: _ctx.resetSelect
    }, {
      default: vue.withCtx(function () {
        return [vue.createTextVNode("\u91CD\u7F6E")];
      }),
      _: 1
    }, 8, ["disabled", "onClick"]), vue.createVNode(_component_t_button, {
      theme: "primary",
      disabled: _ctx.isBtnDisabled,
      onClick: _ctx.confirmSelect
    }, {
      default: vue.withCtx(function () {
        return [vue.createTextVNode("\u786E\u5B9A")];
      }),
      _: 1
    }, 8, ["disabled", "onClick"])], 2)) : vue.createCommentVNode("", true)], 6)], 6)) : vue.createCommentVNode("", true);
  }

  script$o.render = render$n;

  var DropdownMenu = withInstall(script$p);
  var DropdownItem = withInstall(script$o);

  var props$3 = {
    defaultExpandAll: Boolean,
    disabled: Boolean,
    expandIcon: {
      type: [Boolean, Function],
      default: true
    },
    expandMutex: Boolean,
    value: {
      type: Array
    },
    modelValue: {
      type: Array
    },
    defaultValue: {
      type: Array,
      default: []
    },
    onChange: Function
  };

  var prefix$l = config.prefix;
  var name$l = "".concat(prefix$l, "-collapse");
  var script$n = vue.defineComponent({
    name: name$l,
    props: props$3,
    emits: ["update:value", "change"],
    setup: function setup(props2, context) {
      var _toRefs = vue.toRefs(props2),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props2.defaultValue, props2.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        activeValue = _useVModel2[0],
        setActiveValue = _useVModel2[1];
      var calcActiveValues = function calcActiveValues(activeValues, panelValue, expandMutex) {
        var hit = activeValues.indexOf(panelValue);
        if (hit > -1) {
          return activeValues.filter(function (item) {
            return item !== panelValue;
          });
        }
        return expandMutex ? [panelValue] : activeValues.concat(panelValue);
      };
      var onPanelChange = function onPanelChange(value2) {
        if (Array.isArray(activeValue.value)) {
          var val = calcActiveValues(activeValue.value, value2, props2.expandMutex);
          setActiveValue(val);
        }
      };
      var disabled = vue.computed(function () {
        return props2.disabled;
      });
      var expandIcon = vue.computed(function () {
        return props2.expandIcon;
      });
      vue.provide("collapse", {
        activeValue: activeValue,
        disabled: disabled,
        expandIcon: expandIcon,
        onPanelChange: onPanelChange,
        defaultExpandAll: props2.defaultExpandAll
      });
      return {
        prefix: prefix$l,
        classPrefix: name$l,
        activeValue: activeValue
      };
    }
  });

  function render$m(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classPrefix)
    }, [vue.renderSlot(_ctx.$slots, "default")], 2);
  }

  script$n.render = render$m;

  var props$2 = {
    content: {
      type: [String, Function]
    },
    default: {
      type: [String, Function]
    },
    destroyOnCollapse: Boolean,
    disabled: {
      type: Boolean,
      default: void 0
    },
    expandIcon: {
      type: [Boolean, Function],
      default: void 0
    },
    header: {
      type: [String, Function]
    },
    headerRightContent: {
      type: [String, Function]
    },
    value: {
      type: [String, Number],
      required: true
    }
  };

  function findIndex$1(v, set) {
    var reg = new RegExp("^".concat(!v && v !== 0 ? "" : v, "$"));
    var arr = toArray(set);
    return arr.findIndex(function (s) {
      return reg.test(s);
    });
  }
  function isFalsy(v) {
    return !v && v !== 0;
  }
  function toArray(v) {
    if (isFalsy(v)) return [];
    if (_typeof$1(v) === "object") return Array.from(v);
    return [v];
  }

  var prefix$k = config.prefix;
  var name$k = "".concat(prefix$k, "-collapse-panel");
  var script$m = vue.defineComponent({
    name: name$k,
    components: {
      ChevronDownIcon: chevronDown,
      ChevronUpIcon: chevronUp,
      TNode: TNodeComponent
    },
    props: props$2,
    setup: function setup(props2, context) {
      var internalInstance = vue.getCurrentInstance();
      var parent = vue.inject("collapse");
      var isTrue = function isTrue(val) {
        return typeof val === "boolean" && val;
      };
      var rightIcon = vue.computed(function () {
        if (props2.expandIcon === false) return;
        if (isTrue(props2.expandIcon) || isTrue(parent === null || parent === void 0 ? void 0 : parent.expandIcon.value)) {
          console.log(isTrue(parent === null || parent === void 0 ? void 0 : parent.expandIcon.value));
          return isActive.value ? chevronDown : chevronUp;
        }
        return renderTNode(internalInstance, "expand-icon")[0];
      });
      var disabled = vue.computed(function () {
        return (parent === null || parent === void 0 ? void 0 : parent.disabled.value) || props2.disabled;
      });
      var className = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$k), true), _defineProperty$2(_ref, "".concat(name$k, "--active"), isActive.value), _defineProperty$2(_ref, "".concat(name$k, "--disabled"), disabled.value), _ref;
      });
      var isActive = vue.computed(function () {
        return findIndex$1(props2.value, parent === null || parent === void 0 ? void 0 : parent.activeValue.value) > -1;
      });
      var updatePanelValue = function updatePanelValue() {
        if (props2.value != null) {
          parent === null || parent === void 0 ? void 0 : parent.onPanelChange(props2.value);
        }
      };
      var handleClick = function handleClick(e) {
        e === null || e === void 0 ? void 0 : e.stopPropagation();
        if (disabled.value) {
          return;
        }
        updatePanelValue();
      };
      var panelContent = renderContent(internalInstance, "default", "content");
      var $body = vue.ref();
      var $wrap = vue.ref();
      var $head = vue.ref();
      var updatePanelState = function updatePanelState() {
        if (!$wrap.value) {
          return;
        }
        var _$head$value$getBound = $head.value.getBoundingClientRect(),
          headHeight = _$head$value$getBound.height;
        if (!isActive.value) {
          $wrap.value.style.height = "".concat(headHeight, "px");
          return;
        }
        var _$body$value$getBound = $body.value.getBoundingClientRect(),
          bodyHeight = _$body$value$getBound.height;
        var height = headHeight + bodyHeight;
        $wrap.value.style.height = "".concat(height, "px");
      };
      vue.watch(isActive, function () {
        vue.nextTick(function () {
          updatePanelState();
        });
      });
      vue.onMounted(function () {
        if (parent !== null && parent !== void 0 && parent.defaultExpandAll) {
          updatePanelValue();
        }
        updatePanelState();
      });
      return {
        classPrefix: name$k,
        rightIcon: rightIcon,
        $head: $head,
        $body: $body,
        $wrap: $wrap,
        className: className,
        handleClick: handleClick,
        panelContent: panelContent
      };
    }
  });

  function render$l(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "$wrap",
      class: vue.normalizeClass(_ctx.className)
    }, [vue.createElementVNode("div", {
      ref: "$head",
      class: vue.normalizeClass("".concat(_ctx.classPrefix, "__header")),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.handleClick && _ctx.handleClick.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.classPrefix, "__title"))
    }, [vue.renderSlot(_ctx.$slots, "header", {}, function () {
      return [vue.createTextVNode(vue.toDisplayString(_ctx.header), 1)];
    })], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.classPrefix, "__header-right"))
    }, [_ctx.headerRightContent || _ctx.$slots.headerRightContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.classPrefix, "__header-extra"))
    }, [vue.renderSlot(_ctx.$slots, "headerRightContent", {}, function () {
      return [vue.createTextVNode(vue.toDisplayString(_ctx.headerRightContent), 1)];
    })], 2)) : vue.createCommentVNode("", true), (vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.rightIcon), {
      class: vue.normalizeClass("".concat(_ctx.classPrefix, "__header-icon"))
    }, null, 8, ["class"]))], 2)], 2), vue.createElementVNode("div", {
      ref: "$body",
      class: vue.normalizeClass("".concat(_ctx.classPrefix, "__body"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.panelContent
    }, null, 8, ["content"])], 2)], 2);
  }

  script$m.render = render$l;

  var Collapse = withInstall(script$n);
  var CollapsePanel = withInstall(script$m);

  var TabsProps = {
    animation: {
      type: Object
    },
    list: {
      type: Array
    },
    placement: {
      type: String,
      default: "top",
      validator: function validator(val) {
        if (!val) return true;
        return ["left", "top"].includes(val);
      }
    },
    showBottomLine: {
      type: Boolean,
      default: true
    },
    size: {
      type: String,
      default: "medium",
      validator: function validator(val) {
        if (!val) return true;
        return ["medium", "large"].includes(val);
      }
    },
    stickyProps: {
      type: Object
    },
    value: {
      type: [String, Number],
      default: void 0
    },
    modelValue: {
      type: [String, Number],
      default: void 0
    },
    defaultValue: {
      type: [String, Number]
    },
    onChange: Function
  };

  var TabPanelProps = {
    destroyOnHide: {
      type: Boolean,
      default: true
    },
    disabled: Boolean,
    label: {
      type: [String, Function]
    },
    panel: {
      type: [String, Function]
    },
    value: {
      type: [String, Number]
    }
  };

  var prefix$j = config.prefix;
  var script$l = vue.defineComponent({
    name: "".concat(prefix$j, "-tab-nav"),
    components: {
      TNode: TNodeComponent
    },
    props: {
      label: TabPanelProps.label
    },
    setup: function setup(props) {
      var internalInstance = vue.getCurrentInstance();
      var labelContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "label");
      });
      return {
        labelContent: labelContent
      };
    }
  });

  function render$k(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", null, [vue.createVNode(_component_t_node, {
      content: _ctx.labelContent
    }, null, 8, ["content"])]);
  }

  script$l.render = render$k;

  var props$1 = {
    container: {
      type: Object
    },
    disabled: Boolean,
    offsetTop: {
      type: [String, Number],
      default: 0
    },
    zIndex: {
      type: Number,
      default: 99
    },
    onScroll: Function
  };

  var name$j = "".concat(config.prefix, "-sticky");
  var script$k = vue.defineComponent({
    name: name$j,
    components: {
      TNode: TNodeComponent
    },
    props: props$1,
    setup: function setup(props2, context) {
      var boxClasses = name$j;
      var stickyContent = vue.computed(function () {
        return renderContent(vue.getCurrentInstance(), "default", "");
      });
      var emitEvent = useEmitEvent(props2, context.emit);
      var boxRef = templateRef("boxRef");
      var _useElementBounding = useElementBounding(boxRef),
        boxTop = _useElementBounding.top;
      var contentRef = templateRef("contentRef");
      var _useElementBounding2 = useElementBounding(contentRef),
        contentTop = _useElementBounding2.top,
        height = _useElementBounding2.height;
      var boxStyles = vue.computed(function () {
        return "height:".concat(height.value, "px;");
      });
      var container;
      var containerHeight = vue.ref(0);
      var containerTop = vue.ref(0);
      vue.watch(boxTop, function () {
        if (props2.container) {
          container = document.querySelector(props2.container);
          var _container$getBoundin = container.getBoundingClientRect(),
            top = _container$getBoundin.top,
            height2 = _container$getBoundin.height;
          containerHeight.value = height2;
          containerTop.value = top;
        }
      });
      var contentStyles = vue.computed(function () {
        var styleStr = "z-index:".concat(props2.zIndex, ";");
        var isFixed = false;
        if (props2.disabled) return styleStr;
        var offsetTop = Number(props2.offsetTop);
        if (container) {
          if (containerHeight.value + containerTop.value < offsetTop + height.value) {
            styleStr += "transform:translate3d(0, ".concat(containerHeight.value - height.value, "px, 0);");
          } else if (boxTop.value <= offsetTop) {
            styleStr += "position:fixed;top:".concat(offsetTop, "px;");
            isFixed = true;
          }
        } else if (boxTop.value <= offsetTop) {
          styleStr += "position:fixed;top:".concat(offsetTop, "px;");
          isFixed = true;
        }
        emitEvent("scroll", {
          scrollTop: contentTop.value,
          isFixed: isFixed
        });
        return styleStr;
      });
      return {
        boxClasses: boxClasses,
        boxStyles: boxStyles,
        contentStyles: contentStyles,
        stickyContent: stickyContent
      };
    }
  });

  function render$j(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "boxRef",
      class: vue.normalizeClass(_ctx.boxClasses),
      style: vue.normalizeStyle(_ctx.boxStyles)
    }, [vue.createElementVNode("div", {
      ref: "contentRef",
      class: vue.normalizeClass("".concat(_ctx.boxClasses, "__content")),
      style: vue.normalizeStyle(_ctx.contentStyles)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.stickyContent
    }, null, 8, ["content"])], 6)], 6);
  }

  script$k.render = render$j;

  var _Sticky = withInstall(script$k);

  function ownKeys$e(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$e(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$e(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$e(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$i = config.prefix;
  var name$i = "".concat(prefix$i, "-tabs");
  var script$j = vue.defineComponent({
    name: name$i,
    components: {
      TabNavItem: script$l,
      TSticky: _Sticky
    },
    props: TabsProps,
    emits: ["update:value", "update:modelValue"],
    setup: function setup(props, context) {
      var placement = vue.computed(function () {
        return props.placement;
      });
      var showBottomLine = vue.computed(function () {
        return props.showBottomLine;
      });
      var stickyProps = vue.computed(function () {
        return _objectSpread$e({
          disabled: true
        }, props.stickyProps);
      });
      var activeClass = ClASSNAMES.STATUS.active;
      var disabledClass = ClASSNAMES.STATUS.disabled;
      var classes = vue.computed(function () {
        return ["".concat(name$i), "".concat(prefix$i, "-is-").concat(placement.value), props.size ? ClASSNAMES.SIZE[props.size] : ""];
      });
      var navClasses = vue.ref(["".concat(name$i, "__nav")]);
      var isScroll = vue.ref(false);
      var _toRefs = vue.toRefs(props),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        currentValue = _useVModel2[0],
        setCurrentValue = _useVModel2[1];
      var itemProps = vue.computed(function () {
        if (props.list) {
          return props.list;
        }
        var children = context.slots.default ? context.slots.default() : [];
        var res = [];
        var _label = [];
        children.forEach(function (child) {
          var _child$children;
          if (child.type === vue.Fragment) {
            res.push.apply(res, _toConsumableArray(child.children));
          } else {
            res.push(child);
          }
          if ((_child$children = child.children) !== null && _child$children !== void 0 && _child$children.label) {
            _label.push(child.children.label()[0] || null);
          }
        });
        children = res.filter(function (child) {
          return child.type.name === "".concat(prefix$i, "-tab-panel");
        });
        return children.map(function (item, index) {
          return _objectSpread$e(_objectSpread$e({}, item.props), {}, {
            label: function label() {
              return _label[index] || item.props.label;
            }
          });
        });
      });
      var navScroll = vue.ref(null);
      var navWrap = vue.ref(null);
      var navLine = vue.ref(null);
      var lineStyle = vue.ref("");
      var moveToActiveTab = function moveToActiveTab() {
        if (navWrap.value && navLine.value && showBottomLine.value) {
          var tab = navWrap.value.querySelector(".".concat(activeClass));
          if (!tab) return;
          var line = navLine.value;
          if (placement.value === "left") {
            lineStyle.value = "transform: translateY(".concat(tab.offsetTop, "px);").concat(props.animation ? "transition-duration:".concat(props.animation.duration, "ms") : "");
          } else {
            lineStyle.value = "transform: translateX(".concat(Number(tab.offsetLeft) + Number(tab.offsetWidth) / 2 - line.offsetWidth / 2, "px);").concat(props.animation ? "transition-duration:".concat(props.animation.duration, "ms") : "");
          }
        }
      };
      vue.onMounted(function () {
        var _navWrap$value, _navScroll$value;
        isScroll.value = (((_navWrap$value = navWrap.value) === null || _navWrap$value === void 0 ? void 0 : _navWrap$value.offsetWidth) || 0) > (((_navScroll$value = navScroll.value) === null || _navScroll$value === void 0 ? void 0 : _navScroll$value.offsetWidth) || 0);
        isScroll.value && navClasses.value.push("".concat(prefix$i, "-is-scrollable"));
        window.addEventListener("resize", moveToActiveTab, false);
        setTimeout(function () {
          moveToActiveTab();
        }, 300);
      });
      vue.onBeforeUnmount(function () {
        window.removeEventListener("resize", moveToActiveTab);
      });
      var tabClick = function tabClick(event, item) {
        var value2 = item.value,
          disabled = item.disabled;
        if (disabled || currentValue.value === value2) {
          return false;
        }
        setCurrentValue(value2);
        vue.nextTick(function () {
          moveToActiveTab();
        });
      };
      vue.provide("currentValue", vue.readonly(currentValue));
      return {
        name: name$i,
        prefix: prefix$i,
        classes: classes,
        navClasses: navClasses,
        activeClass: activeClass,
        disabledClass: disabledClass,
        currentValue: currentValue,
        tabClick: tabClick,
        showBottomLine: showBottomLine,
        itemProps: itemProps,
        navScroll: navScroll,
        navWrap: navWrap,
        navLine: navLine,
        lineStyle: lineStyle,
        moveToActiveTab: moveToActiveTab,
        stickyProps: stickyProps
      };
    }
  });

  function render$i(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_tab_nav_item = vue.resolveComponent("tab-nav-item");
    var _component_t_sticky = vue.resolveComponent("t-sticky");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [vue.createVNode(_component_t_sticky, vue.normalizeProps(vue.guardReactiveProps(_ctx.stickyProps)), {
      default: vue.withCtx(function () {
        return [vue.createElementVNode("div", {
          class: vue.normalizeClass(_ctx.navClasses)
        }, [vue.createElementVNode("div", {
          ref: "navScroll",
          class: vue.normalizeClass("".concat(_ctx.name, "__nav-container"))
        }, [vue.createElementVNode("div", {
          ref: "navWrap",
          class: vue.normalizeClass("".concat(_ctx.name, "__nav-wrap"))
        }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.itemProps, function (item) {
          var _normalizeClass2;
          return vue.openBlock(), vue.createBlock(_component_tab_nav_item, {
            key: item.value,
            label: item.label,
            class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, "".concat(_ctx.name, "__nav-item"), true), _defineProperty$2(_normalizeClass2, _ctx.activeClass, item.value === _ctx.currentValue), _defineProperty$2(_normalizeClass2, _ctx.disabledClass, item.disabled), _normalizeClass2)),
            onClick: function onClick(e) {
              return _ctx.tabClick(e, item);
            }
          }, null, 8, ["label", "class", "onClick"]);
        }), 128)), _ctx.showBottomLine ? (vue.openBlock(), vue.createElementBlock("div", {
          key: 0,
          ref: "navLine",
          class: vue.normalizeClass("".concat(_ctx.name, "__nav-line")),
          style: vue.normalizeStyle(_ctx.lineStyle)
        }, null, 6)) : vue.createCommentVNode("", true)], 2)], 2)], 2)];
      }),
      _: 1
    }, 16), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__content"))
    }, [vue.renderSlot(_ctx.$slots, "default")], 2)], 2);
  }

  script$j.render = render$i;

  function ownKeys$d(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$d(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$d(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$h = config.prefix;
  var name$h = "".concat(prefix$h, "-tab-panel");
  var script$i = vue.defineComponent({
    name: name$h,
    components: {
      TNode: TNodeComponent
    },
    props: TabPanelProps,
    setup: function setup(props) {
      var currentValue = vue.inject("currentValue", "");
      var isActive = vue.computed(function () {
        return currentValue.value === props.value;
      });
      var internalInstance = vue.getCurrentInstance();
      var panelContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "panel");
      });
      var tabPanelClass = vue.computed(function () {
        return ["".concat(name$h), "".concat(prefix$h, "-tabs__panel")];
      });
      return _objectSpread$d({
        prefix: prefix$h,
        name: name$h,
        isActive: isActive,
        panelContent: panelContent,
        tabPanelClass: tabPanelClass
      }, vue.toRefs(props));
    }
  });

  var _hoisted_1$7 = ["value"];
  function render$h(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return _ctx.destroyOnHide || _ctx.isActive ? vue.withDirectives((vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass(_ctx.tabPanelClass),
      value: _ctx.value
    }, [vue.renderSlot(_ctx.$slots, "default", {}, function () {
      return [vue.createVNode(_component_t_node, {
        content: _ctx.panelContent
      }, null, 8, ["content"])];
    })], 10, _hoisted_1$7)), [[vue.vShow, _ctx.isActive]]) : vue.createCommentVNode("", true);
  }

  script$i.render = render$h;

  var Tabs = withInstall(script$j);
  var TabPanel = withInstall(script$i);

  var CountDownProps = {
    autoStart: {
      type: Boolean,
      default: true
    },
    content: {
      type: [String, Function],
      default: "default"
    },
    format: {
      type: String,
      default: "HH:mm:ss"
    },
    millisecond: Boolean,
    time: {
      type: Number,
      required: true
    },
    size: {
      type: String,
      default: "small"
    },
    theme: {
      type: String,
      default: "default"
    },
    onChange: Function,
    onFinish: Function
  };

  function ownKeys$c(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$c(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$c(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$g = config.prefix;
  var name$g = "".concat(prefix$g, "-countdown");
  var script$h = vue.defineComponent({
    name: name$g,
    components: {
      TNode: TNodeComponent
    },
    props: _objectSpread$c({}, CountDownProps),
    setup: function setup(props) {
      var _ref, _ref$test;
      var _useCountDown = useCountDown(props),
        time = _useCountDown.time,
        showTimes = _useCountDown.showTimes;
      var internalInstance = vue.getCurrentInstance();
      var hasChinese = (_ref = /.*[\u4e00-\u9fa5]+.*$/) === null || _ref === void 0 ? void 0 : (_ref$test = _ref.test) === null || _ref$test === void 0 ? void 0 : _ref$test.call(_ref, props === null || props === void 0 ? void 0 : props.format);
      var contentLayout = vue.computed(function () {
        return renderTNode(internalInstance, "content");
      });
      return {
        name: name$g,
        time: time,
        showTimes: showTimes,
        hasChinese: hasChinese,
        contentLayout: contentLayout
      };
    }
  });

  function render$g(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [!_ctx.time ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.contentLayout
    }, null, 8, ["content"])) : vue.createCommentVNode("", true), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, " ").concat(_ctx.name, "--").concat(_ctx.theme, " ").concat(_ctx.name, "--").concat(_ctx.size, " ").concat(!_ctx.hasChinese ? "" : "".concat(_ctx.name, "--split-with-unit")))
    }, [_ctx.time ? (vue.openBlock(true), vue.createElementBlock(vue.Fragment, {
      key: 0
    }, vue.renderList(_ctx.showTimes, function (item) {
      return vue.openBlock(), vue.createElementBlock(vue.Fragment, {
        key: item.mark
      }, [vue.createElementVNode("span", {
        class: vue.normalizeClass("".concat(_ctx.name, "__digit"))
      }, vue.toDisplayString(item.value), 3), item.mark ? (vue.openBlock(), vue.createElementBlock("span", {
        key: 0,
        class: vue.normalizeClass("".concat(_ctx.name, "__unit"))
      }, vue.toDisplayString(item.mark), 3)) : vue.createCommentVNode("", true)], 64);
    }), 128)) : vue.createCommentVNode("", true)], 2)], 64);
  }

  script$h.render = render$g;

  var Countdown = withInstall(script$h);

  var ImageProps = {
    alt: {
      type: String,
      default: ""
    },
    error: {
      type: Function
    },
    fit: {
      type: String,
      default: "fill",
      validator: function validator(val) {
        if (!val) return true;
        return ["contain", "cover", "fill", "none", "scale-down"].includes(val);
      }
    },
    lazy: Boolean,
    loading: {
      type: Function
    },
    position: {
      type: String,
      default: "center"
    },
    shape: {
      type: String,
      default: "round",
      validator: function validator(val) {
        if (!val) return true;
        return ["circle", "round", "square"].includes(val);
      }
    },
    src: {
      type: String,
      default: ""
    },
    onError: Function,
    onLoad: Function
  };

  var prefix$f = config.prefix;
  var name$f = "".concat(prefix$f, "-image");
  var script$g = vue.defineComponent({
    name: name$f,
    components: {
      TNode: TNodeComponent
    },
    props: ImageProps,
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var closeIcon = vue.h(close);
      var ellipsisIcon = vue.h(ellipsis);
      var statusContent = vue.computed(function () {
        var _context$slots, _context$slots2, _context$slots3, _context$slots4;
        if ((_context$slots = context.slots) !== null && _context$slots !== void 0 && _context$slots.loading && loadingValue.value) {
          return renderTNode(internalInstance, "loading");
        }
        if (!((_context$slots2 = context.slots) !== null && _context$slots2 !== void 0 && _context$slots2.loading) && loadingValue.value) {
          return ellipsisIcon;
        }
        if ((_context$slots3 = context.slots) !== null && _context$slots3 !== void 0 && _context$slots3.error && errorValue.value) {
          return renderTNode(internalInstance, "error");
        }
        if (!((_context$slots4 = context.slots) !== null && _context$slots4 !== void 0 && _context$slots4.error) && errorValue.value) {
          return closeIcon;
        }
        return "";
      });
      var loadingValue = vue.ref(true);
      var errorValue = vue.ref(false);
      var imageStyles = vue.computed(function () {
        return {
          objectFit: props.fit,
          objectPosition: props.position
        };
      });
      var classes = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$f), true), _defineProperty$2(_ref, "".concat(name$f, "--").concat(props.shape), true), _ref;
      });
      var imageDOM = vue.ref();
      var realSrc = vue.ref("");
      vue.watchEffect(function () {
        realSrc.value = props.lazy ? "" : props.src;
      });
      var _useIntersectionObser = useIntersectionObserver(imageDOM, function (_ref2, observerElement) {
          var _ref3 = _slicedToArray(_ref2, 1),
            isIntersecting = _ref3[0].isIntersecting;
          if (isIntersecting && props.lazy) {
            stop();
            realSrc.value = props.src;
          }
        }),
        stop = _useIntersectionObser.stop;
      var handleImgLoadCompleted = function handleImgLoadCompleted(e) {
        emitEvent("load", e);
        loadingValue.value = false;
      };
      var handleImgLoadError = function handleImgLoadError(e) {
        if (realSrc.value === "") {
          return;
        }
        emitEvent("error", e);
        loadingValue.value = false;
        errorValue.value = true;
      };
      return {
        imageDOM: imageDOM,
        statusContent: statusContent,
        name: name$f,
        classes: classes,
        imageStyles: imageStyles,
        loadingValue: loadingValue,
        realSrc: realSrc,
        errorValue: errorValue,
        handleImgLoadCompleted: handleImgLoadCompleted,
        handleImgLoadError: handleImgLoadError
      };
    }
  });

  var _hoisted_1$6 = ["src", "alt"];
  function render$f(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [_ctx.loadingValue || _ctx.errorValue ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__status"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.statusContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), vue.createElementVNode("img", {
      ref: "imageDOM",
      class: vue.normalizeClass("".concat(_ctx.name, "__img")),
      style: vue.normalizeStyle(_ctx.imageStyles),
      src: _ctx.realSrc,
      alt: _ctx.alt,
      onLoad: _cache[0] || (_cache[0] = function () {
        return _ctx.handleImgLoadCompleted && _ctx.handleImgLoadCompleted.apply(_ctx, arguments);
      }),
      onError: _cache[1] || (_cache[1] = function () {
        return _ctx.handleImgLoadError && _ctx.handleImgLoadError.apply(_ctx, arguments);
      })
    }, null, 46, _hoisted_1$6)], 2);
  }

  script$g.render = render$f;

  var _Image = withInstall(script$g);

  var AvatarProps = {
    imageProps: {
      type: Object
    },
    alt: {
      type: String,
      default: ""
    },
    badgeProps: {
      type: Object
    },
    hideOnLoadFailed: Boolean,
    icon: {
      type: Function
    },
    image: {
      type: String,
      default: ""
    },
    shape: {
      type: String,
      default: "circle",
      validator: function validator(val) {
        if (!val) return true;
        return ["circle", "round"].includes(val);
      }
    },
    size: {
      type: String,
      default: ""
    },
    onError: Function
  };

  function ownKeys$b(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$b(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$b(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$e = config.prefix;
  var name$e = "".concat(prefix$e, "-avatar");
  var script$f = vue.defineComponent({
    name: name$e,
    components: {
      TNode: TNodeComponent,
      TBadge: _Badge,
      TImage: _Image
    },
    props: AvatarProps,
    emits: ["error"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var avatarGroupProps = vue.inject("avatarGroup", {});
      var iconContent = vue.computed(function () {
        return renderTNode(internalInstance, "icon");
      });
      var avatarContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var sizeValue = vue.ref(props.size || avatarGroupProps && avatarGroupProps.size);
      var avatarClass = vue.computed(function () {
        return ["".concat(name$e), sizeValue.value ? ClASSNAMES.SIZE[sizeValue.value] : "", _defineProperty$2({}, "".concat(name$e, "--").concat(props.shape), props.shape)];
      });
      var isCustomSize = vue.computed(function () {
        return sizeValue.value && !ClASSNAMES.SIZE[sizeValue.value];
      });
      var customSize = vue.computed(function () {
        return isCustomSize.value ? {
          height: sizeValue.value,
          width: sizeValue.value
        } : {};
      });
      var handleImgLoadCompleted = function handleImgLoadCompleted(e) {
        emitEvent("load", e);
      };
      var handleImgLoadError = function handleImgLoadError(e) {
        emitEvent("error", e);
      };
      var baseImageProps = {
        src: props.image,
        alt: props.alt
      };
      var customImageProps = vue.computed(function () {
        return _objectSpread$b(_objectSpread$b({}, props.imageProps), baseImageProps);
      });
      return _objectSpread$b(_objectSpread$b({
        name: name$e
      }, vue.toRefs(props)), {}, {
        iconContent: iconContent,
        avatarContent: avatarContent,
        avatarClass: avatarClass,
        customSize: customSize,
        handleImgLoadCompleted: handleImgLoadCompleted,
        handleImgLoadError: handleImgLoadError,
        customImageProps: customImageProps
      });
    }
  });

  var _hoisted_1$5 = {
    key: 2
  };
  function render$e(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_image = vue.resolveComponent("t-image");
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_badge = vue.resolveComponent("t-badge");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.avatarClass),
      style: vue.normalizeStyle(_ctx.customSize)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__inner"))
    }, [_ctx.image && !_ctx.hideOnLoadFailed ? (vue.openBlock(), vue.createBlock(_component_t_image, vue.mergeProps({
      key: 0,
      style: _ctx.customSize
    }, _ctx.customImageProps, {
      onLoad: _ctx.handleImgLoadCompleted,
      onError: _ctx.handleImgLoadError
    }), null, 16, ["style", "onLoad", "onError"])) : _ctx.iconContent !== void 0 ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__icon"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.iconContent
    }, null, 8, ["content"])], 2)) : (vue.openBlock(), vue.createElementBlock("span", _hoisted_1$5, [vue.createVNode(_component_t_node, {
      content: _ctx.avatarContent
    }, null, 8, ["content"])]))], 2), _ctx.badgeProps ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__badge"))
    }, [vue.createVNode(_component_t_badge, {
      count: _ctx.badgeProps.count,
      "max-count": _ctx.badgeProps.maxCount,
      dot: _ctx.badgeProps.dot,
      content: _ctx.badgeProps.content,
      size: _ctx.badgeProps.size,
      offset: _ctx.badgeProps.offset
    }, null, 8, ["count", "max-count", "dot", "content", "size", "offset"])], 2)) : vue.createCommentVNode("", true)], 6);
  }

  script$f.render = render$e;

  var AvatarGroupProps = {
    cascading: {
      type: String,
      default: "right-up",
      validator: function validator(val) {
        if (!val) return true;
        return ["left-up", "right-up"].includes(val);
      }
    },
    collapseAvatar: {
      type: [String, Function]
    },
    max: {
      type: Number
    },
    size: {
      type: String,
      default: "medium"
    }
  };

  function ownKeys$a(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$a(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$a(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$d = config.prefix;
  var name$d = "".concat(prefix$d, "-avatar-group");
  var script$e = vue.defineComponent({
    name: name$d,
    components: {
      Avatar: script$f,
      TNode: TNodeComponent
    },
    props: AvatarGroupProps,
    setup: function setup(props, _ref) {
      var slots = _ref.slots;
      vue.provide("avatarGroup", _objectSpread$a({}, props));
      var internalInstance = vue.getCurrentInstance();
      var classes = vue.computed(function () {
        var _ref2;
        return ["".concat(name$d), (_ref2 = {}, _defineProperty$2(_ref2, "".concat(prefix$d, "-avatar--offset-right"), props.cascading === "right-up"), _defineProperty$2(_ref2, "".concat(prefix$d, "-avatar--offset-left"), props.cascading === "left-up"), _ref2)];
      });
      var isShowEllipsisContent = vue.ref(false);
      var ellipsisContent = vue.ref(null);
      var size = vue.ref(props.size);
      var collapseAvatar = vue.computed(function () {
        return renderTNode(internalInstance, "collapseAvatar");
      });
      var avatarItems = function avatarItems() {
        var childContent = slots.default ? slots.default() : [];
        var children = [];
        childContent.forEach(function (child) {
          if (child.type === vue.Fragment) {
            children.push.apply(children, _toConsumableArray(child.children));
          } else {
            children.push(child);
          }
        });
        var childrenShow = [];
        var max = props.max || 0;
        if (max && max < children.length) {
          childrenShow = children.slice(0, max);
          isShowEllipsisContent.value = true;
          ellipsisContent.value = collapseAvatar.value || "+".concat(children.length - max);
        } else {
          childrenShow = children;
        }
        size.value = childrenShow[0].size || props.size;
        return childrenShow;
      };
      return {
        classes: classes,
        size: size,
        isShowEllipsisContent: isShowEllipsisContent,
        ellipsisContent: ellipsisContent,
        avatarItems: avatarItems
      };
    }
  });

  function render$d(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_avatar = vue.resolveComponent("avatar");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [(vue.openBlock(), vue.createBlock(vue.resolveDynamicComponent(_ctx.avatarItems))), _ctx.isShowEllipsisContent ? (vue.openBlock(), vue.createBlock(_component_avatar, {
      key: 0,
      size: _ctx.size
    }, {
      default: vue.withCtx(function () {
        return [vue.createVNode(_component_t_node, {
          content: _ctx.ellipsisContent
        }, null, 8, ["content"])];
      }),
      _: 1
    }, 8, ["size"])) : vue.createCommentVNode("", true)], 2);
  }

  script$e.render = render$d;

  var Avatar = withInstall(script$f);
  var AvatarGroup = withInstall(script$e);

  var props = {
    content: {
      type: [String, Function]
    },
    default: {
      type: [String, Function]
    },
    disabled: Boolean,
    expanded: {
      type: String,
      validator: function validator(val) {
        return ["left", "right"].includes(val);
      }
    },
    left: {
      type: [Array, Function]
    },
    right: {
      type: [Array, Function]
    },
    onChange: Function,
    onClick: Function
  };

  function ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$9(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$c = config.prefix;
  var name$c = "".concat(prefix$c, "-swipe-cell");
  var script$d = vue.defineComponent({
    name: name$c,
    components: {
      TNode: TNodeComponent,
      TButton: _Button
    },
    props: props,
    emits: ["click", "change"],
    setup: function setup(props2, context) {
      var emitEvent = useEmitEvent(props2, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var swipeContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var swipeLeftMenu = vue.computed(function () {
        return renderTNode(internalInstance, "left");
      });
      var swipeRightMenu = vue.computed(function () {
        return renderTNode(internalInstance, "right");
      });
      var leftRef = vue.ref();
      var rightRef = vue.ref();
      var swipeCell = vue.ref();
      var _useSwipe = useSwipe(swipeCell, {
          threshold: 0,
          onSwipeStart: function onSwipeStart(e) {
            initData.moving = true;
            initData.pos = 0;
          },
          onSwipe: function onSwipe(e) {
            if (props2.disabled) {
              return;
            }
            if (initData.moving && initData.status === "close") {
              initData.moving = false;
            }
            var pos = 0;
            if (lengthX.value < 0) {
              if (initData.leftWidth === 0) {
                initData.moving = false;
                return;
              }
              pos = Math.min(Math.abs(lengthX.value), initData.leftWidth > 0 ? initData.leftWidth + spring : 0);
            } else {
              if (initData.rightWidth === 0) {
                initData.moving = false;
                return;
              }
              pos = Math.max(-lengthX.value, -(initData.rightWidth > 0 ? initData.rightWidth + spring : 0));
            }
            if (initData.status === "close") {
              initData.pos = pos;
            }
          },
          onSwipeEnd: function onSwipeEnd(e) {
            end();
          }
        }),
        lengthX = _useSwipe.lengthX;
      var distance = 0;
      var threshold = 0.5;
      var spring = 0;
      var initData = vue.reactive({
        moving: false,
        leftWidth: 0,
        rightWidth: 0,
        pos: 0,
        status: "close"
      });
      var classes = vue.computed(function () {
        return ["".concat(name$c)];
      });
      vue.onMounted(function () {
        var _leftRef$value, _rightRef$value;
        var leftWidth = (_leftRef$value = leftRef.value) === null || _leftRef$value === void 0 ? void 0 : _leftRef$value.clientWidth;
        var rightWidth = (_rightRef$value = rightRef.value) === null || _rightRef$value === void 0 ? void 0 : _rightRef$value.clientWidth;
        initData.leftWidth = leftWidth > 0 ? leftWidth + distance : 0;
        initData.rightWidth = rightWidth > 0 ? rightWidth + distance : 0;
        renderMenuStatus();
      });
      vue.watch(function () {
        return props2.expanded;
      }, function () {
        return renderMenuStatus();
      });
      onClickOutside(swipeCell, function (event) {
        close();
      });
      var renderMenuStatus = function renderMenuStatus() {
        if (props2.expanded && props2.expanded === "left") {
          if (initData.leftWidth) {
            open("toRight");
          }
        }
        if (props2.expanded && props2.expanded === "right") {
          if (initData.rightWidth) {
            open("toLeft");
          }
        }
      };
      var end = function end() {
        if (props2.disabled) {
          return;
        }
        if (lengthX.value < 0 && initData.pos > initData.leftWidth * threshold) {
          open("toRight");
        } else if (lengthX.value > 0 && -initData.pos > initData.rightWidth * threshold) {
          open("toLeft");
        } else {
          close("force");
        }
      };
      var open = function open(direction) {
        if (initData.status === "open") {
          return;
        }
        initData.moving = true;
        initData.status = "open";
        if (direction === "toLeft") {
          initData.pos = -initData.rightWidth;
          if (initData.rightWidth) {
            emitEvent("change", "right");
          }
        } else {
          initData.pos = initData.leftWidth;
          if (initData.leftWidth) {
            emitEvent("change", "left");
          }
        }
      };
      var close = function close(type) {
        if (initData.status === "close" && type !== "force") {
          return;
        }
        initData.moving = true;
        initData.status = "close";
        initData.pos = 0;
        emitEvent("change", void 0);
      };
      var handleClickBtn = function handleClickBtn(_ref) {
        var action = _ref.action,
          source = _ref.source;
        {
          close();
        }
        if (action.onClick) {
          action.onClick();
          return;
        }
        emitEvent("click", {
          action: action,
          source: source
        });
      };
      return _objectSpread$9(_objectSpread$9({}, vue.toRefs(props2)), {}, {
        swipeContent: swipeContent,
        swipeLeftMenu: swipeLeftMenu,
        swipeRightMenu: swipeRightMenu,
        initData: initData,
        classes: classes,
        swipeCell: swipeCell,
        leftRef: leftRef,
        rightRef: rightRef,
        handleClickBtn: handleClickBtn,
        end: end
      });
    }
  });

  function ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$8(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function render$c(_ctx, _cache, $props, $setup, $data, $options) {
    var _normalizeClass2;
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_button = vue.resolveComponent("t-button");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes),
      onTouchend: _cache[2] || (_cache[2] = function () {
        return _ctx.end && _ctx.end.apply(_ctx, arguments);
      }),
      onTouchcancel: _cache[3] || (_cache[3] = function () {
        return _ctx.end && _ctx.end.apply(_ctx, arguments);
      }),
      onMouseup: _cache[4] || (_cache[4] = function () {
        return _ctx.end && _ctx.end.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass((_normalizeClass2 = {}, _defineProperty$2(_normalizeClass2, _ctx.classes + "__wrapper", true), _defineProperty$2(_normalizeClass2, "moving", _ctx.initData.moving), _normalizeClass2)),
      style: vue.normalizeStyle({
        transform: "translate3d(".concat(_ctx.initData.pos, "px,0,0)")
      })
    }, [vue.createElementVNode("div", {
      ref: "leftRef",
      class: vue.normalizeClass(_ctx.classes + "__left"),
      style: vue.normalizeStyle({
        width: _ctx.initData.leftWidth ? "".concat(_ctx.initData.leftWidth, "px") : "auto"
      }),
      onTouchstartPassive: _cache[0] || (_cache[0] = vue.withModifiers(function () {}, ["stop"]))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.swipeLeftMenu
    }, null, 8, ["content"]), (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.left, function (btn, index) {
      return vue.openBlock(), vue.createBlock(_component_t_button, {
        key: index,
        class: vue.normalizeClass(btn.className || ""),
        style: vue.normalizeStyle(btn.style || "height: 100%"),
        onClick: function onClick($event) {
          return _ctx.handleClickBtn({
            action: _objectSpread$8({}, btn),
            source: "left"
          });
        }
      }, {
        default: vue.withCtx(function () {
          return [vue.createTextVNode(vue.toDisplayString(btn.text), 1)];
        }),
        _: 2
      }, 1032, ["class", "style", "onClick"]);
    }), 128))], 38), vue.createElementVNode("div", {
      ref: "swipeCell",
      class: vue.normalizeClass(_ctx.classes + "__content")
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.swipeContent
    }, null, 8, ["content"])], 2), vue.createElementVNode("div", {
      ref: "rightRef",
      class: vue.normalizeClass(_ctx.classes + "__right"),
      style: vue.normalizeStyle({
        width: _ctx.initData.rightWidth ? "".concat(_ctx.initData.rightWidth, "px") : "auto"
      }),
      onTouchstartPassive: _cache[1] || (_cache[1] = vue.withModifiers(function () {}, ["stop"]))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.swipeRightMenu
    }, null, 8, ["content"]), (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.right, function (btn, index) {
      return vue.openBlock(), vue.createBlock(_component_t_button, {
        key: index,
        class: vue.normalizeClass(btn.className || ""),
        style: vue.normalizeStyle(btn.style || "height: 100%"),
        onClick: function onClick($event) {
          return _ctx.handleClickBtn({
            action: _objectSpread$8({}, btn),
            source: "right"
          });
        }
      }, {
        default: vue.withCtx(function () {
          return [vue.createTextVNode(vue.toDisplayString(btn.text), 1)];
        }),
        _: 2
      }, 1032, ["class", "style", "onClick"]);
    }), 128))], 38)], 6)], 34);
  }

  script$d.render = render$c;

  var SwipeCell = withInstall(script$d);

  var baseGetTag$3 = _baseGetTag,
    isObjectLike$4 = isObjectLike_1;

  /** `Object#toString` result references. */
  var numberTag$2 = '[object Number]';

  /**
   * Checks if `value` is classified as a `Number` primitive or object.
   *
   * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
   * classified as numbers, use the `_.isFinite` method.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(3);
   * // => true
   *
   * _.isNumber(Number.MIN_VALUE);
   * // => true
   *
   * _.isNumber(Infinity);
   * // => true
   *
   * _.isNumber('3');
   * // => false
   */
  function isNumber(value) {
    return typeof value == 'number' || isObjectLike$4(value) && baseGetTag$3(value) == numberTag$2;
  }
  var isNumber_1 = isNumber;
  var isNumber$1 = isNumber_1;

  var SkeletonProps = {
    animation: {
      type: String,
      validator: function validator(val) {
        if (!val) return true;
        return ["gradient", "flashed"].includes(val);
      }
    },
    content: {
      type: [String, Function]
    },
    default: {
      type: [String, Function]
    },
    delay: {
      type: Number,
      default: 0
    },
    loading: {
      type: Boolean,
      default: true
    },
    rowCol: {
      type: Array
    },
    theme: {
      type: String,
      default: "text",
      validator: function validator(val) {
        if (!val) return true;
        return ["text", "avatar", "paragraph", "image"].includes(val);
      }
    }
  };

  function ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$7(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$b = config.prefix;
  var name$b = "".concat(prefix$b, "-skeleton");
  var ThemeMap = {
    avatar: [{
      type: "circle",
      height: "64px",
      width: "64px"
    }],
    image: [{
      type: "rect",
      height: "64px",
      width: "64px"
    }],
    text: [1, [{
      width: "24%",
      height: "16px",
      marginRight: "16px"
    }, {
      width: "76%",
      height: "16px"
    }]],
    paragraph: [1, 1, 1, {
      width: "55%"
    }]
  };
  var script$c = vue.defineComponent({
    name: name$b,
    components: {
      TNode: TNodeComponent
    },
    props: SkeletonProps,
    setup: function setup(props) {
      var _toRefs = vue.toRefs(props),
        loading = _toRefs.loading,
        animation = _toRefs.animation;
      var showContent = vue.computed(function () {
        return !loading.value;
      });
      var internalInstance = vue.getCurrentInstance();
      var skeletonContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var baseClass = name$b;
      var rootClasses = vue.computed(function () {
        return ["".concat(name$b)];
      });
      var rowCols = vue.ref([]);
      vue.watchEffect(function () {
        var _props$rowCol;
        if ((_props$rowCol = props.rowCol) !== null && _props$rowCol !== void 0 && _props$rowCol.length) {
          rowCols.value = _toConsumableArray(props.rowCol);
        } else {
          rowCols.value = _toConsumableArray(ThemeMap[props.theme || "text"]);
        }
      });
      var getColItemClass = function getColItemClass(obj) {
        return ["".concat(name$b, "__col"), "".concat(name$b, "--type-").concat(obj.type || "text"), _defineProperty$2({}, "".concat(name$b, "--animation-").concat(animation.value), animation.value)];
      };
      var getColItemStyle = function getColItemStyle(obj) {
        var styleName = ["width", "height", "marginRight", "marginLeft", "margin", "size", "background", "backgroundColor", "borderRadius"];
        var style = {};
        styleName.forEach(function (name2) {
          if (name2 in obj) {
            var px = isNumber$1(obj[name2]) ? "".concat(obj[name2], "px") : obj[name2];
            if (name2 === "size") {
              var _ref2 = [px, px];
              style.width = _ref2[0];
              style.height = _ref2[1];
            } else {
              style[name2] = px;
            }
          }
        });
        return style;
      };
      var parsedRowcols = vue.computed(function () {
        return rowCols.value.map(function (item) {
          if (isNumber$1(item)) {
            return [{
              class: getColItemClass({
                type: "text"
              }),
              style: {}
            }];
          }
          if (Array.isArray(item)) {
            return item.map(function (col) {
              return _objectSpread$7(_objectSpread$7({}, col), {}, {
                class: getColItemClass(col),
                style: getColItemStyle(col)
              });
            });
          }
          var nItem = item;
          return [_objectSpread$7(_objectSpread$7({}, nItem), {}, {
            class: getColItemClass(nItem),
            style: getColItemStyle(nItem)
          })];
        });
      });
      return {
        baseClass: baseClass,
        rootClasses: rootClasses,
        parsedRowcols: parsedRowcols,
        showContent: showContent,
        skeletonContent: skeletonContent
      };
    }
  });

  function render$b(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.rootClasses)
    }, [_ctx.showContent ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.skeletonContent
    }, null, 8, ["content"])) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 1
    }, [_ctx.parsedRowcols.length ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.baseClass, "__content"))
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.parsedRowcols, function (row, index) {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: "row-".concat(index),
        class: vue.normalizeClass("".concat(_ctx.baseClass, "__row"))
      }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(row, function (col, idx) {
        return vue.openBlock(), vue.createElementBlock("div", {
          key: "col-".concat(idx),
          class: vue.normalizeClass(col.class),
          style: vue.normalizeStyle(col.style)
        }, null, 6);
      }), 128))], 2);
    }), 128))], 2)) : vue.createCommentVNode("", true)], 64))], 2);
  }

  script$c.render = render$b;

  var _Skeleton = withInstall(script$c);

  function setStyle(el, styles) {
    var keys = Object.keys(styles);
    keys.forEach(function (key) {
      el.style[key] = styles[key];
    });
  }

  function ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$6(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function circleAdapter(circleElem) {
    var _window, _window$getComputedSt2, _window2, _window2$navigator;
    var basicStyle = {};
    if (!circleElem) {
      return;
    }
    var _window$getComputedSt = (_window = window) === null || _window === void 0 ? void 0 : (_window$getComputedSt2 = _window.getComputedStyle) === null || _window$getComputedSt2 === void 0 ? void 0 : _window$getComputedSt2.call(_window, circleElem),
      color = _window$getComputedSt.color,
      fontSize = _window$getComputedSt.fontSize;
    var ua = (_window2 = window) === null || _window2 === void 0 ? void 0 : (_window2$navigator = _window2.navigator) === null || _window2$navigator === void 0 ? void 0 : _window2$navigator.userAgent;
    var isSafari = /Safari/.test(ua) && !/Chrome/.test(ua);
    var isIosWechat = /(?=.*iPhone)[?=.*MicroMessenger]/.test(ua) && !/Chrome/.test(ua);
    var isMobile = /Mobile/.test(ua);
    if ((isSafari || isIosWechat) && !isMobile) {
      basicStyle = {
        transformOrigin: "-1px -1px",
        transform: "scale(".concat(parseInt(fontSize, 10) / 14, ")")
      };
    }
    if (color && getIEVersion() > 11) {
      var matched = color.match(/[\d.]+/g);
      var endColor = matched ? "rgba(".concat(matched[0], ", ").concat(matched[1], ", ").concat(matched[2], ", 0)") : "";
      setStyle(circleElem, _objectSpread$6(_objectSpread$6({}, basicStyle), {}, {
        background: "conic-gradient(from 90deg at 50% 50%,".concat(endColor, " 0deg, ").concat(color, " 360deg)")
      }));
    } else {
      setStyle(circleElem, _objectSpread$6(_objectSpread$6({}, basicStyle), {}, {
        background: ""
      }));
    }
  }

  var prefix$a = config.prefix;
  var name$a = "".concat(prefix$a, "-loading__gradient");
  var classname = "".concat(prefix$a, "-icon-loading");
  var script$b = vue.defineComponent({
    name: name$a,
    props: {
      style: [Object, String]
    },
    setup: function setup() {
      var classes = [name$a, classname];
      return {
        name: name$a,
        classes: classes
      };
    },
    mounted: function mounted() {
      var _this = this;
      this.$nextTick(function () {
        _this.updateColor();
      });
    },
    updated: function updated() {
      this.updateColor();
    },
    methods: {
      updateColor: function updateColor() {
        var circleElem = this.$refs.circle;
        circleAdapter(circleElem);
      }
    }
  });

  var _hoisted_1$4 = {
    x: "1",
    y: "1",
    width: "12",
    height: "12"
  };
  function render$a(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("svg", {
      style: vue.normalizeStyle(_ctx.style),
      class: vue.normalizeClass(_ctx.classes),
      viewBox: "0 0 14 14",
      version: "1.1",
      width: "1em",
      height: "1em",
      xmlns: "http://www.w3.org/2000/svg"
    }, [(vue.openBlock(), vue.createElementBlock("foreignObject", _hoisted_1$4, [vue.createElementVNode("div", {
      ref: "circle",
      class: vue.normalizeClass("".concat(_ctx.name, "-conic"))
    }, null, 2)]))], 6);
  }

  script$b.render = render$a;

  var prefix$9 = config.prefix;
  var name$9 = "".concat(prefix$9, "-loading__spinner");
  var script$a = vue.defineComponent({
    name: name$9,
    props: {
      style: [Object, String]
    },
    setup: function setup() {
      return {
        name: name$9
      };
    }
  });

  function render$9(_ctx, _cache, $props, $setup, $data, $options) {
    return vue.openBlock(), vue.createElementBlock("span", {
      class: vue.normalizeClass(_ctx.name),
      style: vue.normalizeStyle(_ctx.style)
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(new Array(12), function (item, index) {
      return vue.openBlock(), vue.createElementBlock("i", {
        key: index,
        class: vue.normalizeClass(["".concat(_ctx.name, "--line"), "".concat(_ctx.name, "--line-").concat(index + 1)])
      }, null, 2);
    }), 128))], 6);
  }

  script$a.render = render$9;

  var LoadingProps = {
    default: {
      type: [String, Function]
    },
    content: {
      type: [String, Function]
    },
    delay: {
      type: Number,
      default: 0
    },
    duration: {
      type: Number,
      default: 800
    },
    indicator: {
      type: Boolean,
      default: true
    },
    inheritColor: Boolean,
    layout: {
      type: String,
      default: "horizontal",
      validator: function validator(val) {
        if (!val) return true;
        return ["horizontal", "vertical"].includes(val);
      }
    },
    loading: {
      type: Boolean,
      default: true
    },
    pause: Boolean,
    progress: {
      type: Number
    },
    reverse: Boolean,
    size: {
      type: String,
      default: "40rpx"
    },
    text: {
      type: String
    },
    theme: {
      type: String,
      default: "circular",
      validator: function validator(val) {
        if (!val) return true;
        return ["circular", "spinner", "bar", "error", "dots"].includes(val);
      }
    }
  };

  var prefix$8 = config.prefix;
  var name$8 = "".concat(prefix$8, "-loading");
  var toBarPerc = function toBarPerc(n) {
    if (!n || n <= 0) return -100;
    if (n > 1) return 0;
    return (-1 + n) * 100;
  };
  var script$9 = vue.defineComponent({
    name: name$8,
    components: {
      GradientIcon: script$b,
      SpinnerIcon: script$a,
      TNode: TNodeComponent
    },
    props: LoadingProps,
    setup: function setup(props) {
      var internalInstance = vue.getCurrentInstance();
      var delayShowLoading = vue.ref(false);
      var _toRefs = vue.toRefs(props),
        pause = _toRefs.pause;
      var countDelay = function countDelay() {
        delayShowLoading.value = false;
        var timer = setTimeout(function () {
          delayShowLoading.value = true;
          clearTimeout(timer);
        }, props.delay);
      };
      var realLoading = vue.computed(function () {
        return (!props.delay || delayShowLoading.value) && props.loading;
      });
      vue.watch(function () {
        return props.loading;
      }, function (value) {
        if (value) {
          props.delay && countDelay();
        }
      }, {
        immediate: true
      });
      var rootClass = vue.computed(function () {
        return [name$8, _defineProperty$2({}, "".concat(name$8, "--vertical"), props.layout === "vertical"), _defineProperty$2({}, "".concat(name$8, "--bar"), props.theme === "bar"), props.size ? ClASSNAMES.SIZE[props.size] : ""];
      });
      var textClass = vue.computed(function () {
        return ["".concat(name$8, "__text"), _defineProperty$2({}, "".concat(name$8, "__text--error"), props.theme === "error"), _defineProperty$2({}, "".concat(name$8, "__text--only"), !props.indicator || props.theme === "error")];
      });
      var textContent = vue.computed(function () {
        if (props.theme === "error") {
          return "\u52A0\u8F7D\u5931\u8D25";
        }
        return renderTNode(internalInstance, "text");
      });
      var defaultContent = vue.computed(function () {
        return renderContent(internalInstance, "default", "content");
      });
      var rootStyle = vue.computed(function () {
        if (props.inheritColor) {
          return "color: inherit";
        }
        return "";
      });
      var barStyle = vue.computed(function () {
        return {
          transform: "translate3d(".concat(toBarPerc(props.progress), "%, 0px, 0px)")
        };
      });
      var animationStyle = vue.computed(function () {
        var ans = {};
        if (props.pause) {
          ans["animation-play-state"] = "paused";
        }
        if (props.reverse) {
          ans["animation-direction"] = "reverse";
        }
        if (props.duration) {
          ans["animation-duration"] = "".concat(props.duration, "ms");
        }
        return ans;
      });
      return {
        name: name$8,
        pause: pause,
        rootClass: rootClass,
        textClass: textClass,
        textContent: textContent,
        defaultContent: defaultContent,
        rootStyle: rootStyle,
        barStyle: barStyle,
        animationStyle: animationStyle,
        realLoading: realLoading
      };
    }
  });

  function render$8(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_gradient_icon = vue.resolveComponent("gradient-icon");
    var _component_spinner_icon = vue.resolveComponent("spinner-icon");
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.rootClass),
      style: vue.normalizeStyle(_ctx.rootStyle)
    }, [_ctx.theme === "bar" && _ctx.progress && ![0, 1].includes(_ctx.progress) ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__bar")),
      style: vue.normalizeStyle(_ctx.barStyle)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__shadow"))
    }, null, 2)], 6)) : _ctx.theme !== "bar" ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 1
    }, [_ctx.indicator && _ctx.realLoading ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 0
    }, [_ctx.theme === "circular" ? (vue.openBlock(), vue.createBlock(_component_gradient_icon, {
      key: 0,
      style: vue.normalizeStyle(_ctx.animationStyle)
    }, null, 8, ["style"])) : _ctx.theme === "spinner" ? (vue.openBlock(), vue.createBlock(_component_spinner_icon, {
      key: 1,
      style: vue.normalizeStyle(_ctx.animationStyle)
    }, null, 8, ["style"])) : _ctx.theme === "dots" ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 2,
      class: vue.normalizeClass("".concat(_ctx.name, "__dots")),
      style: vue.normalizeStyle(_ctx.animationStyle)
    }, null, 6)) : vue.createCommentVNode("", true)], 64)) : vue.createCommentVNode("", true), _ctx.textContent && _ctx.realLoading ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 1,
      class: vue.normalizeClass(_ctx.textClass)
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.textContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), vue.createVNode(_component_t_node, {
      content: _ctx.defaultContent
    }, null, 8, ["content"])], 64)) : vue.createCommentVNode("", true)], 6);
  }

  script$9.render = render$8;

  var _Loading = withInstall(script$9);

  var ListProps = {
    asyncLoading: {
      type: [String, Function]
    },
    footer: {
      type: [String, Function]
    },
    header: {
      type: [String, Function]
    },
    onLoadMore: Function,
    onScroll: Function
  };

  var prefix$7 = config.prefix;
  var name$7 = "".concat(prefix$7, "-list");
  var LOADING_TEXT_MAP = {
    loading: "\u52A0\u8F7D\u4E2D...",
    "load-more": "\u70B9\u51FB\u52A0\u8F7D\u66F4\u591A"
  };
  var script$8 = vue.defineComponent({
    name: name$7,
    components: {
      TLoading: _Loading,
      TNode: TNodeComponent
    },
    props: ListProps,
    emits: ["load-more", "scroll"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var root = vue.ref();
      var empty = vue.ref();
      var scrollParent = useScrollParent(root);
      var _useWindowSize = useWindowSize(),
        height = _useWindowSize.height;
      var internalInstance = vue.getCurrentInstance();
      var headerContent = vue.computed(function () {
        return renderTNode(internalInstance, "header");
      });
      var footerContent = vue.computed(function () {
        return renderTNode(internalInstance, "footer");
      });
      var onLoadMore = function onLoadMore(e) {
        if (props.asyncLoading === "load-more") {
          emitEvent("load-more");
        }
      };
      var handleScroll = function handleScroll(e) {
        var _useElementBounding = useElementBounding(root),
          top = _useElementBounding.top;
        emitEvent("scroll", top.value - height.value, document.documentElement.scrollTop);
      };
      useEventListener(scrollParent, "scroll", handleScroll);
      return {
        name: name$7,
        root: root,
        empty: empty,
        onLoadMore: onLoadMore,
        handleScroll: handleScroll,
        headerContent: headerContent,
        footerContent: footerContent,
        LOADING_TEXT_MAP: LOADING_TEXT_MAP
      };
    }
  });

  function render$7(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_loading = vue.resolveComponent("t-loading");
    return vue.openBlock(), vue.createElementBlock("div", {
      ref: "root",
      class: vue.normalizeClass(_ctx.name),
      onScroll: _cache[1] || (_cache[1] = function () {
        return _ctx.handleScroll && _ctx.handleScroll.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.headerContent
    }, null, 8, ["content"]), vue.renderSlot(_ctx.$slots, "default"), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__loading--wrapper")),
      onClick: _cache[0] || (_cache[0] = vue.withModifiers(function () {
        return _ctx.onLoadMore && _ctx.onLoadMore.apply(_ctx, arguments);
      }, ["stop"]))
    }, [typeof _ctx.asyncLoading === "string" && ["loading", "load-more"].includes(_ctx.asyncLoading) ? (vue.openBlock(), vue.createBlock(_component_t_loading, {
      key: 0,
      loading: _ctx.asyncLoading === "loading",
      text: typeof _ctx.asyncLoading === "string" ? _ctx.LOADING_TEXT_MAP[_ctx.asyncLoading] : "",
      class: vue.normalizeClass("".concat(_ctx.name, "__loading"))
    }, null, 8, ["loading", "text", "class"])) : vue.createCommentVNode("", true)], 2), vue.createVNode(_component_t_node, {
      content: _ctx.footerContent
    }, null, 8, ["content"])], 34);
  }

  script$8.render = render$7;

  var _List = withInstall(script$8);

  var BackTopProps = {
    fixed: {
      type: Boolean,
      default: true
    },
    icon: {
      type: Function,
      default: "backtop"
    },
    target: {
      type: Function
    },
    text: {
      type: String,
      default: ""
    },
    theme: {
      type: String,
      default: "round",
      validator: function validator(val) {
        if (!val) return true;
        return ["round", "half-round", "round-dark", "half-round-dark"].includes(val);
      }
    },
    onToTop: Function
  };

  var prefix$6 = config.prefix;
  var name$6 = "".concat(prefix$6, "-back-top");
  var script$7 = vue.defineComponent({
    name: name$6,
    components: {
      TNode: TNodeComponent,
      TIconBackTop: backtop
    },
    props: BackTopProps,
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var el = vue.computed(function () {
        return props.target ? props.target() : window.document.documentElement;
      });
      var _useElementBounding = useElementBounding(el),
        top = _useElementBounding.top;
      var classes = vue.computed(function () {
        var _ref;
        return _ref = {}, _defineProperty$2(_ref, "".concat(name$6), true), _defineProperty$2(_ref, "".concat(prefix$6, "-is-fixed"), props.fixed), _defineProperty$2(_ref, "".concat(name$6, "--").concat(props.theme), true), _ref;
      });
      var internalInstance = vue.getCurrentInstance();
      var iconTNode = vue.computed(function () {
        var _context$slots;
        if ((_context$slots = context.slots) !== null && _context$slots !== void 0 && _context$slots.icon || typeof props.icon === "function") {
          return renderTNode(internalInstance, "icon");
        }
        return false;
      });
      var clickBackBtn = function clickBackBtn() {
        window.document.documentElement.scrollTop += top.value;
        emitEvent("to-top");
      };
      return {
        name: name$6,
        classes: classes,
        iconTNode: iconTNode,
        el: el,
        top: top,
        clickBackBtn: clickBackBtn
      };
    }
  });

  function render$6(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_t_icon_back_top = vue.resolveComponent("t-icon-back-top");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.clickBackBtn && _ctx.clickBackBtn.apply(_ctx, arguments);
      })
    }, [_ctx.iconTNode ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.iconTNode
    }, null, 8, ["content"])) : (vue.openBlock(), vue.createBlock(_component_t_icon_back_top, {
      key: 1
    })), _ctx.text ? (vue.openBlock(), vue.createElementBlock("span", {
      key: 2,
      class: vue.normalizeClass("".concat(_ctx.name, "__text")),
      style: {
        "min-width": "12px",
        "max-width": "24px",
        width: "auto",
        display: "inline-block"
      }
    }, vue.toDisplayString(_ctx.text), 3)) : vue.createCommentVNode("", true)], 2);
  }

  script$7.render = render$6;

  var _BackTop = withInstall(script$7);

  var PullDownRefreshProps = {
    loadingBarHeight: {
      type: [String, Number],
      default: 50
    },
    loadingProps: {
      type: Object
    },
    loadingTexts: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    maxBarHeight: {
      type: [String, Number],
      default: 80
    },
    refreshTimeout: {
      type: Number,
      default: 3e3
    },
    value: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultValue: Boolean,
    onChange: Function,
    onRefresh: Function,
    onTimeout: Function
  };

  var isElement = function isElement(node) {
    var ELEMENT_NODE_TYPE = 1;
    return node.tagName !== "HTML" && node.tagName !== "BODY" && node.nodeType === ELEMENT_NODE_TYPE;
  };
  function useTouch() {
    var startY = vue.ref(0);
    var deltaY = vue.ref(0);
    var start = function start(event) {
      startY.value = event.touches[0].clientY;
      deltaY.value = 0;
    };
    var move = function move(event) {
      var touch = event.touches[0];
      deltaY.value = touch.clientY - startY.value;
    };
    return {
      startY: startY,
      deltaY: deltaY,
      start: start,
      move: move
    };
  }
  var easeDistance = function easeDistance(distance, pullDistance) {
    if (distance > pullDistance) {
      if (distance < pullDistance * 2) {
        distance = pullDistance + (distance - pullDistance) / 2;
      } else {
        distance = pullDistance * 1.5 + (distance - pullDistance * 2) / 4;
      }
    }
    return Math.round(distance);
  };
  var getScrollParent = function getScrollParent(node) {
    var res = node;
    while (res && isElement(res)) {
      if (/auto|scroll/i.test(window.getComputedStyle(res).overflowY)) {
        return res;
      }
      res = res.parentNode;
    }
  };
  var isReachTop = function isReachTop(e) {
    var scrollParent = getScrollParent(e.target);
    return !scrollParent || !scrollParent.scrollTop;
  };

  function ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$5(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$5 = config.prefix;
  var name$5 = "".concat(prefix$5, "-pull-down-refresh");
  var ANIMATION_DURATION = 300;
  var statusName = ["pulling", "loosing", "loading", "success", "initial"];
  var script$6 = vue.defineComponent({
    name: name$5,
    components: {
      TLoading: _Loading
    },
    props: PullDownRefreshProps,
    emits: ["refresh", "timeout", "update:value", "update:modelValue"],
    setup: function setup(props, context) {
      var _props$loadingTexts;
      var emitEvent = useEmitEvent(props, context.emit);
      var trackStyle = vue.computed(function () {
        return {
          transitionDuration: "".concat(ANIMATION_DURATION, "ms"),
          transform: "translate3d(0, ".concat(distance.value, "px, 0)")
        };
      });
      var loadingBarStyles = vue.computed(function () {
        return {
          height: typeof props.loadingBarHeight === "number" ? "".concat(props.loadingBarHeight, "px") : props.loadingBarHeight
        };
      });
      var maxBarStyles = vue.computed(function () {
        return {
          height: typeof props.maxBarHeight === "number" ? "".concat(props.maxBarHeight, "px") : props.maxBarHeight
        };
      });
      var loadingIconProps = vue.computed(function () {
        return _objectSpread$5({}, props.loadingProps);
      });
      var isLoading = vue.ref(false);
      var distance = vue.ref(0);
      var _toRefs = vue.toRefs(props),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        statusValue = _useVModel2[0],
        setStatusValue = _useVModel2[1];
      var status = vue.computed(function () {
        if (!statusValue.value && isLoading.value) {
          return "success";
        }
        if (!statusValue.value || distance.value === 0) {
          return "initial";
        }
        if (distance.value < loadingBarHeight.value) {
          return "pulling";
        }
        if (isLoading.value) {
          return "loading";
        }
        return "loosing";
      });
      vue.watch(status, function (newVal) {
        if (newVal === "success" || newVal === "initial") {
          setTimeout(function () {
            distance.value = 0;
            isLoading.value = false;
          }, 300);
        }
      });
      var loadingTexts = vue.ref((_props$loadingTexts = props.loadingTexts) !== null && _props$loadingTexts !== void 0 && _props$loadingTexts.length ? props.loadingTexts : ["\u4E0B\u62C9\u5237\u65B0", "\u677E\u624B\u5237\u65B0", "\u6B63\u5728\u5237\u65B0", "\u5237\u65B0\u5B8C\u6210"]);
      var loadingText = vue.computed(function () {
        var index = statusName.indexOf(status.value);
        return index >= 0 ? loadingTexts.value[index] : "";
      });
      var touch = useTouch();
      var loadingBar = vue.ref(null);
      var maxBar = vue.ref(null);
      var _useElementSize = useElementSize(loadingBar),
        loadingBarHeight = _useElementSize.height;
      var _useElementSize2 = useElementSize(maxBar),
        maxBarHeight = _useElementSize2.height;
      var onTouchStart = function onTouchStart(e) {
        if (!isReachTop(e) || isLoading.value) return;
        setStatusValue(true);
        distance.value = 0;
        touch.start(e);
      };
      var onTouchMove = function onTouchMove(e) {
        if (!isReachTop(e) || isLoading.value) return;
        var deltaY = touch.deltaY;
        var nextDistance = easeDistance(deltaY.value, loadingBarHeight.value);
        if (deltaY.value > 0) {
          e.preventDefault();
        }
        if (nextDistance >= 0 && nextDistance < maxBarHeight.value) {
          distance.value = nextDistance;
        }
        touch.move(e);
      };
      var timer = null;
      var onTouchEnd = function onTouchEnd(e) {
        if (!isReachTop(e) || isLoading.value) return;
        if (status.value === "loosing") {
          distance.value = loadingBarHeight.value;
          isLoading.value = true;
          emitEvent("refresh");
          timer = setTimeout(function () {
            if (isLoading.value) {
              emitEvent("timeout");
              setStatusValue(false);
            }
          }, props.refreshTimeout);
        } else {
          setStatusValue(false);
        }
      };
      vue.onUnmounted(function () {
        clearTimeout(timer);
      });
      return {
        name: name$5,
        status: status,
        trackStyle: trackStyle,
        loadingText: loadingText,
        maxBarStyles: maxBarStyles,
        loadingBarStyles: loadingBarStyles,
        loadingIconProps: loadingIconProps,
        loadingBar: loadingBar,
        maxBar: maxBar,
        onTouchStart: onTouchStart,
        onTouchMove: onTouchMove,
        onTouchEnd: onTouchEnd
      };
    }
  });

  var _hoisted_1$3 = {
    key: 0
  };
  var _hoisted_2$2 = {
    key: 1
  };
  function render$5(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_loading = vue.resolveComponent("t-loading");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.name)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__track")),
      style: vue.normalizeStyle(_ctx.trackStyle),
      onTouchstart: _cache[0] || (_cache[0] = vue.withModifiers(function () {
        return _ctx.onTouchStart && _ctx.onTouchStart.apply(_ctx, arguments);
      }, ["stop"])),
      onTouchmove: _cache[1] || (_cache[1] = vue.withModifiers(function () {
        return _ctx.onTouchMove && _ctx.onTouchMove.apply(_ctx, arguments);
      }, ["stop"])),
      onTouchend: _cache[2] || (_cache[2] = vue.withModifiers(function () {
        return _ctx.onTouchEnd && _ctx.onTouchEnd.apply(_ctx, arguments);
      }, ["stop"])),
      onTouchcancel: _cache[3] || (_cache[3] = vue.withModifiers(function () {
        return _ctx.onTouchEnd && _ctx.onTouchEnd.apply(_ctx, arguments);
      }, ["stop"]))
    }, [vue.createElementVNode("div", {
      ref: "maxBar",
      class: vue.normalizeClass("".concat(_ctx.name, "__max")),
      style: vue.normalizeStyle(_ctx.maxBarStyles)
    }, [vue.createElementVNode("div", {
      ref: "loadingBar",
      class: vue.normalizeClass("".concat(_ctx.name, "__loading")),
      style: vue.normalizeStyle(_ctx.loadingBarStyles)
    }, [_ctx.status === "loading" ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$3, [vue.createVNode(_component_t_loading, vue.mergeProps({
      text: _ctx.loadingText,
      class: "".concat(_ctx.name, "__loading-icon")
    }, _ctx.loadingIconProps), null, 16, ["text", "class"])])) : (vue.openBlock(), vue.createElementBlock("div", _hoisted_2$2, vue.toDisplayString(_ctx.loadingText), 1))], 6)], 6), vue.renderSlot(_ctx.$slots, "default")], 38)], 2);
  }

  script$6.render = render$5;

  var _PullDownRefresh = withInstall(script$6);

  var ListCache$2 = _ListCache;

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear$1() {
    this.__data__ = new ListCache$2();
    this.size = 0;
  }
  var _stackClear = stackClear$1;

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete$1(key) {
    var data = this.__data__,
      result = data['delete'](key);
    this.size = data.size;
    return result;
  }
  var _stackDelete = stackDelete$1;

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet$1(key) {
    return this.__data__.get(key);
  }
  var _stackGet = stackGet$1;

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas$1(key) {
    return this.__data__.has(key);
  }
  var _stackHas = stackHas$1;

  var ListCache$1 = _ListCache,
    Map$1 = _Map,
    MapCache$1 = _MapCache;

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet$1(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache$1) {
      var pairs = data.__data__;
      if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache$1(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  var _stackSet = stackSet$1;

  var ListCache = _ListCache,
    stackClear = _stackClear,
    stackDelete = _stackDelete,
    stackGet = _stackGet,
    stackHas = _stackHas,
    stackSet = _stackSet;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack$2(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }

  // Add methods to `Stack`.
  Stack$2.prototype.clear = stackClear;
  Stack$2.prototype['delete'] = stackDelete;
  Stack$2.prototype.get = stackGet;
  Stack$2.prototype.has = stackHas;
  Stack$2.prototype.set = stackSet;
  var _Stack = Stack$2;

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome$1(array, predicate) {
    var index = -1,
      length = array == null ? 0 : array.length;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  var _arraySome = arraySome$1;

  var SetCache = _SetCache,
    arraySome = _arraySome,
    cacheHas = _cacheHas;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$5 = 1,
    COMPARE_UNORDERED_FLAG$3 = 2;

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `array` and `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays$2(array, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5,
      arrLength = array.length,
      othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    // Check that cyclic values are equal.
    var arrStacked = stack.get(array);
    var othStacked = stack.get(other);
    if (arrStacked && othStacked) {
      return arrStacked == other && othStacked == array;
    }
    var index = -1,
      result = true,
      seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : undefined;
    stack.set(array, other);
    stack.set(other, array);

    // Ignore non-index properties.
    while (++index < arrLength) {
      var arrValue = array[index],
        othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== undefined) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      // Recursively compare arrays (susceptible to call stack limits).
      if (seen) {
        if (!arraySome(other, function (othValue, othIndex) {
          if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
            return seen.push(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
        result = false;
        break;
      }
    }
    stack['delete'](array);
    stack['delete'](other);
    return result;
  }
  var _equalArrays = equalArrays$2;

  var root$4 = _root;

  /** Built-in value references. */
  var Uint8Array$1 = root$4.Uint8Array;
  var _Uint8Array = Uint8Array$1;

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray$1(map) {
    var index = -1,
      result = Array(map.size);
    map.forEach(function (value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  var _mapToArray = mapToArray$1;

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray$1(set) {
    var index = -1,
      result = Array(set.size);
    set.forEach(function (value) {
      result[++index] = value;
    });
    return result;
  }
  var _setToArray = setToArray$1;

  var _Symbol = _Symbol$4,
    Uint8Array = _Uint8Array,
    eq = eq_1,
    equalArrays$1 = _equalArrays,
    mapToArray = _mapToArray,
    setToArray = _setToArray;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$4 = 1,
    COMPARE_UNORDERED_FLAG$2 = 2;

  /** `Object#toString` result references. */
  var boolTag$1 = '[object Boolean]',
    dateTag$1 = '[object Date]',
    errorTag$1 = '[object Error]',
    mapTag$2 = '[object Map]',
    numberTag$1 = '[object Number]',
    regexpTag$1 = '[object RegExp]',
    setTag$2 = '[object Set]',
    stringTag$1 = '[object String]',
    symbolTag = '[object Symbol]';
  var arrayBufferTag$1 = '[object ArrayBuffer]',
    dataViewTag$2 = '[object DataView]';

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag$1(object, other, tag, bitmask, customizer, equalFunc, stack) {
    switch (tag) {
      case dataViewTag$2:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag$1:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
          return false;
        }
        return true;
      case boolTag$1:
      case dateTag$1:
      case numberTag$1:
        // Coerce booleans to `1` or `0` and dates to milliseconds.
        // Invalid dates are coerced to `NaN`.
        return eq(+object, +other);
      case errorTag$1:
        return object.name == other.name && object.message == other.message;
      case regexpTag$1:
      case stringTag$1:
        // Coerce regexes to strings and treat strings, primitives and objects,
        // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
        // for more details.
        return object == other + '';
      case mapTag$2:
        var convert = mapToArray;
      case setTag$2:
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        // Assume cyclic values are equal.
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= COMPARE_UNORDERED_FLAG$2;

        // Recursively compare objects (susceptible to call stack limits).
        stack.set(object, other);
        var result = equalArrays$1(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
        stack['delete'](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  var _equalByTag = equalByTag$1;

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush$1(array, values) {
    var index = -1,
      length = values.length,
      offset = array.length;
    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }
  var _arrayPush = arrayPush$1;

  var arrayPush = _arrayPush,
    isArray$7 = isArray_1;

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys$1(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray$7(object) ? result : arrayPush(result, symbolsFunc(object));
  }
  var _baseGetAllKeys = baseGetAllKeys$1;

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter$1(array, predicate) {
    var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];
    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }
  var _arrayFilter = arrayFilter$1;

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray$1() {
    return [];
  }
  var stubArray_1 = stubArray$1;

  var arrayFilter = _arrayFilter,
    stubArray = stubArray_1;

  /** Used for built-in method references. */
  var objectProto$6 = Object.prototype;

  /** Built-in value references. */
  var propertyIsEnumerable$1 = objectProto$6.propertyIsEnumerable;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols;

  /**
   * Creates an array of the own enumerable symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols$1 = !nativeGetSymbols ? stubArray : function (object) {
    if (object == null) {
      return [];
    }
    object = Object(object);
    return arrayFilter(nativeGetSymbols(object), function (symbol) {
      return propertyIsEnumerable$1.call(object, symbol);
    });
  };
  var _getSymbols = getSymbols$1;

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes$1(n, iteratee) {
    var index = -1,
      result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  var _baseTimes = baseTimes$1;

  var baseGetTag$2 = _baseGetTag,
    isObjectLike$3 = isObjectLike_1;

  /** `Object#toString` result references. */
  var argsTag$2 = '[object Arguments]';

  /**
   * The base implementation of `_.isArguments`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   */
  function baseIsArguments$1(value) {
    return isObjectLike$3(value) && baseGetTag$2(value) == argsTag$2;
  }
  var _baseIsArguments = baseIsArguments$1;

  var baseIsArguments = _baseIsArguments,
    isObjectLike$2 = isObjectLike_1;

  /** Used for built-in method references. */
  var objectProto$5 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$4 = objectProto$5.hasOwnProperty;

  /** Built-in value references. */
  var propertyIsEnumerable = objectProto$5.propertyIsEnumerable;

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  var isArguments$2 = baseIsArguments(function () {
    return arguments;
  }()) ? baseIsArguments : function (value) {
    return isObjectLike$2(value) && hasOwnProperty$4.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
  };
  var isArguments_1 = isArguments$2;

  var isBuffer$2 = {exports: {}};

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }
  var stubFalse_1 = stubFalse;

  (function (module, exports) {
    var root = _root,
      stubFalse = stubFalse_1;

    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Built-in value references. */
    var Buffer = moduleExports ? root.Buffer : undefined;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;
    module.exports = isBuffer;
  })(isBuffer$2, isBuffer$2.exports);

  var MAX_SAFE_INTEGER = 9007199254740991;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex$2(value, length) {
    var type = _typeof$1(value);
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
  }
  var _isIndex = isIndex$2;

  var baseGetTag$1 = _baseGetTag,
    isLength$1 = isLength_1,
    isObjectLike$1 = isObjectLike_1;

  /** `Object#toString` result references. */
  var argsTag$1 = '[object Arguments]',
    arrayTag$1 = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag$1 = '[object Map]',
    numberTag = '[object Number]',
    objectTag$2 = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag$1 = '[object Set]',
    stringTag = '[object String]',
    weakMapTag$1 = '[object WeakMap]';
  var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag$1 = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;

  /**
   * The base implementation of `_.isTypedArray` without Node.js optimizations.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   */
  function baseIsTypedArray$1(value) {
    return isObjectLike$1(value) && isLength$1(value.length) && !!typedArrayTags[baseGetTag$1(value)];
  }
  var _baseIsTypedArray = baseIsTypedArray$1;

  var _nodeUtil = {exports: {}};

  (function (module, exports) {
    var freeGlobal = _freeGlobal;

    /** Detect free variable `exports`. */
    var freeExports = exports && !exports.nodeType && exports;

    /** Detect free variable `module`. */
    var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

    /** Detect the popular CommonJS extension `module.exports`. */
    var moduleExports = freeModule && freeModule.exports === freeExports;

    /** Detect free variable `process` from Node.js. */
    var freeProcess = moduleExports && freeGlobal.process;

    /** Used to access faster Node.js helpers. */
    var nodeUtil = function () {
      try {
        // Use `util.types` for Node.js 10+.
        var types = freeModule && freeModule.require && freeModule.require('util').types;
        if (types) {
          return types;
        }

        // Legacy `process.binding('util')` for Node.js < 10.
        return freeProcess && freeProcess.binding && freeProcess.binding('util');
      } catch (e) {}
    }();
    module.exports = nodeUtil;
  })(_nodeUtil, _nodeUtil.exports);

  var baseIsTypedArray = _baseIsTypedArray,
    baseUnary = _baseUnary,
    nodeUtil = _nodeUtil.exports;

  /* Node.js helper references. */
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @since 3.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  var isTypedArray$2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  var isTypedArray_1 = isTypedArray$2;

  var baseTimes = _baseTimes,
    isArguments$1 = isArguments_1,
    isArray$6 = isArray_1,
    isBuffer$1 = isBuffer$2.exports,
    isIndex$1 = _isIndex,
    isTypedArray$1 = isTypedArray_1;

  /** Used for built-in method references. */
  var objectProto$4 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$3 = objectProto$4.hasOwnProperty;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys$1(value, inherited) {
    var isArr = isArray$6(value),
      isArg = !isArr && isArguments$1(value),
      isBuff = !isArr && !isArg && isBuffer$1(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray$1(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty$3.call(value, key)) && !(skipIndexes && (
      // Safari 9 has enumerable `arguments.length` in strict mode.
      key == 'length' ||
      // Node.js 0.10 has enumerable non-index properties on buffers.
      isBuff && (key == 'offset' || key == 'parent') ||
      // PhantomJS 2 has enumerable non-index properties on typed arrays.
      isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
      // Skip index properties.
      isIndex$1(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  var _arrayLikeKeys = arrayLikeKeys$1;

  /** Used for built-in method references. */
  var objectProto$3 = Object.prototype;

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype$1(value) {
    var Ctor = value && value.constructor,
      proto = typeof Ctor == 'function' && Ctor.prototype || objectProto$3;
    return value === proto;
  }
  var _isPrototype = isPrototype$1;

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg$1(func, transform) {
    return function (arg) {
      return func(transform(arg));
    };
  }
  var _overArg = overArg$1;

  var overArg = _overArg;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeKeys$1 = overArg(Object.keys, Object);
  var _nativeKeys = nativeKeys$1;

  var isPrototype = _isPrototype,
    nativeKeys = _nativeKeys;

  /** Used for built-in method references. */
  var objectProto$2 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$2 = objectProto$2.hasOwnProperty;

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys$1(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty$2.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }
  var _baseKeys = baseKeys$1;

  var arrayLikeKeys = _arrayLikeKeys,
    baseKeys = _baseKeys,
    isArrayLike = isArrayLike_1;

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys$2(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  var keys_1 = keys$2;

  var baseGetAllKeys = _baseGetAllKeys,
    getSymbols = _getSymbols,
    keys$1 = keys_1;

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys$1(object) {
    return baseGetAllKeys(object, keys$1, getSymbols);
  }
  var _getAllKeys = getAllKeys$1;

  var getAllKeys = _getAllKeys;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$3 = 1;

  /** Used for built-in method references. */
  var objectProto$1 = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty$1 = objectProto$1.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} stack Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects$1(object, other, bitmask, customizer, equalFunc, stack) {
    var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
        return false;
      }
    }
    // Check that cyclic values are equal.
    var objStacked = stack.get(object);
    var othStacked = stack.get(other);
    if (objStacked && othStacked) {
      return objStacked == other && othStacked == object;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key],
        othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      // Recursively compare objects (susceptible to call stack limits).
      if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == 'constructor');
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor,
        othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack['delete'](object);
    stack['delete'](other);
    return result;
  }
  var _equalObjects = equalObjects$1;

  var getNative$3 = _getNative,
    root$3 = _root;

  /* Built-in method references that are verified to be native. */
  var DataView$1 = getNative$3(root$3, 'DataView');
  var _DataView = DataView$1;

  var getNative$2 = _getNative,
    root$2 = _root;

  /* Built-in method references that are verified to be native. */
  var Promise$2 = getNative$2(root$2, 'Promise');
  var _Promise = Promise$2;

  var getNative$1 = _getNative,
    root$1 = _root;

  /* Built-in method references that are verified to be native. */
  var Set$2 = getNative$1(root$1, 'Set');
  var _Set = Set$2;

  var getNative = _getNative,
    root = _root;

  /* Built-in method references that are verified to be native. */
  var WeakMap$1 = getNative(root, 'WeakMap');
  var _WeakMap = WeakMap$1;

  var DataView = _DataView,
    Map = _Map,
    Promise$1 = _Promise,
    Set$1 = _Set,
    WeakMap = _WeakMap,
    baseGetTag = _baseGetTag,
    toSource = _toSource;

  /** `Object#toString` result references. */
  var mapTag = '[object Map]',
    objectTag$1 = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';
  var dataViewTag = '[object DataView]';

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise$1),
    setCtorString = toSource(Set$1),
    weakMapCtorString = toSource(WeakMap);

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag$1 = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  if (DataView && getTag$1(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag$1(new Map()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$1 && getTag$1(new Set$1()) != setTag || WeakMap && getTag$1(new WeakMap()) != weakMapTag) {
    getTag$1 = function getTag(value) {
      var result = baseGetTag(value),
        Ctor = result == objectTag$1 ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  var _getTag = getTag$1;

  var Stack$1 = _Stack,
    equalArrays = _equalArrays,
    equalByTag = _equalByTag,
    equalObjects = _equalObjects,
    getTag = _getTag,
    isArray$5 = isArray_1,
    isBuffer = isBuffer$2.exports,
    isTypedArray = isTypedArray_1;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$2 = 1;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

  /** Used for built-in method references. */
  var objectProto = Object.prototype;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
   * @param {Function} customizer The function to customize comparisons.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Object} [stack] Tracks traversed `object` and `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep$1(object, other, bitmask, customizer, equalFunc, stack) {
    var objIsArr = isArray$5(object),
      othIsArr = isArray$5(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);
    objTag = objTag == argsTag ? objectTag : objTag;
    othTag = othTag == argsTag ? objectTag : othTag;
    var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;
    if (isSameTag && isBuffer(object)) {
      if (!isBuffer(other)) {
        return false;
      }
      objIsArr = true;
      objIsObj = false;
    }
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack$1());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
    }
    if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack$1());
        return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack$1());
    return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  }
  var _baseIsEqualDeep = baseIsEqualDeep$1;

  var baseIsEqualDeep = _baseIsEqualDeep,
    isObjectLike = isObjectLike_1;

  /**
   * The base implementation of `_.isEqual` which supports partial comparisons
   * and tracks traversed objects.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {boolean} bitmask The bitmask flags.
   *  1 - Unordered comparison
   *  2 - Partial comparison
   * @param {Function} [customizer] The function to customize comparisons.
   * @param {Object} [stack] Tracks traversed `value` and `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual$2(value, other, bitmask, customizer, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$2, stack);
  }
  var _baseIsEqual = baseIsEqual$2;

  var Stack = _Stack,
    baseIsEqual$1 = _baseIsEqual;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG$1 = 1,
    COMPARE_UNORDERED_FLAG$1 = 2;

  /**
   * The base implementation of `_.isMatch` without support for iteratee shorthands.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Object} source The object of property values to match.
   * @param {Array} matchData The property names, values, and compare flags to match.
   * @param {Function} [customizer] The function to customize comparisons.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch$1(object, source, matchData, customizer) {
    var index = matchData.length,
      length = index,
      noCustomizer = !customizer;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0],
        objValue = object[key],
        srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === undefined && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === undefined ? baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  var _baseIsMatch = baseIsMatch$1;

  var isObject$1 = isObject_1;

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable$2(value) {
    return value === value && !isObject$1(value);
  }
  var _isStrictComparable = isStrictComparable$2;

  var isStrictComparable$1 = _isStrictComparable,
    keys = keys_1;

  /**
   * Gets the property names, values, and compare flags of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the match data of `object`.
   */
  function getMatchData$1(object) {
    var result = keys(object),
      length = result.length;
    while (length--) {
      var key = result[length],
        value = object[key];
      result[length] = [key, value, isStrictComparable$1(value)];
    }
    return result;
  }
  var _getMatchData = getMatchData$1;

  /**
   * A specialized version of `matchesProperty` for source values suitable
   * for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function matchesStrictComparable$2(key, srcValue) {
    return function (object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
    };
  }
  var _matchesStrictComparable = matchesStrictComparable$2;

  var baseIsMatch = _baseIsMatch,
    getMatchData = _getMatchData,
    matchesStrictComparable$1 = _matchesStrictComparable;

  /**
   * The base implementation of `_.matches` which doesn't clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatches$1(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
    }
    return function (object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  var _baseMatches = baseMatches$1;

  var isArray$4 = isArray_1,
    isSymbol$2 = isSymbol_1;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

  /**
   * Checks if `value` is a property name and not a property path.
   *
   * @private
   * @param {*} value The value to check.
   * @param {Object} [object] The object to query keys on.
   * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
   */
  function isKey$3(value, object) {
    if (isArray$4(value)) {
      return false;
    }
    var type = _typeof$1(value);
    if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol$2(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  var _isKey = isKey$3;

  var MapCache = _MapCache;

  /** Error message constants. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided, it determines the cache key for storing the result based on the
   * arguments provided to the memoized function. By default, the first argument
   * provided to the memoized function is used as the map cache key. The `func`
   * is invoked with the `this` binding of the memoized function.
   *
   * **Note:** The cache is exposed as the `cache` property on the memoized
   * function. Its creation may be customized by replacing the `_.memoize.Cache`
   * constructor with one whose instances implement the
   * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
   * method interface of `clear`, `delete`, `get`, `has`, and `set`.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Function
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] The function to resolve the cache key.
   * @returns {Function} Returns the new memoized function.
   * @example
   *
   * var object = { 'a': 1, 'b': 2 };
   * var other = { 'c': 3, 'd': 4 };
   *
   * var values = _.memoize(_.values);
   * values(object);
   * // => [1, 2]
   *
   * values(other);
   * // => [3, 4]
   *
   * object.a = 2;
   * values(object);
   * // => [1, 2]
   *
   * // Modify the result cache.
   * values.cache.set(object, ['a', 'b']);
   * values(object);
   * // => ['a', 'b']
   *
   * // Replace `_.memoize.Cache`.
   * _.memoize.Cache = WeakMap;
   */
  function memoize$1(func, resolver) {
    if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function memoized() {
      var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result) || cache;
      return result;
    };
    memoized.cache = new (memoize$1.Cache || MapCache)();
    return memoized;
  }

  // Expose `MapCache`.
  memoize$1.Cache = MapCache;
  var memoize_1 = memoize$1;

  var memoize = memoize_1;

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /**
   * A specialized version of `_.memoize` which clears the memoized function's
   * cache when it exceeds `MAX_MEMOIZE_SIZE`.
   *
   * @private
   * @param {Function} func The function to have its output memoized.
   * @returns {Function} Returns the new memoized function.
   */
  function memoizeCapped$1(func) {
    var result = memoize(func, function (key) {
      if (cache.size === MAX_MEMOIZE_SIZE) {
        cache.clear();
      }
      return key;
    });
    var cache = result.cache;
    return result;
  }
  var _memoizeCapped = memoizeCapped$1;

  var memoizeCapped = _memoizeCapped;

  /** Used to match property names within property paths. */
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Converts `string` to a property path array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the property path array.
   */
  var stringToPath$1 = memoizeCapped(function (string) {
    var result = [];
    if (string.charCodeAt(0) === 46 /* . */) {
      result.push('');
    }
    string.replace(rePropName, function (match, number, quote, subString) {
      result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
    });
    return result;
  });
  var _stringToPath = stringToPath$1;

  var isArray$3 = isArray_1,
    isKey$2 = _isKey,
    stringToPath = _stringToPath,
    toString = toString_1;

  /**
   * Casts `value` to a path array if it's not one.
   *
   * @private
   * @param {*} value The value to inspect.
   * @param {Object} [object] The object to query keys on.
   * @returns {Array} Returns the cast property path array.
   */
  function castPath$2(value, object) {
    if (isArray$3(value)) {
      return value;
    }
    return isKey$2(value, object) ? [value] : stringToPath(toString(value));
  }
  var _castPath = castPath$2;

  var isSymbol$1 = isSymbol_1;

  /** Used as references for various `Number` constants. */
  var INFINITY$1 = 1 / 0;

  /**
   * Converts `value` to a string key if it's not a string or symbol.
   *
   * @private
   * @param {*} value The value to inspect.
   * @returns {string|symbol} Returns the key.
   */
  function toKey$4(value) {
    if (typeof value == 'string' || isSymbol$1(value)) {
      return value;
    }
    var result = value + '';
    return result == '0' && 1 / value == -INFINITY$1 ? '-0' : result;
  }
  var _toKey = toKey$4;

  var castPath$1 = _castPath,
    toKey$3 = _toKey;

  /**
   * The base implementation of `_.get` without support for default values.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @returns {*} Returns the resolved value.
   */
  function baseGet$2(object, path) {
    path = castPath$1(path, object);
    var index = 0,
      length = path.length;
    while (object != null && index < length) {
      object = object[toKey$3(path[index++])];
    }
    return index && index == length ? object : undefined;
  }
  var _baseGet = baseGet$2;

  var baseGet$1 = _baseGet;

  /**
   * Gets the value at `path` of `object`. If the resolved value is
   * `undefined`, the `defaultValue` is returned in its place.
   *
   * @static
   * @memberOf _
   * @since 3.7.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path of the property to get.
   * @param {*} [defaultValue] The value returned for `undefined` resolved values.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = { 'a': [{ 'b': { 'c': 3 } }] };
   *
   * _.get(object, 'a[0].b.c');
   * // => 3
   *
   * _.get(object, ['a', '0', 'b', 'c']);
   * // => 3
   *
   * _.get(object, 'a.b.c', 'default');
   * // => 'default'
   */
  function get$1(object, path, defaultValue) {
    var result = object == null ? undefined : baseGet$1(object, path);
    return result === undefined ? defaultValue : result;
  }
  var get_1 = get$1;

  /**
   * The base implementation of `_.hasIn` without support for deep paths.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {Array|string} key The key to check.
   * @returns {boolean} Returns `true` if `key` exists, else `false`.
   */
  function baseHasIn$1(object, key) {
    return object != null && key in Object(object);
  }
  var _baseHasIn = baseHasIn$1;

  var castPath = _castPath,
    isArguments = isArguments_1,
    isArray$2 = isArray_1,
    isIndex = _isIndex,
    isLength = isLength_1,
    toKey$2 = _toKey;

  /**
   * Checks if `path` exists on `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @param {Function} hasFunc The function to check properties.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   */
  function hasPath$1(object, path, hasFunc) {
    path = castPath(path, object);
    var index = -1,
      length = path.length,
      result = false;
    while (++index < length) {
      var key = toKey$2(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result || ++index != length) {
      return result;
    }
    length = object == null ? 0 : object.length;
    return !!length && isLength(length) && isIndex(key, length) && (isArray$2(object) || isArguments(object));
  }
  var _hasPath = hasPath$1;

  var baseHasIn = _baseHasIn,
    hasPath = _hasPath;

  /**
   * Checks if `path` is a direct or inherited property of `object`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Object
   * @param {Object} object The object to query.
   * @param {Array|string} path The path to check.
   * @returns {boolean} Returns `true` if `path` exists, else `false`.
   * @example
   *
   * var object = _.create({ 'a': _.create({ 'b': 2 }) });
   *
   * _.hasIn(object, 'a');
   * // => true
   *
   * _.hasIn(object, 'a.b');
   * // => true
   *
   * _.hasIn(object, ['a', 'b']);
   * // => true
   *
   * _.hasIn(object, 'b');
   * // => false
   */
  function hasIn$1(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  var hasIn_1 = hasIn$1;

  var baseIsEqual = _baseIsEqual,
    get = get_1,
    hasIn = hasIn_1,
    isKey$1 = _isKey,
    isStrictComparable = _isStrictComparable,
    matchesStrictComparable = _matchesStrictComparable,
    toKey$1 = _toKey;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

  /**
   * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
   *
   * @private
   * @param {string} path The path of the property to get.
   * @param {*} srcValue The value to match.
   * @returns {Function} Returns the new spec function.
   */
  function baseMatchesProperty$1(path, srcValue) {
    if (isKey$1(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey$1(path), srcValue);
    }
    return function (object) {
      var objValue = get(object, path);
      return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
    };
  }
  var _baseMatchesProperty = baseMatchesProperty$1;

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty$1(key) {
    return function (object) {
      return object == null ? undefined : object[key];
    };
  }
  var _baseProperty = baseProperty$1;

  var baseGet = _baseGet;

  /**
   * A specialized version of `baseProperty` which supports deep paths.
   *
   * @private
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyDeep$1(path) {
    return function (object) {
      return baseGet(object, path);
    };
  }
  var _basePropertyDeep = basePropertyDeep$1;

  var baseProperty = _baseProperty,
    basePropertyDeep = _basePropertyDeep,
    isKey = _isKey,
    toKey = _toKey;

  /**
   * Creates a function that returns the value at `path` of a given object.
   *
   * @static
   * @memberOf _
   * @since 2.4.0
   * @category Util
   * @param {Array|string} path The path of the property to get.
   * @returns {Function} Returns the new accessor function.
   * @example
   *
   * var objects = [
   *   { 'a': { 'b': 2 } },
   *   { 'a': { 'b': 1 } }
   * ];
   *
   * _.map(objects, _.property('a.b'));
   * // => [2, 1]
   *
   * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
   * // => [1, 2]
   */
  function property$1(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  var property_1 = property$1;

  var baseMatches = _baseMatches,
    baseMatchesProperty = _baseMatchesProperty,
    identity = identity_1,
    isArray$1 = isArray_1,
    property = property_1;

  /**
   * The base implementation of `_.iteratee`.
   *
   * @private
   * @param {*} [value=_.identity] The value to convert to an iteratee.
   * @returns {Function} Returns the iteratee.
   */
  function baseIteratee$1(value) {
    // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
    // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
    if (typeof value == 'function') {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (_typeof$1(value) == 'object') {
      return isArray$1(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  var _baseIteratee = baseIteratee$1;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex$1(string) {
    var index = string.length;
    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }
  var _trimmedEndIndex = trimmedEndIndex$1;

  var trimmedEndIndex = _trimmedEndIndex;

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim$1(string) {
    return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
  }
  var _baseTrim = baseTrim$1;

  var baseTrim = _baseTrim,
    isObject = isObject_1,
    isSymbol = isSymbol_1;

  /** Used as references for various `Number` constants. */
  var NAN = 0 / 0;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Built-in method references without a dependency on `root`. */
  var freeParseInt = parseInt;

  /**
   * Converts `value` to a number.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to process.
   * @returns {number} Returns the number.
   * @example
   *
   * _.toNumber(3.2);
   * // => 3.2
   *
   * _.toNumber(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toNumber(Infinity);
   * // => Infinity
   *
   * _.toNumber('3.2');
   * // => 3.2
   */
  function toNumber$1(value) {
    if (typeof value == 'number') {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
      value = isObject(other) ? other + '' : other;
    }
    if (typeof value != 'string') {
      return value === 0 ? value : +value;
    }
    value = baseTrim(value);
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  var toNumber_1 = toNumber$1;

  var toNumber = toNumber_1;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

  /**
   * Converts `value` to a finite number.
   *
   * @static
   * @memberOf _
   * @since 4.12.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted number.
   * @example
   *
   * _.toFinite(3.2);
   * // => 3.2
   *
   * _.toFinite(Number.MIN_VALUE);
   * // => 5e-324
   *
   * _.toFinite(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toFinite('3.2');
   * // => 3.2
   */
  function toFinite$1(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  var toFinite_1 = toFinite$1;

  var toFinite = toFinite_1;

  /**
   * Converts `value` to an integer.
   *
   * **Note:** This method is loosely based on
   * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to convert.
   * @returns {number} Returns the converted integer.
   * @example
   *
   * _.toInteger(3.2);
   * // => 3
   *
   * _.toInteger(Number.MIN_VALUE);
   * // => 0
   *
   * _.toInteger(Infinity);
   * // => 1.7976931348623157e+308
   *
   * _.toInteger('3.2');
   * // => 3
   */
  function toInteger$1(value) {
    var result = toFinite(value),
      remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  var toInteger_1 = toInteger$1;

  var baseFindIndex = _baseFindIndex,
    baseIteratee = _baseIteratee,
    toInteger = toInteger_1;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeMax = Math.max;

  /**
   * This method is like `_.find` except that it returns the index of the first
   * element `predicate` returns truthy for instead of the element itself.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {Function} [predicate=_.identity] The function invoked per iteration.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the found element, else `-1`.
   * @example
   *
   * var users = [
   *   { 'user': 'barney',  'active': false },
   *   { 'user': 'fred',    'active': false },
   *   { 'user': 'pebbles', 'active': true }
   * ];
   *
   * _.findIndex(users, function(o) { return o.user == 'barney'; });
   * // => 0
   *
   * // The `_.matches` iteratee shorthand.
   * _.findIndex(users, { 'user': 'fred', 'active': false });
   * // => 1
   *
   * // The `_.matchesProperty` iteratee shorthand.
   * _.findIndex(users, ['active', false]);
   * // => 0
   *
   * // The `_.property` iteratee shorthand.
   * _.findIndex(users, 'active');
   * // => 2
   */
  function findIndex(array, predicate, fromIndex) {
    var length = array == null ? 0 : array.length;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
      index = nativeMax(length + index, 0);
    }
    return baseFindIndex(array, baseIteratee(predicate), index);
  }
  var findIndex_1 = findIndex;

  function getCurrentDate() {
    var needTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    var d = new Date();
    var month = d.getMonth() + 1;
    month = month < 10 ? "0".concat(month) : month;
    var date = "".concat(d.getFullYear(), "-").concat(month, "-").concat(d.getDate());
    var time = "".concat(d.getHours(), ":").concat(d.getMinutes(), ":").concat(d.getSeconds());
    if (needTime) return [date, time].join(" ");
    return date;
  }

  function ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$4(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  function xhr(_ref) {
    var _files$;
    var _ref$method = _ref.method,
      method = _ref$method === void 0 ? "POST" : _ref$method,
      action = _ref.action,
      _ref$withCredentials = _ref.withCredentials,
      withCredentials = _ref$withCredentials === void 0 ? false : _ref$withCredentials,
      _ref$headers = _ref.headers,
      headers = _ref$headers === void 0 ? {} : _ref$headers,
      _ref$data = _ref.data,
      data = _ref$data === void 0 ? {} : _ref$data,
      file = _ref.file,
      _ref$files = _ref.files,
      files = _ref$files === void 0 ? [] : _ref$files,
      _ref$name = _ref.name,
      name = _ref$name === void 0 ? "file" : _ref$name,
      _ref$useMockProgress = _ref.useMockProgress,
      useMockProgress = _ref$useMockProgress === void 0 ? true : _ref$useMockProgress,
      formatRequest = _ref.formatRequest,
      onError = _ref.onError,
      onProgress = _ref.onProgress,
      onSuccess = _ref.onSuccess;
    var innerFiles = files || [];
    var percent = 0;
    var xhr2 = new XMLHttpRequest();
    if (withCredentials) {
      xhr2.withCredentials = true;
    }
    var timer1;
    var timer2;
    if (useMockProgress && ((_files$ = files[0]) === null || _files$ === void 0 ? void 0 : _files$.status) === "progress") {
      var timer22 = setTimeout(function () {
        timer1 = setInterval(function () {
          if (percent + 10 < 100) {
            percent = Math.max(percent + 10, percent);
            if (files[0] && percent !== files[0].percent) {
              files[0].percent = percent;
              onProgress({
                percent: percent,
                file: file || innerFiles[0],
                files: innerFiles.map(function (file2) {
                  return _objectSpread$4(_objectSpread$4({}, file2), {}, {
                    percent: percent
                  });
                }),
                type: "mock"
              });
            }
          } else {
            clearInterval(timer1);
          }
        }, 300);
        clearTimeout(timer22);
      }, 300);
    }
    var requestData = {};
    if (data) {
      var extraData = typeof data === "function" ? data(file) : data;
      Object.assign(requestData, extraData);
    }
    innerFiles.forEach(function (file2, index) {
      var fileField = innerFiles.length > 1 ? "".concat(name, "[").concat(index, "]") : name;
      requestData[fileField] = file2.raw;
      requestData[name] = file2.raw;
    });
    if (formatRequest) {
      requestData = formatRequest(requestData);
    }
    var formData = new FormData();
    Object.keys(requestData).forEach(function (key) {
      formData.append(key, requestData[key]);
    });
    xhr2.open(method, action, true);
    Object.keys(headers).forEach(function (key) {
      xhr2.setRequestHeader(key, headers[key]);
    });
    xhr2.onerror = function (event) {
      onError({
        event: event,
        file: file,
        files: innerFiles
      });
      clearInterval(timer1);
      clearTimeout(timer2);
    };
    if (xhr2.upload) {
      xhr2.upload.onprogress = function (event) {
        var _innerFiles$;
        var realPercent = 0;
        if (event.total > 0) {
          realPercent = Math.round(event.loaded / event.total * 100);
        }
        percent = Math.max(realPercent, percent);
        if (percent !== realPercent && ((_innerFiles$ = innerFiles[0]) === null || _innerFiles$ === void 0 ? void 0 : _innerFiles$.percent) !== percent) {
          var progressFiles = innerFiles.map(function (item) {
            return _objectSpread$4(_objectSpread$4({}, item), {}, {
              percent: percent
            });
          });
          onProgress({
            event: event,
            percent: percent,
            file: file || progressFiles[0],
            files: progressFiles,
            type: "real"
          });
        }
      };
    }
    xhr2.onload = function (event) {
      var response = {};
      var isFail = xhr2.status < 200 || xhr2.status >= 300;
      if (isFail) {
        return onError({
          event: event,
          file: file,
          files: innerFiles,
          response: response
        });
      }
      var text = xhr2.responseText || xhr2.response;
      try {
        response = JSON.parse(text);
      } catch (e) {
        response = text;
      }
      clearInterval(timer1);
      clearTimeout(timer2);
      innerFiles.forEach(function (file2) {
        var _response;
        file2.percent = 100;
        file2.status = "success";
        file2.uploadTime = ((_response = response) === null || _response === void 0 ? void 0 : _response.uploadTime) || getCurrentDate();
      });
      onSuccess({
        event: event,
        file: file || innerFiles[0],
        files: _toConsumableArray(innerFiles),
        response: response
      });
    };
    xhr2.send(formData);
    return xhr2;
  }

  var UploadProps = {
    accept: {
      type: String,
      default: ""
    },
    action: {
      type: String,
      default: ""
    },
    allowUploadDuplicateFile: Boolean,
    autoUpload: {
      type: Boolean,
      default: true
    },
    beforeUpload: {
      type: Function
    },
    data: {
      type: Object
    },
    deleteBtn: {
      type: [String, Function]
    },
    disabled: Boolean,
    fileListDisplay: {
      type: Function
    },
    files: {
      type: Array
    },
    modelValue: {
      type: Array,
      default: void 0
    },
    defaultFiles: {
      type: Array
    },
    format: {
      type: Function
    },
    formatResponse: {
      type: Function
    },
    gridConfig: {
      type: Object
    },
    headers: {
      type: Object
    },
    imageProps: {
      type: Object
    },
    max: {
      type: Number,
      default: 0
    },
    method: {
      type: String,
      default: "POST",
      validator: function validator(val) {
        if (!val) return true;
        return ["POST", "GET", "PUT", "OPTION", "PATCH", "post", "get", "put", "option", "patch"].includes(val);
      }
    },
    multiple: Boolean,
    requestMethod: {
      type: Function
    },
    sizeLimit: {
      type: [Number, Object]
    },
    trigger: {
      type: [String, Function]
    },
    useMockProgress: {
      type: Boolean,
      default: true
    },
    withCredentials: Boolean,
    onCancelUpload: Function,
    onChange: Function,
    onFail: Function,
    onPreview: Function,
    onProgress: Function,
    onRemove: Function,
    onSelectChange: Function,
    onSuccess: Function
  };

  var SIZE_MAP = {
    B: 1024,
    KB: 1,
    MB: 1048576,
    GB: 1073741824
  };
  function isOverSizeLimit(fileSize, sizeLimit, unit) {
    var units = ["B", "KB", "MB", "GB"];
    var KB_INDEX = 1;
    var index = units.indexOf(unit);
    if (index === -1) {
      console.warn("TDesign Upload Warn: `sizeLimit.unit` can only be one of ".concat(units.join()));
      index = KB_INDEX;
    }
    var num = SIZE_MAP[unit];
    var limit = index < KB_INDEX ? sizeLimit / num : sizeLimit * num;
    return fileSize <= limit;
  }

  function ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$4 = config.prefix;
  var name$4 = "".concat(prefix$4, "-upload");
  var isArray = Array.isArray;
  var script$5 = vue.defineComponent({
    name: name$4,
    components: {
      AddIcon: add,
      TNode: TNodeComponent,
      CloseIcon: close,
      RefreshIcon: refresh,
      TImageViewer: _ImageViewer
    },
    props: UploadProps,
    emits: ["update:files", "update:modelValue", "change", "fail", "preview", "progress", "remove", "success", "select-change"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var _useDefault = useDefault(props, context.emit, "files", "change"),
        _useDefault2 = _slicedToArray(_useDefault, 2),
        innerFiles = _useDefault2[0],
        setInnerFiles = _useDefault2[1];
      var internalInstance = vue.getCurrentInstance();
      var defaultContent = vue.computed(function () {
        return renderTNode(internalInstance, "default");
      });
      var deleteBtnContent = vue.computed(function () {
        return renderTNode(internalInstance, "deleteBtn");
      });
      var images = vue.ref([]);
      var showViewer = vue.ref(false);
      var initialIndex = vue.ref(0);
      var UPLOAD_NAME = name$4;
      var xhrReq = vue.ref(null);
      var toUploadFiles = vue.ref([]);
      var uploadedFiles = vue.computed(function () {
        if (innerFiles.value && isArray(innerFiles.value)) {
          return innerFiles.value;
        }
        return [];
      });
      var errorMsg = vue.ref("");
      var inputRef = vue.ref(null);
      var itemStyle = vue.computed(function () {
        var _toRefs = vue.toRefs(props),
          gridConfig = _toRefs.gridConfig;
        var column = 4;
        if (isObject$5(gridConfig.value)) {
          column = gridConfig.value.column;
        }
        return {
          flexBasis: "".concat(100 / +column, "%")
        };
      });
      var itemContentStyle = vue.computed(function () {
        var width = 80;
        var height = 80;
        var _toRefs2 = vue.toRefs(props),
          gridConfig = _toRefs2.gridConfig;
        if (isObject$5(gridConfig.value)) {
          var _gridConfig$value = gridConfig.value;
          width = _gridConfig$value.width;
          height = _gridConfig$value.height;
        }
        return {
          height: "".concat(height, "px"),
          width: "".concat(width, "px")
        };
      });
      var triggerUpload = function triggerUpload() {
        var input = inputRef.value;
        if (props.disabled) return;
        input.click();
      };
      var handlePreview = function handlePreview(e, file) {
        showViewer.value = true;
        emitEvent("preview", {
          e: e,
          file: file
        });
      };
      var handleReload = function handleReload(file) {
        uploadFiles([file.fileRaw]);
      };
      var handleChange = function handleChange() {
        var input = inputRef.value;
        if (props.disabled || !input || !input.files) return;
        var formatFiles = formatFileToUploadFile(input.files);
        emitEvent("select-change", _toConsumableArray(formatFiles));
        uploadFiles(formatFiles);
        input.value = "";
      };
      var formatFileToUploadFile = function formatFileToUploadFile(files) {
        var format = props.format;
        if (!format || !isFunction$3(format)) {
          var res = [];
          for (var i = 0; i < files.length; i++) {
            res.push(files[i]);
          }
          return res;
        }
        var NewFiles = _toConsumableArray(files);
        NewFiles.forEach(function (item) {
          item = format(item);
        });
        return NewFiles;
      };
      var handleBeforeUpload = function handleBeforeUpload(file) {
        if (props.beforeUpload && isFunction$3(props.beforeUpload)) {
          var beforeUpload = props.beforeUpload(file);
          if (beforeUpload instanceof Promise) return beforeUpload;
          return Promise.resolve(beforeUpload);
        }
        return new Promise(function (resolve) {
          if (props.sizeLimit) {
            resolve(handleSizeLimit(file.size));
          }
          resolve(true);
        });
      };
      var handleSizeLimit = function handleSizeLimit(fileSize) {
        var sizeLimit;
        if (typeof props.sizeLimit === "number") {
          sizeLimit = {
            size: props.sizeLimit,
            unit: "KB"
          };
        } else if (_typeof$1(props.sizeLimit) === "object") {
          sizeLimit = props.sizeLimit;
        } else {
          sizeLimit = {
            size: 0,
            unit: "KB"
          };
        }
        var isOverSize = isOverSizeLimit(fileSize, sizeLimit.size, sizeLimit.unit);
        if (isOverSize) {
          errorMsg.value = sizeLimit.message ? sizeLimit.message : "TDesign Upoad Error: uploaded picture exceeds ".concat(props.sizeLimit).concat(sizeLimit.unit, " restrictions");
        }
        return isOverSize;
      };
      var uploadFiles = function uploadFiles(files) {
        var _toRefs3 = vue.toRefs(props),
          max = _toRefs3.max;
        var tmpFiles = _toConsumableArray(files);
        if (max.value) {
          tmpFiles = tmpFiles.slice(0, max.value - uploadedFiles.value.length);
          if (tmpFiles.length !== files.length) {
            console.warn("TDesign Upload Warn: you can only upload ".concat(max.value, " files"));
          }
        }
        tmpFiles.forEach(function (fileRaw) {
          var uploadFile = _objectSpread$3(_objectSpread$3({}, fileRaw), {}, {
            fileRaw: fileRaw,
            lastModified: fileRaw.lastModified,
            name: fileRaw.name,
            size: fileRaw.size,
            type: fileRaw.type,
            percent: 0,
            status: "waiting"
          });
          var reader = new FileReader();
          reader.readAsDataURL(fileRaw);
          reader.onload = function (event) {
            var _event$target;
            uploadFile.url = (_event$target = event.target) === null || _event$target === void 0 ? void 0 : _event$target.result;
          };
          handleBeforeUpload(fileRaw).then(function (canUpload) {
            if (!canUpload) return;
            var newFiles = toUploadFiles.value.concat();
            if (props.allowUploadDuplicateFile || !toUploadFiles.value.find(function (file) {
              return file.name === uploadFile.name;
            })) {
              newFiles.push(uploadFile);
            }
            toUploadFiles.value = newFiles;
            if (props.autoUpload) {
              upload(uploadFile);
            }
          });
        });
      };
      var handleMockProgress = function handleMockProgress(file) {
        var timer = setInterval(function () {
          if (file.status === "success" || file.percent >= 99) {
            clearInterval(timer);
            return;
          }
          file.percent += 1;
          handleProgress({
            file: file,
            percent: file.percent,
            type: "mock"
          });
        }, 10);
      };
      var handleProgress = function handleProgress(_ref) {
        var event = _ref.event,
          file = _ref.file,
          percent = _ref.percent,
          _ref$type = _ref.type,
          type = _ref$type === void 0 ? "real" : _ref$type;
        if (!file) throw new Error("Error file");
        file.percent = Math.min(percent, 100);
        var progressCtx = {
          percent: percent,
          e: event,
          file: file,
          type: type
        };
        emitEvent("progress", progressCtx);
      };
      var handleRemove = function handleRemove(e, file, index) {
        errorMsg.value = "";
        var files = uploadedFiles.value.concat();
        files.splice(index, 1);
        setInnerFiles(files, {
          e: e,
          trigger: "remove",
          index: index,
          file: file
        });
        emitEvent("remove", {
          e: e,
          index: index,
          file: file
        });
        images.value.splice(index, 1);
      };
      var upload = /*#__PURE__*/function () {
        var _ref2 = _asyncToGenerator( /*#__PURE__*/regenerator.mark(function _callee(file) {
          var request;
          return regenerator.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!(!props.action && !props.requestMethod)) {
                    _context.next = 3;
                    break;
                  }
                  console.error("TDesign Upload Error: one of action and requestMethod must be exist.");
                  return _context.abrupt("return");
                case 3:
                  errorMsg.value = "";
                  file.status = "progress";
                  if (props.requestMethod) {
                    handleRequestMethod(file);
                  } else {
                    if (props.useMockProgress) {
                      handleMockProgress(file);
                    }
                    request = xhr;
                    xhrReq.value = request({
                      action: props.action,
                      data: _objectSpread$3({
                        file: file.fileRaw
                      }, props.data),
                      file: file,
                      method: props.method,
                      headers: props.headers || {},
                      withCredentials: props.withCredentials,
                      onError: handleError,
                      onProgress: handleProgress,
                      onSuccess: handleSuccess
                    });
                  }
                case 6:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));
        return function upload(_x) {
          return _ref2.apply(this, arguments);
        };
      }();
      var handleRequestMethod = function handleRequestMethod(file) {
        var _props$requestMethod;
        if (!isFunction$3(props.requestMethod)) {
          console.warn("TDesign Upload Warn: `requestMethod` must be a function.");
          return;
        }
        (_props$requestMethod = props.requestMethod) === null || _props$requestMethod === void 0 ? void 0 : _props$requestMethod.call(props, file).then(function (res) {
          if (!handleRequestMethodResponse(res)) return;
          if (res.status === "success") {
            handleSuccess({
              file: file,
              response: res.response
            });
          } else if (res.status === "fail") {
            var r = res.response || {};
            handleError({
              event: void 0,
              file: file,
              response: _objectSpread$3(_objectSpread$3({}, r), {}, {
                error: res.error
              })
            });
          }
        });
      };
      var handleRequestMethodResponse = function handleRequestMethodResponse(res) {
        if (!res) {
          console.error("TDesign Upoad Error: `requestMethodResponse` is required.");
          return false;
        }
        if (!res.status) {
          console.error("TDesign Upoad Error: `requestMethodResponse.status` is missing, which value is `success` or `fail`");
          return false;
        }
        if (!["success", "fail"].includes(res.status)) {
          console.error("TDesign Upoad Error: `requestMethodResponse.status` must be `success` or `fail`");
          return false;
        }
        if (res.status === "success" && (!res.response || !res.response.url)) {
          console.warn("TDesign Upoad Warn: `requestMethodResponse.response.url` is required, when `status` is `success`");
        }
        return true;
      };
      var handleSuccess = function handleSuccess(_ref3) {
        var _res, _res2;
        var event = _ref3.event,
          file = _ref3.file,
          response = _ref3.response;
        if (!file) throw new Error("Error file");
        file.status = "success";
        var res = response;
        if (props.formatResponse && isFunction$3(props.formatResponse)) {
          res = props.formatResponse(response, {
            file: file
          });
        }
        if ((_res = res) !== null && _res !== void 0 && _res.error) {
          handleError({
            event: event,
            file: file,
            response: res,
            resFormatted: true
          });
          return;
        }
        file.url = ((_res2 = res) === null || _res2 === void 0 ? void 0 : _res2.url) || file.url;
        var index = findIndex_1(toUploadFiles.value, function (o) {
          return o.name === file.name;
        });
        toUploadFiles.value.splice(index, 1);
        var newFile = _objectSpread$3(_objectSpread$3({}, file), {}, {
          response: res
        });
        var files = uploadedFiles.value.concat(newFile);
        setInnerFiles(files, {
          e: event,
          response: res,
          trigger: "upload-success"
        });
        emitEvent("success", {
          file: file,
          fileList: files,
          e: event,
          response: res
        });
        images.value.push(newFile.url);
      };
      var handleError = function handleError(options) {
        var _res3;
        var event = options.event,
          file = options.file,
          response = options.response,
          resFormatted = options.resFormatted;
        file.status = "fail";
        var res = response;
        if (!resFormatted && props.formatResponse && isFunction$3(props.formatResponse)) {
          res = props.formatResponse(response, {
            file: file
          });
        }
        errorMsg.value = (_res3 = res) === null || _res3 === void 0 ? void 0 : _res3.error;
        if (!uploadedFiles.value.find(function (item) {
          return item.name === file.name;
        })) {
          var files = uploadedFiles.value.concat(file);
          setInnerFiles(files, {
            e: event,
            response: res,
            trigger: "upload-fail"
          });
        }
        emitEvent("fail", {
          e: event,
          file: file
        });
      };
      return _objectSpread$3(_objectSpread$3({}, vue.toRefs(props)), {}, {
        UPLOAD_NAME: UPLOAD_NAME,
        images: images,
        showViewer: showViewer,
        initialIndex: initialIndex,
        prefix: prefix$4,
        innerFiles: innerFiles,
        xhrReq: xhrReq,
        toUploadFiles: toUploadFiles,
        errorMsg: errorMsg,
        inputRef: inputRef,
        uploadedFiles: uploadedFiles,
        deleteBtnContent: deleteBtnContent,
        defaultContent: defaultContent,
        itemStyle: itemStyle,
        itemContentStyle: itemContentStyle,
        emitEvent: emitEvent,
        setInnerFiles: setInnerFiles,
        triggerUpload: triggerUpload,
        handleChange: handleChange,
        handlePreview: handlePreview,
        handleReload: handleReload,
        handleBeforeUpload: handleBeforeUpload,
        handleSizeLimit: handleSizeLimit,
        uploadFiles: uploadFiles,
        handleMockProgress: handleMockProgress,
        handleProgress: handleProgress,
        handleRemove: handleRemove,
        upload: upload,
        handleRequestMethodResponse: handleRequestMethodResponse,
        handleSuccess: handleSuccess,
        handleError: handleError
      });
    }
  });

  var _hoisted_1$2 = ["onClick"];
  var _hoisted_2$1 = ["src", "onClick"];
  var _hoisted_3 = ["value", "multiple", "accept"];
  function render$4(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_close_icon = vue.resolveComponent("close-icon");
    var _component_refresh_icon = vue.resolveComponent("refresh-icon");
    var _component_add_icon = vue.resolveComponent("add-icon");
    var _component_t_image_viewer = vue.resolveComponent("t-image-viewer");
    return vue.openBlock(), vue.createElementBlock("div", null, [vue.createElementVNode("ul", {
      class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card"))
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.uploadedFiles, function (file, index) {
      return vue.openBlock(), vue.createElementBlock("li", {
        key: index,
        class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-item")),
        style: vue.normalizeStyle(_ctx.itemStyle)
      }, [vue.createElementVNode("div", {
        class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-content ").concat(_ctx.UPLOAD_NAME, "__card-box")),
        style: vue.normalizeStyle(_ctx.itemContentStyle)
      }, [vue.createElementVNode("div", {
        key: "delete-icon",
        class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-delete-item")),
        onClick: function onClick(e) {
          return _ctx.handleRemove(e, file, index);
        }
      }, [_ctx.deleteBtnContent ? (vue.openBlock(), vue.createBlock(_component_t_node, {
        key: 0,
        content: _ctx.deleteBtnContent
      }, null, 8, ["content"])) : (vue.openBlock(), vue.createBlock(_component_close_icon, {
        key: 1,
        class: "close-icon"
      }))], 10, _hoisted_1$2), vue.createElementVNode("img", {
        class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-image")),
        src: file.url,
        onClick: function onClick(e) {
          return _ctx.handlePreview(e, file);
        }
      }, null, 10, _hoisted_2$1), file.status === "fail" ? (vue.openBlock(), vue.createElementBlock("div", {
        key: 0,
        class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-mask"))
      }, [vue.createElementVNode("span", {
        key: "refresh-icon",
        class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-mask-item"))
      }, [vue.createVNode(_component_refresh_icon, {
        onClick: function onClick($event) {
          return _ctx.handleReload(file);
        }
      }, null, 8, ["onClick"])], 2)], 2)) : vue.createCommentVNode("", true)], 6)], 6);
    }), 128)), _ctx.defaultContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.triggerUpload && _ctx.triggerUpload.apply(_ctx, arguments);
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.defaultContent
    }, null, 8, ["content"])])) : (vue.openBlock(), vue.createElementBlock("li", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-item")),
      onClick: _cache[1] || (_cache[1] = function () {
        return _ctx.triggerUpload && _ctx.triggerUpload.apply(_ctx, arguments);
      })
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.UPLOAD_NAME, "__card-container ").concat(_ctx.UPLOAD_NAME, "__card-box"))
    }, [vue.createVNode(_component_add_icon)], 2)], 2))], 2), vue.createElementVNode("input", {
      ref: "inputRef",
      value: _ctx.files,
      type: "file",
      multiple: _ctx.multiple,
      hidden: "",
      accept: _ctx.accept,
      onChange: _cache[2] || (_cache[2] = function () {
        return _ctx.handleChange && _ctx.handleChange.apply(_ctx, arguments);
      })
    }, null, 40, _hoisted_3), vue.createVNode(_component_t_image_viewer, {
      images: _ctx.images,
      "onUpdate:images": _cache[3] || (_cache[3] = function ($event) {
        return _ctx.images = $event;
      }),
      modelValue: _ctx.showViewer,
      "onUpdate:modelValue": _cache[4] || (_cache[4] = function ($event) {
        return _ctx.showViewer = $event;
      }),
      "initial-index": _ctx.initialIndex
    }, null, 8, ["images", "modelValue", "initial-index"])]);
  }

  script$5.render = render$4;

  var _Upload = withInstall(script$5);

  var NoticeBarProps = {
    content: {
      type: [String, Function]
    },
    extra: {
      type: [String, Function]
    },
    marquee: {
      type: [Boolean, Object],
      default: false
    },
    prefixIcon: {
      type: [Boolean, Function],
      default: true
    },
    suffixIcon: {
      type: Function
    },
    theme: {
      type: String,
      default: "info",
      validator: function validator(val) {
        if (!val) return true;
        return ["info", "success", "warning", "error"].includes(val);
      }
    },
    visible: {
      type: Boolean,
      default: void 0
    },
    modelValue: {
      type: Boolean,
      default: void 0
    },
    defaultVisible: Boolean,
    onChange: Function,
    onClick: Function
  };

  function ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$3 = config.prefix;
  var name$3 = "".concat(prefix$3, "-notice-bar");
  var iconDefault$1 = {
    info: vue.h(infoCircleFilled),
    success: vue.h(checkCircleFilled),
    warning: vue.h(infoCircleFilled),
    error: vue.h(closeCircleFilled)
  };
  var script$4 = vue.defineComponent({
    name: name$3,
    components: {
      TNode: TNodeComponent
    },
    props: NoticeBarProps,
    emits: ["click", "change"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var internalInstance = vue.getCurrentInstance();
      var state = vue.reactive({
        duration: 0,
        offset: 0,
        listWidth: 0,
        itemWidth: 0,
        timer: null,
        nextTimer: null,
        scroll: {
          marquee: false,
          speed: 50,
          loop: -1,
          delay: 0
        }
      });
      var rootClasses = vue.computed(function () {
        return ["".concat(name$3), "".concat(name$3, "--").concat(props.theme)];
      });
      var prefixIconContent = vue.computed(function () {
        var iconContent = null;
        if (isFunction$3(props.prefixIcon) || context.slots.prefixIcon) {
          iconContent = renderTNode(internalInstance, "prefixIcon");
        } else if (props.prefixIcon) {
          var key = props.theme;
          iconContent = (iconDefault$1 === null || iconDefault$1 === void 0 ? void 0 : iconDefault$1[key]) || null;
        }
        return iconContent;
      });
      var suffixIconContent = vue.computed(function () {
        return renderTNode(internalInstance, "suffixIcon");
      });
      var showExtraText = vue.computed(function () {
        return renderTNode(internalInstance, "extra");
      });
      var showContent = vue.computed(function () {
        return renderTNode(internalInstance, "content");
      });
      function handleClick(trigger) {
        emitEvent("click", trigger);
      }
      var animateStyle = vue.computed(function () {
        return {
          transform: state.offset ? "translateX(".concat(state.offset, "px)") : "",
          transitionDuration: "".concat(state.duration, "s"),
          transitionTimingFunction: "linear"
        };
      });
      var listDOM = vue.ref();
      var itemDOM = vue.ref();
      var _toRefs = vue.toRefs(props),
        visible = _toRefs.visible,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(visible, modelValue, props.defaultVisible, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        isShow = _useVModel2[0];
        _useVModel2[1];
      function handleScrolling() {
        var _props$marquee, _marquee$speed, _marquee$delay;
        if (!(props !== null && props !== void 0 && props.marquee) || (props === null || props === void 0 ? void 0 : (_props$marquee = props.marquee) === null || _props$marquee === void 0 ? void 0 : _props$marquee.loop) === 0) {
          return;
        }
        if (typeof props.marquee === "boolean") {
          state.scroll = _objectSpread$2(_objectSpread$2({}, state.scroll), {}, {
            marquee: props.marquee
          });
        }
        var marquee = props.marquee;
        state.scroll = {
          marquee: true,
          loop: typeof (marquee === null || marquee === void 0 ? void 0 : marquee.loop) === "undefined" ? state.scroll.loop : marquee.loop,
          speed: (_marquee$speed = marquee.speed) !== null && _marquee$speed !== void 0 ? _marquee$speed : state.scroll.speed,
          delay: (_marquee$delay = marquee.delay) !== null && _marquee$delay !== void 0 ? _marquee$delay : state.scroll.delay
        };
        setTimeout(function () {
          var _listDOM$value, _itemDOM$value;
          var listDOMWidth = (_listDOM$value = listDOM.value) === null || _listDOM$value === void 0 ? void 0 : _listDOM$value.getBoundingClientRect().width;
          var itemDOMWidth = (_itemDOM$value = itemDOM.value) === null || _itemDOM$value === void 0 ? void 0 : _itemDOM$value.getBoundingClientRect().width;
          if (itemDOMWidth > listDOMWidth) {
            state.offset = -itemDOMWidth;
            state.duration = itemDOMWidth / state.scroll.speed;
            state.listWidth = listDOMWidth;
            state.itemWidth = itemDOMWidth;
          }
        }, state.scroll.delay);
      }
      function handleTransitionend() {
        state.scroll.loop = --state.scroll.loop;
        if (state.scroll.loop === 0) {
          state.scroll = _objectSpread$2(_objectSpread$2({}, state.scroll), {}, {
            marquee: false
          });
          return;
        }
        state.offset = state.listWidth;
        state.duration = 0;
        setTimeout(function () {
          state.offset = -state.itemWidth;
          state.duration = (state.itemWidth + state.listWidth) / state.scroll.speed;
        }, 0);
      }
      vue.onMounted(function () {
        vue.nextTick(function () {
          if (isShow.value) {
            handleScrolling();
          }
        });
      });
      vue.watch(function () {
        return isShow.value;
      }, function () {
        emitEvent("change", isShow.value);
        vue.nextTick(function () {
          if (isShow.value) {
            state.offset = state.listWidth;
            state.duration = 0;
            handleScrolling();
          }
        });
      });
      return _objectSpread$2(_objectSpread$2(_objectSpread$2({
        name: name$3
      }, vue.toRefs(props)), vue.toRefs(state)), {}, {
        rootClasses: rootClasses,
        prefixIconContent: prefixIconContent,
        suffixIconContent: suffixIconContent,
        showExtraText: showExtraText,
        showContent: showContent,
        isShow: isShow,
        handleClick: handleClick,
        listDOM: listDOM,
        itemDOM: itemDOM,
        animateStyle: animateStyle,
        handleScrolling: handleScrolling,
        handleTransitionend: handleTransitionend
      });
    }
  });

  function render$3(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    return _ctx.isShow ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass(_ctx.rootClasses)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__inner"))
    }, [_ctx.prefixIconContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__hd")),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.handleClick("prefix-icon");
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.prefixIconContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__bd"))
    }, [vue.createElementVNode("div", {
      ref: "listDOM",
      class: vue.normalizeClass("".concat(_ctx.name, "__list ").concat(_ctx.scroll.marquee ? "".concat(_ctx.name, "__list--scrolling") : ""))
    }, [vue.createElementVNode("div", {
      ref: "itemDOM",
      class: vue.normalizeClass("".concat(_ctx.name, "__item ").concat(_ctx.showExtraText ? "".concat(_ctx.name, "__item-detail") : "")),
      style: vue.normalizeStyle(_ctx.scroll.marquee ? _ctx.animateStyle : ""),
      onTransitionend: _cache[3] || (_cache[3] = function ($event) {
        return _ctx.handleTransitionend();
      })
    }, [vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, "__text")),
      onClick: _cache[2] || (_cache[2] = function () {
        return _ctx.handleClick("content");
      })
    }, [_ctx.showContent ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.showContent
    }, null, 8, ["content"])) : vue.createCommentVNode("", true), vue.createElementVNode("span", {
      class: vue.normalizeClass("".concat(_ctx.name, "__text-detail")),
      onClick: _cache[1] || (_cache[1] = vue.withModifiers(function () {
        return _ctx.handleClick("extra");
      }, ["stop"]))
    }, [_ctx.showExtraText ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.showExtraText
    }, null, 8, ["content"])) : vue.createCommentVNode("", true)], 2)], 2)], 38)], 2)], 2), _ctx.suffixIconContent !== void 0 ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__ft")),
      onClick: _cache[4] || (_cache[4] = function () {
        return _ctx.handleClick("suffix-icon");
      })
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.suffixIconContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2)], 2)) : vue.createCommentVNode("", true);
  }

  script$4.render = render$3;

  var _NoticeBar = withInstall(script$4);

  var resultProps = {
    description: {
      type: [String, Function]
    },
    icon: {
      type: [String, Function]
    },
    image: {
      type: [String, Function]
    },
    title: {
      type: [String, Function]
    },
    theme: {
      type: String,
      default: "default",
      validator: function validator(val) {
        if (!val) return true;
        return ["default", "success", "warning", "error"].includes(val);
      }
    },
    imageProps: {
      type: Object
    }
  };

  function ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$2 = config.prefix;
  var name$2 = "".concat(prefix$2, "-result");
  var iconDefault = {
    default: vue.h(infoCircle),
    success: vue.h(checkCircle),
    warning: vue.h(infoCircle),
    error: vue.h(closeCircle)
  };
  var script$3 = vue.defineComponent({
    name: name$2,
    components: {
      TNode: TNodeComponent
    },
    props: resultProps,
    setup: function setup(props) {
      var internalInstance = vue.getCurrentInstance();
      var imageContent = vue.computed(function () {
        return renderTNode(internalInstance, "image");
      });
      var titleContent = vue.computed(function () {
        return renderTNode(internalInstance, "title");
      });
      var descriptionContent = vue.computed(function () {
        return renderTNode(internalInstance, "description");
      });
      var classes = vue.computed(function () {
        return ["".concat(name$2), "".concat(name$2, "--theme-").concat(props.theme)];
      });
      var iconContent;
      if (props.icon !== "") {
        if (Object.keys(iconDefault).includes(props === null || props === void 0 ? void 0 : props.theme)) {
          var key = props.theme;
          iconContent = vue.computed(function () {
            return iconDefault === null || iconDefault === void 0 ? void 0 : iconDefault[key];
          });
        }
        iconContent = props.icon ? vue.computed(function () {
          return renderTNode(internalInstance, "icon");
        }) : iconContent;
      }
      var baseImageProps = {
        src: props.image
      };
      var customImageProps = vue.computed(function () {
        return _objectSpread$1(_objectSpread$1({}, props.imageProps), baseImageProps);
      });
      return _objectSpread$1({
        name: name$2,
        classes: classes,
        imageContent: imageContent,
        customImageProps: customImageProps,
        iconContent: iconContent,
        titleContent: titleContent,
        descriptionContent: descriptionContent
      }, vue.toRefs(props));
    }
  });

  function render$2(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_image = vue.resolveComponent("t-image");
    var _component_t_node = vue.resolveComponent("t-node");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.classes)
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__thumb"))
    }, [_ctx.imageContent ? (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 0
    }, [typeof _ctx.image === "string" ? (vue.openBlock(), vue.createBlock(_component_t_image, vue.normalizeProps(vue.mergeProps({
      key: 0
    }, _ctx.customImageProps)), null, 16)) : (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 1,
      content: _ctx.imageContent
    }, null, 8, ["content"]))], 64)) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 1
    }, [_ctx.iconContent !== void 0 ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__icon")),
      content: _ctx.iconContent
    }, null, 8, ["class", "content"])) : vue.createCommentVNode("", true)], 64))], 2), _ctx.titleContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 0,
      class: vue.normalizeClass("".concat(_ctx.name, "__title"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.titleContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true), _ctx.descriptionContent ? (vue.openBlock(), vue.createElementBlock("div", {
      key: 1,
      class: vue.normalizeClass("".concat(_ctx.name, "__description"))
    }, [vue.createVNode(_component_t_node, {
      content: _ctx.descriptionContent
    }, null, 8, ["content"])], 2)) : vue.createCommentVNode("", true)], 2);
  }

  script$3.render = render$2;

  var _Result = withInstall(script$3);

  var _hoisted_1$1 = {
    key: 0,
    class: "t-cascader__steps"
  };
  var _hoisted_2 = ["onClick"];
  var script$2 = /* @__PURE__ */vue.defineComponent({
    __name: "steps",
    props: {
      items: Array,
      value: Number
    },
    emits: ["update:value"],
    setup: function setup(__props, _ref) {
      var emit = _ref.emit;
      var handleClick = function handleClick(index) {
        emit("update:value", index);
      };
      return function (_ctx, _cache) {
        return Array.isArray(__props.items) ? (vue.openBlock(), vue.createElementBlock("div", _hoisted_1$1, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(__props.items, function (item, index) {
          return vue.openBlock(), vue.createElementBlock("div", {
            key: index,
            class: "t-cascader__step",
            onClick: function onClick($event) {
              return handleClick(index);
            }
          }, [vue.createElementVNode("div", {
            class: vue.normalizeClass({
              "t-cascader__step-dot": true,
              "t-cascader__step-dot--active": index === __props.value,
              "t-cascader__step-dot--last": index === __props.items.length - 1
            })
          }, null, 2), vue.createElementVNode("div", {
            class: vue.normalizeClass({
              "t-cascader__step-label": true,
              "t-cascader__step-label--active": index === __props.value
            })
          }, vue.toDisplayString(item), 3)], 8, _hoisted_2);
        }), 128))])) : vue.createCommentVNode("", true);
      };
    }
  });

  var CascaderProps = {
    value: {
      type: [String, Number],
      default: void 0
    },
    modelValue: {
      type: [String, Number],
      default: void 0
    },
    options: {
      type: Array,
      default: function _default() {
        return [];
      }
    },
    closeIcon: {
      type: [Boolean, Function],
      default: true
    },
    title: {
      type: [String, Function],
      default: ""
    }
  };

  var CascaderItemProps = {
    value: {
      type: [String, Number],
      default: void 0
    },
    label: {
      type: [String, Function],
      default: ""
    },
    disabled: {
      type: Boolean,
      default: false
    },
    active: {
      type: Boolean,
      default: false
    },
    index: {
      type: String,
      default: ""
    },
    children: {
      type: [Array],
      default: []
    },
    selected: {
      type: Boolean,
      default: false
    }
  };

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty$2(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
  var prefix$1 = config.prefix;
  var name$1 = "".concat(prefix$1, "-cascader-item");
  var script$1 = vue.defineComponent({
    name: name$1,
    components: {
      CheckIcon: check
    },
    props: CascaderItemProps,
    emits: ["click"],
    setup: function setup(props, context) {
      var className = vue.computed(function () {
        return ["".concat(name$1), Boolean(props.active) && "active", Boolean(props.disabled) && "disabled"];
      });
      var internalInstance = vue.getCurrentInstance();
      var labelTNode = vue.computed(function () {
        return renderTNode(internalInstance, "label");
      });
      var emitEvent = useEmitEvent(props, context.emit);
      var onSelect = function onSelect(context2) {
        emitEvent("click", {
          e: context2.e
        });
      };
      var label = vue.computed(function () {
        return props.label;
      });
      return _objectSpread({
        labelTNode: labelTNode,
        name: name$1,
        label: label,
        className: className,
        onSelect: onSelect
      }, vue.toRefs(props));
    }
  });

  function render$1(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_check_icon = vue.resolveComponent("check-icon");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass(_ctx.className),
      onClick: _cache[0] || (_cache[0] = function ($event) {
        return _ctx.onSelect({
          e: $event
        });
      })
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-content"))
    }, vue.toDisplayString(_ctx.label), 3), vue.withDirectives(vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "-active-icon"))
    }, [vue.createVNode(_component_check_icon, {
      size: "24"
    })], 2), [[vue.vShow, _ctx.active]])], 2);
  }

  script$1.render = render$1;

  var prefix = config.prefix;
  var name = "".concat(prefix, "-cascader");
  var script = vue.defineComponent({
    name: name,
    components: {
      CloseIcon: close,
      CascaderItem: script$1,
      TNode: TNodeComponent,
      CascaderSteps: script$2
    },
    props: CascaderProps,
    emits: ["change", "cancel", "pick", "click-tab", "update:modelValue", "update:value"],
    setup: function setup(props, context) {
      var emitEvent = useEmitEvent(props, context.emit);
      var _toRefs = vue.toRefs(props),
        value = _toRefs.value,
        modelValue = _toRefs.modelValue;
      var _useVModel = useVModel(value, modelValue, props.defaultValue, props.onChange),
        _useVModel2 = _slicedToArray(_useVModel, 2),
        cascaderValue = _useVModel2[0],
        setCascaderValue = _useVModel2[1];
      var title = vue.computed(function () {
        return props.title || "\u6807\u9898";
      });
      var closeIcon = vue.computed(function () {
        return props.closeIcon || false;
      });
      var stepIndex = vue.ref(0);
      var selectedIndexes = vue.reactive([]);
      var items = vue.reactive([props.options]);
      var steps = vue.reactive(["\u9009\u62E9\u9009\u9879"]);
      var onCancel = function onCancel(e) {
        emitEvent("cancel", {
          e: e
        });
      };
      var onStepsChange = function onStepsChange(index) {
        stepIndex.value = index;
        emitEvent("click-tab", index);
      };
      var internalInstance = vue.getCurrentInstance();
      var closeBtnTNode = vue.computed(function () {
        return renderTNode(internalInstance, "closeIcon");
      });
      var titleTNode = vue.computed(function () {
        return renderTNode(internalInstance, "title");
      });
      var onPick = function onPick(item, index, level, e) {
        var _item$children;
        if (item.disabled) {
          return;
        }
        selectedIndexes[level] = index;
        selectedIndexes.length = level + 1;
        steps[level] = item.label;
        emitEvent("pick", item.value, index, {
          e: e
        });
        if (item !== null && item !== void 0 && (_item$children = item.children) !== null && _item$children !== void 0 && _item$children.length) {
          items[level + 1] = item.children;
          items.length = level + 2;
          stepIndex.value += 1;
          steps[level + 1] = "\u9009\u62E9\u9009\u9879";
          steps.length = level + 2;
        } else {
          setCascaderValue(item.value);
          emitEvent("change", item.value, items.map(function (item2, index2) {
            return vue.toRaw(item2[selectedIndexes[index2]]);
          }), {
            e: e
          });
        }
      };
      return {
        closeBtnTNode: closeBtnTNode,
        titleTNode: titleTNode,
        stepIndex: stepIndex,
        name: name,
        title: title,
        closeIcon: closeIcon,
        cascaderValue: cascaderValue,
        steps: steps,
        selectedIndexes: selectedIndexes,
        items: items,
        setCascaderValue: setCascaderValue,
        emitEvent: emitEvent,
        onCancel: onCancel,
        onPick: onPick,
        onStepsChange: onStepsChange
      };
    }
  });

  var _hoisted_1 = {
    style: {
      "width": "100%"
    }
  };
  function render(_ctx, _cache, $props, $setup, $data, $options) {
    var _component_t_node = vue.resolveComponent("t-node");
    var _component_close_icon = vue.resolveComponent("close-icon");
    var _component_cascader_steps = vue.resolveComponent("cascader-steps");
    var _component_cascader_item = vue.resolveComponent("cascader-item");
    return vue.openBlock(), vue.createElementBlock("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__wrapper"))
    }, [vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__title"))
    }, [!(typeof _ctx.titleTNode === "string") ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.titleTNode
    }, null, 8, ["content"])) : (vue.openBlock(), vue.createElementBlock(vue.Fragment, {
      key: 1
    }, [vue.createTextVNode(vue.toDisplayString(_ctx.title), 1)], 64))], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__close-btn")),
      onClick: _cache[0] || (_cache[0] = function () {
        return _ctx.onCancel && _ctx.onCancel.apply(_ctx, arguments);
      })
    }, [!(typeof _ctx.closeBtnTNode === "boolean") ? (vue.openBlock(), vue.createBlock(_component_t_node, {
      key: 0,
      content: _ctx.closeBtnTNode
    }, null, 8, ["content"])) : typeof _ctx.closeIcon === "boolean" && _ctx.closeIcon ? (vue.openBlock(), vue.createBlock(_component_close_icon, {
      key: 1,
      size: "24"
    })) : vue.createCommentVNode("", true)], 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__content"))
    }, [vue.createVNode(_component_cascader_steps, {
      value: _ctx.stepIndex,
      items: _ctx.steps,
      "onUpdate:value": _ctx.onStepsChange
    }, null, 8, ["value", "items", "onUpdate:value"]), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__options-title"))
    }, "\u9009\u9879\u6807\u9898", 2), vue.createElementVNode("div", {
      class: vue.normalizeClass("".concat(_ctx.name, "__options-content"))
    }, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(_ctx.items, function (options, index) {
      return vue.openBlock(), vue.createElementBlock("div", {
        key: index,
        style: {
          "width": "100%"
        }
      }, [vue.createVNode(vue.Transition, {
        appear: "",
        name: "slide"
      }, {
        default: vue.withCtx(function () {
          return [vue.withDirectives(vue.createElementVNode("div", _hoisted_1, [(vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(options, function (item, idx) {
            return vue.openBlock(), vue.createBlock(_component_cascader_item, vue.mergeProps({
              key: item.value
            }, item, {
              active: _ctx.selectedIndexes[index] === idx,
              onClick: function onClick($event) {
                return _ctx.onPick(item, idx, index, $event);
              }
            }), null, 16, ["active", "onClick"]);
          }), 128))], 512), [[vue.vShow, _ctx.stepIndex === index]])];
        }),
        _: 2
      }, 1024)]);
    }), 128))], 2)], 2)], 2);
  }

  script.render = render;

  var _Cascader = withInstall(script);

  var components = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Button: _Button,
    ButtonGroup: _ButtonGroup,
    Divider: Divider,
    Calendar: _Calendar,
    Cell: _Cell,
    CellGroup: _CellGroup,
    Checkbox: CheckBox,
    CheckboxGroup: CheckboxGroup,
    Input: _Input,
    Textarea: _Textarea,
    Overlay: Overlay,
    Progress: _Progress,
    Radio: _Radio,
    RadioGroup: _RadioGroup,
    Rate: _Rate,
    Switch: _Switch,
    Stepper: Stepper,
    Slider: _Slider,
    Dialog: DialogPlugin,
    Popup: _Popup,
    ActionSheet: _ActionSheet,
    Badge: _Badge,
    Fab: _Fab,
    ImageViewer: _ImageViewer,
    Drawer: _Drawer,
    Navbar: _Navbar,
    Message: MessagePlugin,
    DateTimePicker: _DateTimePicker,
    Toast: ToastPlugin,
    Search: _Search,
    Steps: Steps,
    Step: Step,
    Indexes: Indexes,
    IndexesCell: IndexesCell,
    Picker: Picker,
    Cascade: Cascade,
    Tag: Tag,
    CheckTag: CheckTag,
    TabBar: TabBar,
    TabBarItem: TabBarItem,
    DropdownMenu: DropdownMenu,
    DropdownItem: DropdownItem,
    Collapse: Collapse,
    CollapsePanel: CollapsePanel,
    Tabs: Tabs,
    TabPanel: TabPanel,
    Swiper: Swiper,
    SwiperItem: SwiperItem,
    Countdown: Countdown,
    Avatar: Avatar,
    AvatarGroup: AvatarGroup,
    Image: _Image,
    SwipeCell: SwipeCell,
    Skeleton: _Skeleton,
    Grid: Grid,
    GridItem: GridItem,
    Sticky: _Sticky,
    List: _List,
    Loading: _Loading,
    BackTop: _BackTop,
    PullDownRefresh: _PullDownRefresh,
    Upload: _Upload,
    NoticeBar: _NoticeBar,
    Result: _Result,
    Cascader: _Cascader
  });

  var install = function install(app, option) {
    Object.keys(components).forEach(function (key) {
      app.use(components[key], option);
    });
  };
  var version = "0.14.1";
  var index = {
    install: install,
    version: version
  };

  exports.ActionSheet = _ActionSheet;
  exports.Avatar = Avatar;
  exports.AvatarGroup = AvatarGroup;
  exports.BackTop = _BackTop;
  exports.Badge = _Badge;
  exports.Button = _Button;
  exports.ButtonGroup = _ButtonGroup;
  exports.Calendar = _Calendar;
  exports.Cascade = Cascade;
  exports.Cascader = _Cascader;
  exports.Cell = _Cell;
  exports.CellGroup = _CellGroup;
  exports.CheckTag = CheckTag;
  exports.Checkbox = CheckBox;
  exports.CheckboxGroup = CheckboxGroup;
  exports.Collapse = Collapse;
  exports.CollapsePanel = CollapsePanel;
  exports.Countdown = Countdown;
  exports.DateTimePicker = _DateTimePicker;
  exports.Dialog = DialogPlugin;
  exports.DialogPlugin = DialogPlugin;
  exports.Divider = Divider;
  exports.Drawer = _Drawer;
  exports.DropdownItem = DropdownItem;
  exports.DropdownMenu = DropdownMenu;
  exports.Fab = _Fab;
  exports.Grid = Grid;
  exports.GridItem = GridItem;
  exports.Image = _Image;
  exports.ImageViewer = _ImageViewer;
  exports.Indexes = Indexes;
  exports.IndexesCell = IndexesCell;
  exports.Input = _Input;
  exports.List = _List;
  exports.Loading = _Loading;
  exports.Message = MessagePlugin;
  exports.MessagePlugin = MessagePlugin;
  exports.Navbar = _Navbar;
  exports.NoticeBar = _NoticeBar;
  exports.Overlay = Overlay;
  exports.Picker = Picker;
  exports.Popup = _Popup;
  exports.Progress = _Progress;
  exports.PullDownRefresh = _PullDownRefresh;
  exports.Radio = _Radio;
  exports.RadioGroup = _RadioGroup;
  exports.Rate = _Rate;
  exports.Result = _Result;
  exports.Search = _Search;
  exports.Skeleton = _Skeleton;
  exports.Slider = _Slider;
  exports.Step = Step;
  exports.Stepper = Stepper;
  exports.Steps = Steps;
  exports.Sticky = _Sticky;
  exports.SwipeCell = SwipeCell;
  exports.Swiper = Swiper;
  exports.SwiperItem = SwiperItem;
  exports.Switch = _Switch;
  exports.TabBar = TabBar;
  exports.TabBarItem = TabBarItem;
  exports.TabPanel = TabPanel;
  exports.Tabs = Tabs;
  exports.Tag = Tag;
  exports.Textarea = _Textarea;
  exports.Toast = ToastPlugin;
  exports.ToastPlugin = ToastPlugin;
  exports.Upload = _Upload;
  exports["default"] = index;
  exports.install = install;
  exports.version = version;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=tdesign.js.map
